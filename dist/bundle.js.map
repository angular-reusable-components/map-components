{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({\"./src/index.js\":[function(require,module,exports){\nvar mapbox    = require('mapbox.js');\nvar toque     = require('torque.js');\n\nvar module = angular.module('MapComponents', []);\n\nmodule.directive('map', require('./directives/map_directive'));\n\n},{\"./directives/map_directive\":\"/Users/tiatia/projects/reusable-components/map-components/src/directives/map_directive.js\",\"mapbox.js\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/index.js\",\"torque.js\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/lib/_empty.js\":[function(require,module,exports){\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/assert/assert.js\":[function(require,module,exports){\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// when used in node, this will actually load the util module we depend on\n// versus loading the builtin util module as happens otherwise\n// this is a bug in node module loading as far as I am concerned\nvar util = require('util/');\n\nvar pSlice = Array.prototype.slice;\nvar hasOwn = Object.prototype.hasOwnProperty;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n  else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = stackStartFunction.name;\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && !isFinite(value)) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction getMessage(self) {\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b)) {\n    return a === b;\n  }\n  var aIsArgs = isArguments(a),\n      bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  var ka = objectKeys(a),\n      kb = objectKeys(b),\n      key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n},{\"util/\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/util/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/inherits/inherits_browser.js\":[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/path-browserify/index.js\":[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/process/browser.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/process/browser.js\":[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/util/support/isBufferBrowser.js\":[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/util/util.js\":[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/util/support/isBufferBrowser.js\",\"_process\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/process/browser.js\",\"inherits\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/inherits/inherits_browser.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/corslite/corslite.js\":[function(require,module,exports){\nfunction corslite(url, callback, cors) {\n    var sent = false;\n\n    if (typeof window.XMLHttpRequest === 'undefined') {\n        return callback(Error('Browser not supported'));\n    }\n\n    if (typeof cors === 'undefined') {\n        var m = url.match(/^\\s*https?:\\/\\/[^\\/]*/);\n        cors = m && (m[0] !== location.protocol + '//' + location.domain +\n                (location.port ? ':' + location.port : ''));\n    }\n\n    var x = new window.XMLHttpRequest();\n\n    function isSuccessful(status) {\n        return status >= 200 && status < 300 || status === 304;\n    }\n\n    if (cors && !('withCredentials' in x)) {\n        // IE8-9\n        x = new window.XDomainRequest();\n\n        // Ensure callback is never called synchronously, i.e., before\n        // x.send() returns (this has been observed in the wild).\n        // See https://github.com/mapbox/mapbox.js/issues/472\n        var original = callback;\n        callback = function() {\n            if (sent) {\n                original.apply(this, arguments);\n            } else {\n                var that = this, args = arguments;\n                setTimeout(function() {\n                    original.apply(that, args);\n                }, 0);\n            }\n        }\n    }\n\n    function loaded() {\n        if (\n            // XDomainRequest\n            x.status === undefined ||\n            // modern browsers\n            isSuccessful(x.status)) callback.call(x, null, x);\n        else callback.call(x, x, null);\n    }\n\n    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`\n    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).\n    if ('onload' in x) {\n        x.onload = loaded;\n    } else {\n        x.onreadystatechange = function readystate() {\n            if (x.readyState === 4) {\n                loaded();\n            }\n        };\n    }\n\n    // Call the callback with the XMLHttpRequest object as an error and prevent\n    // it from ever being called again by reassigning it to `noop`\n    x.onerror = function error(evt) {\n        // XDomainRequest provides no evt parameter\n        callback.call(this, evt || true, null);\n        callback = function() { };\n    };\n\n    // IE9 must have onprogress be set to a unique function.\n    x.onprogress = function() { };\n\n    x.ontimeout = function(evt) {\n        callback.call(this, evt, null);\n        callback = function() { };\n    };\n\n    x.onabort = function(evt) {\n        callback.call(this, evt, null);\n        callback = function() { };\n    };\n\n    // GET is the only supported HTTP Verb by XDomainRequest and is the\n    // only one supported here.\n    x.open('GET', url, true);\n\n    // Send the request. Sending data is not supported.\n    x.send(null);\n    sent = true;\n\n    return x;\n}\n\nif (typeof module !== 'undefined') module.exports = corslite;\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/leaflet/dist/leaflet-src.js\":[function(require,module,exports){\n/*\n Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com\n (c) 2010-2013, Vladimir Agafonkin\n (c) 2010-2011, CloudMade\n*/\n(function (window, document, undefined) {\r\nvar oldL = window.L,\r\n    L = {};\r\n\r\nL.version = '0.7.2';\r\n\r\n// define Leaflet for Node module pattern loaders, including Browserify\r\nif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\tmodule.exports = L;\r\n\r\n// define Leaflet as an AMD module\r\n} else if (typeof define === 'function' && define.amd) {\r\n\tdefine(L);\r\n}\r\n\r\n// define Leaflet as a global L variable, saving the original L to restore later if needed\r\n\r\nL.noConflict = function () {\r\n\twindow.L = oldL;\r\n\treturn this;\r\n};\r\n\r\nwindow.L = L;\r\n\n\n/*\r\n * L.Util contains various utility functions used throughout Leaflet code.\r\n */\r\n\r\nL.Util = {\r\n\textend: function (dest) { // (Object[, Object, ...]) ->\r\n\t\tvar sources = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, j, len, src;\r\n\r\n\t\tfor (j = 0, len = sources.length; j < len; j++) {\r\n\t\t\tsrc = sources[j] || {};\r\n\t\t\tfor (i in src) {\r\n\t\t\t\tif (src.hasOwnProperty(i)) {\r\n\t\t\t\t\tdest[i] = src[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dest;\r\n\t},\r\n\r\n\tbind: function (fn, obj) { // (Function, Object) -> Function\r\n\t\tvar args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;\r\n\t\treturn function () {\r\n\t\t\treturn fn.apply(obj, args || arguments);\r\n\t\t};\r\n\t},\r\n\r\n\tstamp: (function () {\r\n\t\tvar lastId = 0,\r\n\t\t    key = '_leaflet_id';\r\n\t\treturn function (obj) {\r\n\t\t\tobj[key] = obj[key] || ++lastId;\r\n\t\t\treturn obj[key];\r\n\t\t};\r\n\t}()),\r\n\r\n\tinvokeEach: function (obj, method, context) {\r\n\t\tvar i, args;\r\n\r\n\t\tif (typeof obj === 'object') {\r\n\t\t\targs = Array.prototype.slice.call(arguments, 3);\r\n\r\n\t\t\tfor (i in obj) {\r\n\t\t\t\tmethod.apply(context, [i, obj[i]].concat(args));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\tlimitExecByInterval: function (fn, time, context) {\r\n\t\tvar lock, execOnUnlock;\r\n\r\n\t\treturn function wrapperFn() {\r\n\t\t\tvar args = arguments;\r\n\r\n\t\t\tif (lock) {\r\n\t\t\t\texecOnUnlock = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlock = true;\r\n\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tlock = false;\r\n\r\n\t\t\t\tif (execOnUnlock) {\r\n\t\t\t\t\twrapperFn.apply(context, args);\r\n\t\t\t\t\texecOnUnlock = false;\r\n\t\t\t\t}\r\n\t\t\t}, time);\r\n\r\n\t\t\tfn.apply(context, args);\r\n\t\t};\r\n\t},\r\n\r\n\tfalseFn: function () {\r\n\t\treturn false;\r\n\t},\r\n\r\n\tformatNum: function (num, digits) {\r\n\t\tvar pow = Math.pow(10, digits || 5);\r\n\t\treturn Math.round(num * pow) / pow;\r\n\t},\r\n\r\n\ttrim: function (str) {\r\n\t\treturn str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\r\n\t},\r\n\r\n\tsplitWords: function (str) {\r\n\t\treturn L.Util.trim(str).split(/\\s+/);\r\n\t},\r\n\r\n\tsetOptions: function (obj, options) {\r\n\t\tobj.options = L.extend({}, obj.options, options);\r\n\t\treturn obj.options;\r\n\t},\r\n\r\n\tgetParamString: function (obj, existingUrl, uppercase) {\r\n\t\tvar params = [];\r\n\t\tfor (var i in obj) {\r\n\t\t\tparams.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));\r\n\t\t}\r\n\t\treturn ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');\r\n\t},\r\n\ttemplate: function (str, data) {\r\n\t\treturn str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\r\n\t\t\tvar value = data[key];\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tthrow new Error('No value provided for variable ' + str);\r\n\t\t\t} else if (typeof value === 'function') {\r\n\t\t\t\tvalue = value(data);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t});\r\n\t},\r\n\r\n\tisArray: Array.isArray || function (obj) {\r\n\t\treturn (Object.prototype.toString.call(obj) === '[object Array]');\r\n\t},\r\n\r\n\temptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\r\n};\r\n\r\n(function () {\r\n\r\n\t// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n\r\n\tfunction getPrefixed(name) {\r\n\t\tvar i, fn,\r\n\t\t    prefixes = ['webkit', 'moz', 'o', 'ms'];\r\n\r\n\t\tfor (i = 0; i < prefixes.length && !fn; i++) {\r\n\t\t\tfn = window[prefixes[i] + name];\r\n\t\t}\r\n\r\n\t\treturn fn;\r\n\t}\r\n\r\n\tvar lastTime = 0;\r\n\r\n\tfunction timeoutDefer(fn) {\r\n\t\tvar time = +new Date(),\r\n\t\t    timeToCall = Math.max(0, 16 - (time - lastTime));\r\n\r\n\t\tlastTime = time + timeToCall;\r\n\t\treturn window.setTimeout(fn, timeToCall);\r\n\t}\r\n\r\n\tvar requestFn = window.requestAnimationFrame ||\r\n\t        getPrefixed('RequestAnimationFrame') || timeoutDefer;\r\n\r\n\tvar cancelFn = window.cancelAnimationFrame ||\r\n\t        getPrefixed('CancelAnimationFrame') ||\r\n\t        getPrefixed('CancelRequestAnimationFrame') ||\r\n\t        function (id) { window.clearTimeout(id); };\r\n\r\n\r\n\tL.Util.requestAnimFrame = function (fn, context, immediate, element) {\r\n\t\tfn = L.bind(fn, context);\r\n\r\n\t\tif (immediate && requestFn === timeoutDefer) {\r\n\t\t\tfn();\r\n\t\t} else {\r\n\t\t\treturn requestFn.call(window, fn, element);\r\n\t\t}\r\n\t};\r\n\r\n\tL.Util.cancelAnimFrame = function (id) {\r\n\t\tif (id) {\r\n\t\t\tcancelFn.call(window, id);\r\n\t\t}\r\n\t};\r\n\r\n}());\r\n\r\n// shortcuts for most used utility functions\r\nL.extend = L.Util.extend;\r\nL.bind = L.Util.bind;\r\nL.stamp = L.Util.stamp;\r\nL.setOptions = L.Util.setOptions;\r\n\n\n/*\r\n * L.Class powers the OOP facilities of the library.\r\n * Thanks to John Resig and Dean Edwards for inspiration!\r\n */\r\n\r\nL.Class = function () {};\r\n\r\nL.Class.extend = function (props) {\r\n\r\n\t// extended class with the new prototype\r\n\tvar NewClass = function () {\r\n\r\n\t\t// call the constructor\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\t// call all constructor hooks\r\n\t\tif (this._initHooks) {\r\n\t\t\tthis.callInitHooks();\r\n\t\t}\r\n\t};\r\n\r\n\t// instantiate class without calling constructor\r\n\tvar F = function () {};\r\n\tF.prototype = this.prototype;\r\n\r\n\tvar proto = new F();\r\n\tproto.constructor = NewClass;\r\n\r\n\tNewClass.prototype = proto;\r\n\r\n\t//inherit parent's statics\r\n\tfor (var i in this) {\r\n\t\tif (this.hasOwnProperty(i) && i !== 'prototype') {\r\n\t\t\tNewClass[i] = this[i];\r\n\t\t}\r\n\t}\r\n\r\n\t// mix static properties into the class\r\n\tif (props.statics) {\r\n\t\tL.extend(NewClass, props.statics);\r\n\t\tdelete props.statics;\r\n\t}\r\n\r\n\t// mix includes into the prototype\r\n\tif (props.includes) {\r\n\t\tL.Util.extend.apply(null, [proto].concat(props.includes));\r\n\t\tdelete props.includes;\r\n\t}\r\n\r\n\t// merge options\r\n\tif (props.options && proto.options) {\r\n\t\tprops.options = L.extend({}, proto.options, props.options);\r\n\t}\r\n\r\n\t// mix given properties into the prototype\r\n\tL.extend(proto, props);\r\n\r\n\tproto._initHooks = [];\r\n\r\n\tvar parent = this;\r\n\t// jshint camelcase: false\r\n\tNewClass.__super__ = parent.prototype;\r\n\r\n\t// add method for calling all hooks\r\n\tproto.callInitHooks = function () {\r\n\r\n\t\tif (this._initHooksCalled) { return; }\r\n\r\n\t\tif (parent.prototype.callInitHooks) {\r\n\t\t\tparent.prototype.callInitHooks.call(this);\r\n\t\t}\r\n\r\n\t\tthis._initHooksCalled = true;\r\n\r\n\t\tfor (var i = 0, len = proto._initHooks.length; i < len; i++) {\r\n\t\t\tproto._initHooks[i].call(this);\r\n\t\t}\r\n\t};\r\n\r\n\treturn NewClass;\r\n};\r\n\r\n\r\n// method for adding properties to prototype\r\nL.Class.include = function (props) {\r\n\tL.extend(this.prototype, props);\r\n};\r\n\r\n// merge new default options to the Class\r\nL.Class.mergeOptions = function (options) {\r\n\tL.extend(this.prototype.options, options);\r\n};\r\n\r\n// add a constructor hook\r\nL.Class.addInitHook = function (fn) { // (Function) || (String, args...)\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\tvar init = typeof fn === 'function' ? fn : function () {\r\n\t\tthis[fn].apply(this, args);\r\n\t};\r\n\r\n\tthis.prototype._initHooks = this.prototype._initHooks || [];\r\n\tthis.prototype._initHooks.push(init);\r\n};\r\n\n\n/*\r\n * L.Mixin.Events is used to add custom events functionality to Leaflet classes.\r\n */\r\n\r\nvar eventsKey = '_leaflet_events';\r\n\r\nL.Mixin = {};\r\n\r\nL.Mixin.Events = {\r\n\r\n\taddEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])\r\n\r\n\t\t// types can be a map of types/handlers\r\n\t\tif (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey] = this[eventsKey] || {},\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, event, type, indexKey, indexLenKey, typeIndex;\r\n\r\n\t\t// types can be a string of space-separated words\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\tevent = {\r\n\t\t\t\taction: fn,\r\n\t\t\t\tcontext: context || this\r\n\t\t\t};\r\n\t\t\ttype = types[i];\r\n\r\n\t\t\tif (contextId) {\r\n\t\t\t\t// store listeners of a particular context in a separate hash (if it has an id)\r\n\t\t\t\t// gives a major performance boost when removing thousands of map layers\r\n\r\n\t\t\t\tindexKey = type + '_idx';\r\n\t\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\t\ttypeIndex = events[indexKey] = events[indexKey] || {};\r\n\r\n\t\t\t\tif (!typeIndex[contextId]) {\r\n\t\t\t\t\ttypeIndex[contextId] = [];\r\n\r\n\t\t\t\t\t// keep track of the number of keys in the index to quickly check if it's empty\r\n\t\t\t\t\tevents[indexLenKey] = (events[indexLenKey] || 0) + 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttypeIndex[contextId].push(event);\r\n\r\n\r\n\t\t\t} else {\r\n\t\t\t\tevents[type] = events[type] || [];\r\n\t\t\t\tevents[type].push(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasEventListeners: function (type) { // (String) -> Boolean\r\n\t\tvar events = this[eventsKey];\r\n\t\treturn !!events && ((type in events && events[type].length > 0) ||\r\n\t\t                    (type + '_idx' in events && events[type + '_idx_len'] > 0));\r\n\t},\r\n\r\n\tremoveEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])\r\n\r\n\t\tif (!this[eventsKey]) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif (!types) {\r\n\t\t\treturn this.clearAllEventListeners();\r\n\t\t}\r\n\r\n\t\tif (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    contextId = context && context !== this && L.stamp(context),\r\n\t\t    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;\r\n\r\n\t\ttypes = L.Util.splitWords(types);\r\n\r\n\t\tfor (i = 0, len = types.length; i < len; i++) {\r\n\t\t\ttype = types[i];\r\n\t\t\tindexKey = type + '_idx';\r\n\t\t\tindexLenKey = indexKey + '_len';\r\n\r\n\t\t\ttypeIndex = events[indexKey];\r\n\r\n\t\t\tif (!fn) {\r\n\t\t\t\t// clear all listeners for a type if function isn't specified\r\n\t\t\t\tdelete events[type];\r\n\t\t\t\tdelete events[indexKey];\r\n\t\t\t\tdelete events[indexLenKey];\r\n\r\n\t\t\t} else {\r\n\t\t\t\tlisteners = contextId && typeIndex ? typeIndex[contextId] : events[type];\r\n\r\n\t\t\t\tif (listeners) {\r\n\t\t\t\t\tfor (j = listeners.length - 1; j >= 0; j--) {\r\n\t\t\t\t\t\tif ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {\r\n\t\t\t\t\t\t\tremoved = listeners.splice(j, 1);\r\n\t\t\t\t\t\t\t// set the old action to a no-op, because it is possible\r\n\t\t\t\t\t\t\t// that the listener is being iterated over as part of a dispatch\r\n\t\t\t\t\t\t\tremoved[0].action = L.Util.falseFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (context && typeIndex && (listeners.length === 0)) {\r\n\t\t\t\t\t\tdelete typeIndex[contextId];\r\n\t\t\t\t\t\tevents[indexLenKey]--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclearAllEventListeners: function () {\r\n\t\tdelete this[eventsKey];\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfireEvent: function (type, data) { // (String[, Object])\r\n\t\tif (!this.hasEventListeners(type)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar event = L.Util.extend({}, data, { type: type, target: this });\r\n\r\n\t\tvar events = this[eventsKey],\r\n\t\t    listeners, i, len, typeIndex, contextId;\r\n\r\n\t\tif (events[type]) {\r\n\t\t\t// make sure adding/removing listeners inside other listeners won't cause infinite loop\r\n\t\t\tlisteners = events[type].slice();\r\n\r\n\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// fire event for the context-indexed listeners as well\r\n\t\ttypeIndex = events[type + '_idx'];\r\n\r\n\t\tfor (contextId in typeIndex) {\r\n\t\t\tlisteners = typeIndex[contextId].slice();\r\n\r\n\t\t\tif (listeners) {\r\n\t\t\t\tfor (i = 0, len = listeners.length; i < len; i++) {\r\n\t\t\t\t\tlisteners[i].action.call(listeners[i].context, event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOneTimeEventListener: function (types, fn, context) {\r\n\r\n\t\tif (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }\r\n\r\n\t\tvar handler = L.bind(function () {\r\n\t\t\tthis\r\n\t\t\t    .removeEventListener(types, fn, context)\r\n\t\t\t    .removeEventListener(types, handler, context);\r\n\t\t}, this);\r\n\r\n\t\treturn this\r\n\t\t    .addEventListener(types, fn, context)\r\n\t\t    .addEventListener(types, handler, context);\r\n\t}\r\n};\r\n\r\nL.Mixin.Events.on = L.Mixin.Events.addEventListener;\r\nL.Mixin.Events.off = L.Mixin.Events.removeEventListener;\r\nL.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;\r\nL.Mixin.Events.fire = L.Mixin.Events.fireEvent;\r\n\n\n/*\r\n * L.Browser handles different browser and feature detections for internal Leaflet use.\r\n */\r\n\r\n(function () {\r\n\r\n\tvar ie = 'ActiveXObject' in window,\r\n\t\tielt9 = ie && !document.addEventListener,\r\n\r\n\t    // terrible browser detection to work around Safari / iOS / Android browser bugs\r\n\t    ua = navigator.userAgent.toLowerCase(),\r\n\t    webkit = ua.indexOf('webkit') !== -1,\r\n\t    chrome = ua.indexOf('chrome') !== -1,\r\n\t    phantomjs = ua.indexOf('phantom') !== -1,\r\n\t    android = ua.indexOf('android') !== -1,\r\n\t    android23 = ua.search('android [23]') !== -1,\r\n\t\tgecko = ua.indexOf('gecko') !== -1,\r\n\r\n\t    mobile = typeof orientation !== undefined + '',\r\n\t    msPointer = window.navigator && window.navigator.msPointerEnabled &&\r\n\t              window.navigator.msMaxTouchPoints && !window.PointerEvent,\r\n\t\tpointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||\r\n\t\t\t\t  msPointer,\r\n\t    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||\r\n\t             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&\r\n\t              window.matchMedia('(min-resolution:144dpi)').matches),\r\n\r\n\t    doc = document.documentElement,\r\n\t    ie3d = ie && ('transition' in doc.style),\r\n\t    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,\r\n\t    gecko3d = 'MozPerspective' in doc.style,\r\n\t    opera3d = 'OTransition' in doc.style,\r\n\t    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;\r\n\r\n\r\n\t// PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.\r\n\t// https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151\r\n\r\n\tvar touch = !window.L_NO_TOUCH && !phantomjs && (function () {\r\n\r\n\t\tvar startName = 'ontouchstart';\r\n\r\n\t\t// IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.\r\n\t\tif (pointer || (startName in doc)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Firefox/Gecko\r\n\t\tvar div = document.createElement('div'),\r\n\t\t    supported = false;\r\n\r\n\t\tif (!div.setAttribute) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tdiv.setAttribute(startName, 'return;');\r\n\r\n\t\tif (typeof div[startName] === 'function') {\r\n\t\t\tsupported = true;\r\n\t\t}\r\n\r\n\t\tdiv.removeAttribute(startName);\r\n\t\tdiv = null;\r\n\r\n\t\treturn supported;\r\n\t}());\r\n\r\n\r\n\tL.Browser = {\r\n\t\tie: ie,\r\n\t\tielt9: ielt9,\r\n\t\twebkit: webkit,\r\n\t\tgecko: gecko && !webkit && !window.opera && !ie,\r\n\r\n\t\tandroid: android,\r\n\t\tandroid23: android23,\r\n\r\n\t\tchrome: chrome,\r\n\r\n\t\tie3d: ie3d,\r\n\t\twebkit3d: webkit3d,\r\n\t\tgecko3d: gecko3d,\r\n\t\topera3d: opera3d,\r\n\t\tany3d: any3d,\r\n\r\n\t\tmobile: mobile,\r\n\t\tmobileWebkit: mobile && webkit,\r\n\t\tmobileWebkit3d: mobile && webkit3d,\r\n\t\tmobileOpera: mobile && window.opera,\r\n\r\n\t\ttouch: touch,\r\n\t\tmsPointer: msPointer,\r\n\t\tpointer: pointer,\r\n\r\n\t\tretina: retina\r\n\t};\r\n\r\n}());\r\n\n\n/*\r\n * L.Point represents a point with x and y coordinates.\r\n */\r\n\r\nL.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\tthis.y = (round ? Math.round(y) : y);\r\n};\r\n\r\nL.Point.prototype = {\r\n\r\n\tclone: function () {\r\n\t\treturn new L.Point(this.x, this.y);\r\n\t},\r\n\r\n\t// non-destructive, returns a new point\r\n\tadd: function (point) {\r\n\t\treturn this.clone()._add(L.point(point));\r\n\t},\r\n\r\n\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t_add: function (point) {\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(L.point(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\tequals: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\tcontains: function (point) {\r\n\t\tpoint = L.point(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        L.Util.formatNum(this.x) + ', ' +\r\n\t\t        L.Util.formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\nL.point = function (x, y, round) {\r\n\tif (x instanceof L.Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (L.Util.isArray(x)) {\r\n\t\treturn new L.Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\treturn new L.Point(x, y, round);\r\n};\r\n\n\n/*\r\n * L.Bounds represents a rectangular area on the screen in pixel coordinates.\r\n */\r\n\r\nL.Bounds = function (a, b) { //(Point, Point) or Point[]\r\n\tif (!a) { return; }\r\n\r\n\tvar points = b ? [a, b] : a;\r\n\r\n\tfor (var i = 0, len = points.length; i < len; i++) {\r\n\t\tthis.extend(points[i]);\r\n\t}\r\n};\r\n\r\nL.Bounds.prototype = {\r\n\t// extend the bounds to contain the given point\r\n\textend: function (point) { // (Point)\r\n\t\tpoint = L.point(point);\r\n\r\n\t\tif (!this.min && !this.max) {\r\n\t\t\tthis.min = point.clone();\r\n\t\t\tthis.max = point.clone();\r\n\t\t} else {\r\n\t\t\tthis.min.x = Math.min(point.x, this.min.x);\r\n\t\t\tthis.max.x = Math.max(point.x, this.max.x);\r\n\t\t\tthis.min.y = Math.min(point.y, this.min.y);\r\n\t\t\tthis.max.y = Math.max(point.y, this.max.y);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetCenter: function (round) { // (Boolean) -> Point\r\n\t\treturn new L.Point(\r\n\t\t        (this.min.x + this.max.x) / 2,\r\n\t\t        (this.min.y + this.max.y) / 2, round);\r\n\t},\r\n\r\n\tgetBottomLeft: function () { // -> Point\r\n\t\treturn new L.Point(this.min.x, this.max.y);\r\n\t},\r\n\r\n\tgetTopRight: function () { // -> Point\r\n\t\treturn new L.Point(this.max.x, this.min.y);\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\treturn this.max.subtract(this.min);\r\n\t},\r\n\r\n\tcontains: function (obj) { // (Bounds) or (Point) -> Boolean\r\n\t\tvar min, max;\r\n\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.Point) {\r\n\t\t\tobj = L.point(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.bounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.Bounds) {\r\n\t\t\tmin = obj.min;\r\n\t\t\tmax = obj.max;\r\n\t\t} else {\r\n\t\t\tmin = max = obj;\r\n\t\t}\r\n\r\n\t\treturn (min.x >= this.min.x) &&\r\n\t\t       (max.x <= this.max.x) &&\r\n\t\t       (min.y >= this.min.y) &&\r\n\t\t       (max.y <= this.max.y);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (Bounds) -> Boolean\r\n\t\tbounds = L.bounds(bounds);\r\n\r\n\t\tvar min = this.min,\r\n\t\t    max = this.max,\r\n\t\t    min2 = bounds.min,\r\n\t\t    max2 = bounds.max,\r\n\t\t    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),\r\n\t\t    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\r\n\r\n\t\treturn xIntersects && yIntersects;\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this.min && this.max);\r\n\t}\r\n};\r\n\r\nL.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])\r\n\tif (!a || a instanceof L.Bounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.Bounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.\r\n */\r\n\r\nL.Transformation = function (a, b, c, d) {\r\n\tthis._a = a;\r\n\tthis._b = b;\r\n\tthis._c = c;\r\n\tthis._d = d;\r\n};\r\n\r\nL.Transformation.prototype = {\r\n\ttransform: function (point, scale) { // (Point, Number) -> Point\r\n\t\treturn this._transform(point.clone(), scale);\r\n\t},\r\n\r\n\t// destructive transform (faster)\r\n\t_transform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tpoint.x = scale * (this._a * point.x + this._b);\r\n\t\tpoint.y = scale * (this._c * point.y + this._d);\r\n\t\treturn point;\r\n\t},\r\n\r\n\tuntransform: function (point, scale) {\r\n\t\tscale = scale || 1;\r\n\t\treturn new L.Point(\r\n\t\t        (point.x / scale - this._b) / this._a,\r\n\t\t        (point.y / scale - this._d) / this._c);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.DomUtil contains various utility functions for working with DOM.\r\n */\r\n\r\nL.DomUtil = {\r\n\tget: function (id) {\r\n\t\treturn (typeof id === 'string' ? document.getElementById(id) : id);\r\n\t},\r\n\r\n\tgetStyle: function (el, style) {\r\n\r\n\t\tvar value = el.style[style];\r\n\r\n\t\tif (!value && el.currentStyle) {\r\n\t\t\tvalue = el.currentStyle[style];\r\n\t\t}\r\n\r\n\t\tif ((!value || value === 'auto') && document.defaultView) {\r\n\t\t\tvar css = document.defaultView.getComputedStyle(el, null);\r\n\t\t\tvalue = css ? css[style] : null;\r\n\t\t}\r\n\r\n\t\treturn value === 'auto' ? null : value;\r\n\t},\r\n\r\n\tgetViewportOffset: function (element) {\r\n\r\n\t\tvar top = 0,\r\n\t\t    left = 0,\r\n\t\t    el = element,\r\n\t\t    docBody = document.body,\r\n\t\t    docEl = document.documentElement,\r\n\t\t    pos;\r\n\r\n\t\tdo {\r\n\t\t\ttop  += el.offsetTop  || 0;\r\n\t\t\tleft += el.offsetLeft || 0;\r\n\r\n\t\t\t//add borders\r\n\t\t\ttop += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;\r\n\t\t\tleft += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;\r\n\r\n\t\t\tpos = L.DomUtil.getStyle(el, 'position');\r\n\r\n\t\t\tif (el.offsetParent === docBody && pos === 'absolute') { break; }\r\n\r\n\t\t\tif (pos === 'fixed') {\r\n\t\t\t\ttop  += docBody.scrollTop  || docEl.scrollTop  || 0;\r\n\t\t\t\tleft += docBody.scrollLeft || docEl.scrollLeft || 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (pos === 'relative' && !el.offsetLeft) {\r\n\t\t\t\tvar width = L.DomUtil.getStyle(el, 'width'),\r\n\t\t\t\t    maxWidth = L.DomUtil.getStyle(el, 'max-width'),\r\n\t\t\t\t    r = el.getBoundingClientRect();\r\n\r\n\t\t\t\tif (width !== 'none' || maxWidth !== 'none') {\r\n\t\t\t\t\tleft += r.left + el.clientLeft;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate full y offset since we're breaking out of the loop\r\n\t\t\t\ttop += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tel = el.offsetParent;\r\n\r\n\t\t} while (el);\r\n\r\n\t\tel = element;\r\n\r\n\t\tdo {\r\n\t\t\tif (el === docBody) { break; }\r\n\r\n\t\t\ttop  -= el.scrollTop  || 0;\r\n\t\t\tleft -= el.scrollLeft || 0;\r\n\r\n\t\t\tel = el.parentNode;\r\n\t\t} while (el);\r\n\r\n\t\treturn new L.Point(left, top);\r\n\t},\r\n\r\n\tdocumentIsLtr: function () {\r\n\t\tif (!L.DomUtil._docIsLtrCached) {\r\n\t\t\tL.DomUtil._docIsLtrCached = true;\r\n\t\t\tL.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';\r\n\t\t}\r\n\t\treturn L.DomUtil._docIsLtr;\r\n\t},\r\n\r\n\tcreate: function (tagName, className, container) {\r\n\r\n\t\tvar el = document.createElement(tagName);\r\n\t\tel.className = className;\r\n\r\n\t\tif (container) {\r\n\t\t\tcontainer.appendChild(el);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\thasClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\treturn el.classList.contains(name);\r\n\t\t}\r\n\t\tvar className = L.DomUtil._getClass(el);\r\n\t\treturn className.length > 0 && new RegExp('(^|\\\\s)' + name + '(\\\\s|$)').test(className);\r\n\t},\r\n\r\n\taddClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tvar classes = L.Util.splitWords(name);\r\n\t\t\tfor (var i = 0, len = classes.length; i < len; i++) {\r\n\t\t\t\tel.classList.add(classes[i]);\r\n\t\t\t}\r\n\t\t} else if (!L.DomUtil.hasClass(el, name)) {\r\n\t\t\tvar className = L.DomUtil._getClass(el);\r\n\t\t\tL.DomUtil._setClass(el, (className ? className + ' ' : '') + name);\r\n\t\t}\r\n\t},\r\n\r\n\tremoveClass: function (el, name) {\r\n\t\tif (el.classList !== undefined) {\r\n\t\t\tel.classList.remove(name);\r\n\t\t} else {\r\n\t\t\tL.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));\r\n\t\t}\r\n\t},\r\n\r\n\t_setClass: function (el, name) {\r\n\t\tif (el.className.baseVal === undefined) {\r\n\t\t\tel.className = name;\r\n\t\t} else {\r\n\t\t\t// in case of SVG element\r\n\t\t\tel.className.baseVal = name;\r\n\t\t}\r\n\t},\r\n\r\n\t_getClass: function (el) {\r\n\t\treturn el.className.baseVal === undefined ? el.className : el.className.baseVal;\r\n\t},\r\n\r\n\tsetOpacity: function (el, value) {\r\n\r\n\t\tif ('opacity' in el.style) {\r\n\t\t\tel.style.opacity = value;\r\n\r\n\t\t} else if ('filter' in el.style) {\r\n\r\n\t\t\tvar filter = false,\r\n\t\t\t    filterName = 'DXImageTransform.Microsoft.Alpha';\r\n\r\n\t\t\t// filters collection throws an error if we try to retrieve a filter that doesn't exist\r\n\t\t\ttry {\r\n\t\t\t\tfilter = el.filters.item(filterName);\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// don't set opacity to 1 if we haven't already set an opacity,\r\n\t\t\t\t// it isn't needed and breaks transparent pngs.\r\n\t\t\t\tif (value === 1) { return; }\r\n\t\t\t}\r\n\r\n\t\t\tvalue = Math.round(value * 100);\r\n\r\n\t\t\tif (filter) {\r\n\t\t\t\tfilter.Enabled = (value !== 100);\r\n\t\t\t\tfilter.Opacity = value;\r\n\t\t\t} else {\r\n\t\t\t\tel.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\ttestProp: function (props) {\r\n\r\n\t\tvar style = document.documentElement.style;\r\n\r\n\t\tfor (var i = 0; i < props.length; i++) {\r\n\t\t\tif (props[i] in style) {\r\n\t\t\t\treturn props[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\tgetTranslateString: function (point) {\r\n\t\t// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate\r\n\t\t// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care\r\n\t\t// (same speed either way), Opera 12 doesn't support translate3d\r\n\r\n\t\tvar is3d = L.Browser.webkit3d,\r\n\t\t    open = 'translate' + (is3d ? '3d' : '') + '(',\r\n\t\t    close = (is3d ? ',0' : '') + ')';\r\n\r\n\t\treturn open + point.x + 'px,' + point.y + 'px' + close;\r\n\t},\r\n\r\n\tgetScaleString: function (scale, origin) {\r\n\r\n\t\tvar preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),\r\n\t\t    scaleStr = ' scale(' + scale + ') ';\r\n\r\n\t\treturn preTranslateStr + scaleStr;\r\n\t},\r\n\r\n\tsetPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])\r\n\r\n\t\t// jshint camelcase: false\r\n\t\tel._leaflet_pos = point;\r\n\r\n\t\tif (!disable3D && L.Browser.any3d) {\r\n\t\t\tel.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);\r\n\t\t} else {\r\n\t\t\tel.style.left = point.x + 'px';\r\n\t\t\tel.style.top = point.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\tgetPosition: function (el) {\r\n\t\t// this method is only used for elements previously positioned using setPosition,\r\n\t\t// so it's safe to cache the position for performance\r\n\r\n\t\t// jshint camelcase: false\r\n\t\treturn el._leaflet_pos;\r\n\t}\r\n};\r\n\r\n\r\n// prefix style property names\r\n\r\nL.DomUtil.TRANSFORM = L.DomUtil.testProp(\r\n        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\r\n\r\n// webkitTransition comes first because some browser versions that drop vendor prefix don't do\r\n// the same for the transitionend event, in particular the Android 4.1 stock browser\r\n\r\nL.DomUtil.TRANSITION = L.DomUtil.testProp(\r\n        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\r\n\r\nL.DomUtil.TRANSITION_END =\r\n        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?\r\n        L.DomUtil.TRANSITION + 'End' : 'transitionend';\r\n\r\n(function () {\r\n    if ('onselectstart' in document) {\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);\r\n            }\r\n        });\r\n    } else {\r\n        var userSelectProperty = L.DomUtil.testProp(\r\n            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);\r\n\r\n        L.extend(L.DomUtil, {\r\n            disableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    var style = document.documentElement.style;\r\n                    this._userSelect = style[userSelectProperty];\r\n                    style[userSelectProperty] = 'none';\r\n                }\r\n            },\r\n\r\n            enableTextSelection: function () {\r\n                if (userSelectProperty) {\r\n                    document.documentElement.style[userSelectProperty] = this._userSelect;\r\n                    delete this._userSelect;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\tL.extend(L.DomUtil, {\r\n\t\tdisableImageDrag: function () {\r\n\t\t\tL.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t},\r\n\r\n\t\tenableImageDrag: function () {\r\n\t\t\tL.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);\r\n\t\t}\r\n\t});\r\n})();\r\n\n\n/*\r\n * L.LatLng represents a geographical point with latitude and longitude coordinates.\r\n */\r\n\r\nL.LatLng = function (lat, lng, alt) { // (Number, Number, Number)\r\n\tlat = parseFloat(lat);\r\n\tlng = parseFloat(lng);\r\n\r\n\tif (isNaN(lat) || isNaN(lng)) {\r\n\t\tthrow new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');\r\n\t}\r\n\r\n\tthis.lat = lat;\r\n\tthis.lng = lng;\r\n\r\n\tif (alt !== undefined) {\r\n\t\tthis.alt = parseFloat(alt);\r\n\t}\r\n};\r\n\r\nL.extend(L.LatLng, {\r\n\tDEG_TO_RAD: Math.PI / 180,\r\n\tRAD_TO_DEG: 180 / Math.PI,\r\n\tMAX_MARGIN: 1.0E-9 // max margin of error for the \"equals\" check\r\n});\r\n\r\nL.LatLng.prototype = {\r\n\tequals: function (obj) { // (LatLng) -> Boolean\r\n\t\tif (!obj) { return false; }\r\n\r\n\t\tobj = L.latLng(obj);\r\n\r\n\t\tvar margin = Math.max(\r\n\t\t        Math.abs(this.lat - obj.lat),\r\n\t\t        Math.abs(this.lng - obj.lng));\r\n\r\n\t\treturn margin <= L.LatLng.MAX_MARGIN;\r\n\t},\r\n\r\n\ttoString: function (precision) { // (Number) -> String\r\n\t\treturn 'LatLng(' +\r\n\t\t        L.Util.formatNum(this.lat, precision) + ', ' +\r\n\t\t        L.Util.formatNum(this.lng, precision) + ')';\r\n\t},\r\n\r\n\t// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula\r\n\t// TODO move to projection code, LatLng shouldn't know about Earth\r\n\tdistanceTo: function (other) { // (LatLng) -> Number\r\n\t\tother = L.latLng(other);\r\n\r\n\t\tvar R = 6378137, // earth radius in meters\r\n\t\t    d2r = L.LatLng.DEG_TO_RAD,\r\n\t\t    dLat = (other.lat - this.lat) * d2r,\r\n\t\t    dLon = (other.lng - this.lng) * d2r,\r\n\t\t    lat1 = this.lat * d2r,\r\n\t\t    lat2 = other.lat * d2r,\r\n\t\t    sin1 = Math.sin(dLat / 2),\r\n\t\t    sin2 = Math.sin(dLon / 2);\r\n\r\n\t\tvar a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);\r\n\r\n\t\treturn R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n\t},\r\n\r\n\twrap: function (a, b) { // (Number, Number) -> LatLng\r\n\t\tvar lng = this.lng;\r\n\r\n\t\ta = a || -180;\r\n\t\tb = b ||  180;\r\n\r\n\t\tlng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);\r\n\r\n\t\treturn new L.LatLng(this.lat, lng);\r\n\t}\r\n};\r\n\r\nL.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)\r\n\tif (a instanceof L.LatLng) {\r\n\t\treturn a;\r\n\t}\r\n\tif (L.Util.isArray(a)) {\r\n\t\tif (typeof a[0] === 'number' || typeof a[0] === 'string') {\r\n\t\t\treturn new L.LatLng(a[0], a[1], a[2]);\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\tif (a === undefined || a === null) {\r\n\t\treturn a;\r\n\t}\r\n\tif (typeof a === 'object' && 'lat' in a) {\r\n\t\treturn new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);\r\n\t}\r\n\tif (b === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\treturn new L.LatLng(a, b);\r\n};\r\n\r\n\n\n/*\r\n * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.\r\n */\r\n\r\nL.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])\r\n\tif (!southWest) { return; }\r\n\r\n\tvar latlngs = northEast ? [southWest, northEast] : southWest;\r\n\r\n\tfor (var i = 0, len = latlngs.length; i < len; i++) {\r\n\t\tthis.extend(latlngs[i]);\r\n\t}\r\n};\r\n\r\nL.LatLngBounds.prototype = {\r\n\t// extend the bounds to contain the given point or bounds\r\n\textend: function (obj) { // (LatLng) or (LatLngBounds)\r\n\t\tif (!obj) { return this; }\r\n\r\n\t\tvar latLng = L.latLng(obj);\r\n\t\tif (latLng !== null) {\r\n\t\t\tobj = latLng;\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tif (obj instanceof L.LatLng) {\r\n\t\t\tif (!this._southWest && !this._northEast) {\r\n\t\t\t\tthis._southWest = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t\tthis._northEast = new L.LatLng(obj.lat, obj.lng);\r\n\t\t\t} else {\r\n\t\t\t\tthis._southWest.lat = Math.min(obj.lat, this._southWest.lat);\r\n\t\t\t\tthis._southWest.lng = Math.min(obj.lng, this._southWest.lng);\r\n\r\n\t\t\t\tthis._northEast.lat = Math.max(obj.lat, this._northEast.lat);\r\n\t\t\t\tthis._northEast.lng = Math.max(obj.lng, this._northEast.lng);\r\n\t\t\t}\r\n\t\t} else if (obj instanceof L.LatLngBounds) {\r\n\t\t\tthis.extend(obj._southWest);\r\n\t\t\tthis.extend(obj._northEast);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// extend the bounds by a percentage\r\n\tpad: function (bufferRatio) { // (Number) -> LatLngBounds\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,\r\n\t\t    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),\r\n\t\t        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));\r\n\t},\r\n\r\n\tgetCenter: function () { // -> LatLng\r\n\t\treturn new L.LatLng(\r\n\t\t        (this._southWest.lat + this._northEast.lat) / 2,\r\n\t\t        (this._southWest.lng + this._northEast.lng) / 2);\r\n\t},\r\n\r\n\tgetSouthWest: function () {\r\n\t\treturn this._southWest;\r\n\t},\r\n\r\n\tgetNorthEast: function () {\r\n\t\treturn this._northEast;\r\n\t},\r\n\r\n\tgetNorthWest: function () {\r\n\t\treturn new L.LatLng(this.getNorth(), this.getWest());\r\n\t},\r\n\r\n\tgetSouthEast: function () {\r\n\t\treturn new L.LatLng(this.getSouth(), this.getEast());\r\n\t},\r\n\r\n\tgetWest: function () {\r\n\t\treturn this._southWest.lng;\r\n\t},\r\n\r\n\tgetSouth: function () {\r\n\t\treturn this._southWest.lat;\r\n\t},\r\n\r\n\tgetEast: function () {\r\n\t\treturn this._northEast.lng;\r\n\t},\r\n\r\n\tgetNorth: function () {\r\n\t\treturn this._northEast.lat;\r\n\t},\r\n\r\n\tcontains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean\r\n\t\tif (typeof obj[0] === 'number' || obj instanceof L.LatLng) {\r\n\t\t\tobj = L.latLng(obj);\r\n\t\t} else {\r\n\t\t\tobj = L.latLngBounds(obj);\r\n\t\t}\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2, ne2;\r\n\r\n\t\tif (obj instanceof L.LatLngBounds) {\r\n\t\t\tsw2 = obj.getSouthWest();\r\n\t\t\tne2 = obj.getNorthEast();\r\n\t\t} else {\r\n\t\t\tsw2 = ne2 = obj;\r\n\t\t}\r\n\r\n\t\treturn (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&\r\n\t\t       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);\r\n\t},\r\n\r\n\tintersects: function (bounds) { // (LatLngBounds)\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar sw = this._southWest,\r\n\t\t    ne = this._northEast,\r\n\t\t    sw2 = bounds.getSouthWest(),\r\n\t\t    ne2 = bounds.getNorthEast(),\r\n\r\n\t\t    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),\r\n\t\t    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);\r\n\r\n\t\treturn latIntersects && lngIntersects;\r\n\t},\r\n\r\n\ttoBBoxString: function () {\r\n\t\treturn [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');\r\n\t},\r\n\r\n\tequals: function (bounds) { // (LatLngBounds)\r\n\t\tif (!bounds) { return false; }\r\n\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\treturn this._southWest.equals(bounds.getSouthWest()) &&\r\n\t\t       this._northEast.equals(bounds.getNorthEast());\r\n\t},\r\n\r\n\tisValid: function () {\r\n\t\treturn !!(this._southWest && this._northEast);\r\n\t}\r\n};\r\n\r\n//TODO International date line?\r\n\r\nL.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)\r\n\tif (!a || a instanceof L.LatLngBounds) {\r\n\t\treturn a;\r\n\t}\r\n\treturn new L.LatLngBounds(a, b);\r\n};\r\n\n\n/*\r\n * L.Projection contains various geographical projections used by CRS classes.\r\n */\r\n\r\nL.Projection = {};\r\n\n\n/*\r\n * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.\r\n */\r\n\r\nL.Projection.SphericalMercator = {\r\n\tMAX_LATITUDE: 85.0511287798,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    x = latlng.lng * d,\r\n\t\t    y = lat * d;\r\n\r\n\t\ty = Math.log(Math.tan((Math.PI / 4) + (y / 2)));\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    lng = point.x * d,\r\n\t\t    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;\r\n\r\n\t\treturn new L.LatLng(lat, lng);\r\n\t}\r\n};\r\n\n\n/*\r\n * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.\r\n */\r\n\r\nL.Projection.LonLat = {\r\n\tproject: function (latlng) {\r\n\t\treturn new L.Point(latlng.lng, latlng.lat);\r\n\t},\r\n\r\n\tunproject: function (point) {\r\n\t\treturn new L.LatLng(point.y, point.x);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.\r\n */\r\n\r\nL.CRS = {\r\n\tlatLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    scale = this.scale(zoom);\r\n\r\n\t\treturn this.transformation._transform(projectedPoint, scale);\r\n\t},\r\n\r\n\tpointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng\r\n\t\tvar scale = this.scale(zoom),\r\n\t\t    untransformedPoint = this.transformation.untransform(point, scale);\r\n\r\n\t\treturn this.projection.unproject(untransformedPoint);\r\n\t},\r\n\r\n\tproject: function (latlng) {\r\n\t\treturn this.projection.project(latlng);\r\n\t},\r\n\r\n\tscale: function (zoom) {\r\n\t\treturn 256 * Math.pow(2, zoom);\r\n\t},\r\n\r\n\tgetSize: function (zoom) {\r\n\t\tvar s = this.scale(zoom);\r\n\t\treturn L.point(s, s);\r\n\t}\r\n};\r\n\n\n/*\n * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.\n */\n\nL.CRS.Simple = L.extend({}, L.CRS, {\n\tprojection: L.Projection.LonLat,\n\ttransformation: new L.Transformation(1, 0, -1, 0),\n\n\tscale: function (zoom) {\n\t\treturn Math.pow(2, zoom);\n\t}\n});\n\n\n/*\r\n * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping\r\n * and is used by Leaflet by default.\r\n */\r\n\r\nL.CRS.EPSG3857 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3857',\r\n\r\n\tprojection: L.Projection.SphericalMercator,\r\n\ttransformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar projectedPoint = this.projection.project(latlng),\r\n\t\t    earthRadius = 6378137;\r\n\t\treturn projectedPoint.multiplyBy(earthRadius);\r\n\t}\r\n});\r\n\r\nL.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {\r\n\tcode: 'EPSG:900913'\r\n});\r\n\n\n/*\r\n * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.\r\n */\r\n\r\nL.CRS.EPSG4326 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:4326',\r\n\r\n\tprojection: L.Projection.LonLat,\r\n\ttransformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)\r\n});\r\n\n\n/*\r\n * L.Map is the central class of the API - it is used to create a map.\r\n */\r\n\r\nL.Map = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tcrs: L.CRS.EPSG3857,\r\n\r\n\t\t/*\r\n\t\tcenter: LatLng,\r\n\t\tzoom: Number,\r\n\t\tlayers: Array,\r\n\t\t*/\r\n\r\n\t\tfadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,\r\n\t\ttrackResize: true,\r\n\t\tmarkerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d\r\n\t},\r\n\r\n\tinitialize: function (id, options) { // (HTMLElement or String, Object)\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\r\n\t\tthis._initContainer(id);\r\n\t\tthis._initLayout();\r\n\r\n\t\t// hack for https://github.com/Leaflet/Leaflet/issues/1980\r\n\t\tthis._onResize = L.bind(this._onResize, this);\r\n\r\n\t\tthis._initEvents();\r\n\r\n\t\tif (options.maxBounds) {\r\n\t\t\tthis.setMaxBounds(options.maxBounds);\r\n\t\t}\r\n\r\n\t\tif (options.center && options.zoom !== undefined) {\r\n\t\t\tthis.setView(L.latLng(options.center), options.zoom, {reset: true});\r\n\t\t}\r\n\r\n\t\tthis._handlers = [];\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._zoomBoundLayers = {};\r\n\t\tthis._tileLayersNum = 0;\r\n\r\n\t\tthis.callInitHooks();\r\n\r\n\t\tthis._addLayers(options.layers);\r\n\t},\r\n\r\n\r\n\t// public methods that modify map state\r\n\r\n\t// replaced by animation-powered implementation in Map.PanAnimation.js\r\n\tsetView: function (center, zoom) {\r\n\t\tzoom = zoom === undefined ? this.getZoom() : zoom;\r\n\t\tthis._resetView(L.latLng(center), this._limitZoom(zoom));\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZoom: function (zoom, options) {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthis._zoom = this._limitZoom(zoom);\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\treturn this.setView(this.getCenter(), zoom, {zoom: options});\r\n\t},\r\n\r\n\tzoomIn: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom + (delta || 1), options);\r\n\t},\r\n\r\n\tzoomOut: function (delta, options) {\r\n\t\treturn this.setZoom(this._zoom - (delta || 1), options);\r\n\t},\r\n\r\n\tsetZoomAround: function (latlng, zoom, options) {\r\n\t\tvar scale = this.getZoomScale(zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),\r\n\r\n\t\t    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),\r\n\t\t    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));\r\n\r\n\t\treturn this.setView(newCenter, zoom, {zoom: options});\r\n\t},\r\n\r\n\tfitBounds: function (bounds, options) {\r\n\r\n\t\toptions = options || {};\r\n\t\tbounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);\r\n\r\n\t\tvar paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\r\n\t\t    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\r\n\r\n\t\t    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)),\r\n\t\t    paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),\r\n\r\n\t\t    swPoint = this.project(bounds.getSouthWest(), zoom),\r\n\t\t    nePoint = this.project(bounds.getNorthEast(), zoom),\r\n\t\t    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);\r\n\r\n\t\tzoom = options && options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;\r\n\r\n\t\treturn this.setView(center, zoom, options);\r\n\t},\r\n\r\n\tfitWorld: function (options) {\r\n\t\treturn this.fitBounds([[-90, -180], [90, 180]], options);\r\n\t},\r\n\r\n\tpanTo: function (center, options) { // (LatLng)\r\n\t\treturn this.setView(center, this._zoom, {pan: options});\r\n\t},\r\n\r\n\tpanBy: function (offset) { // (Point)\r\n\t\t// replaced with animated panBy in Map.PanAnimation.js\r\n\t\tthis.fire('movestart');\r\n\r\n\t\tthis._rawPanBy(L.point(offset));\r\n\r\n\t\tthis.fire('move');\r\n\t\treturn this.fire('moveend');\r\n\t},\r\n\r\n\tsetMaxBounds: function (bounds) {\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tthis.options.maxBounds = bounds;\r\n\r\n\t\tif (!bounds) {\r\n\t\t\treturn this.off('moveend', this._panInsideMaxBounds, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._panInsideMaxBounds();\r\n\t\t}\r\n\r\n\t\treturn this.on('moveend', this._panInsideMaxBounds, this);\r\n\t},\r\n\r\n\tpanInsideBounds: function (bounds, options) {\r\n\t\tvar center = this.getCenter(),\r\n\t\t\tnewCenter = this._limitCenter(center, this._zoom, bounds);\r\n\r\n\t\tif (center.equals(newCenter)) { return this; }\r\n\r\n\t\treturn this.panTo(newCenter, options);\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\t// TODO method is too big, refactor\r\n\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (this._layers[id]) { return this; }\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\t// TODO getMaxZoom, getMinZoom in ILayer (instead of options)\r\n\t\tif (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {\r\n\t\t\tthis._zoomBoundLayers[id] = layer;\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor!!!\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum++;\r\n\t\t\tthis._tileLayersToLoad++;\r\n\t\t\tlayer.on('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis._layerAdd(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tif (!this._layers[id]) { return this; }\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tlayer.onRemove(this);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('layerremove', {layer: layer});\r\n\t\t}\r\n\r\n\t\tif (this._zoomBoundLayers[id]) {\r\n\t\t\tdelete this._zoomBoundLayers[id];\r\n\t\t\tthis._updateZoomLevels();\r\n\t\t}\r\n\r\n\t\t// TODO looks ugly, refactor\r\n\t\tif (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {\r\n\t\t\tthis._tileLayersNum--;\r\n\t\t\tthis._tileLayersToLoad--;\r\n\t\t\tlayer.off('load', this._onTileLayerLoad, this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (L.stamp(layer) in this._layers);\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvalidateSize: function (options) {\r\n\t\tif (!this._loaded) { return this; }\r\n\r\n\t\toptions = L.extend({\r\n\t\t\tanimate: false,\r\n\t\t\tpan: true\r\n\t\t}, options === true ? {animate: true} : options);\r\n\r\n\t\tvar oldSize = this.getSize();\r\n\t\tthis._sizeChanged = true;\r\n\t\tthis._initialCenter = null;\r\n\r\n\t\tvar newSize = this.getSize(),\r\n\t\t    oldCenter = oldSize.divideBy(2).round(),\r\n\t\t    newCenter = newSize.divideBy(2).round(),\r\n\t\t    offset = oldCenter.subtract(newCenter);\r\n\r\n\t\tif (!offset.x && !offset.y) { return this; }\r\n\r\n\t\tif (options.animate && options.pan) {\r\n\t\t\tthis.panBy(offset);\r\n\r\n\t\t} else {\r\n\t\t\tif (options.pan) {\r\n\t\t\t\tthis._rawPanBy(offset);\r\n\t\t\t}\r\n\r\n\t\t\tthis.fire('move');\r\n\r\n\t\t\tif (options.debounceMoveend) {\r\n\t\t\t\tclearTimeout(this._sizeTimer);\r\n\t\t\t\tthis._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);\r\n\t\t\t} else {\r\n\t\t\t\tthis.fire('moveend');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.fire('resize', {\r\n\t\t\toldSize: oldSize,\r\n\t\t\tnewSize: newSize\r\n\t\t});\r\n\t},\r\n\r\n\t// TODO handler.addTo\r\n\taddHandler: function (name, HandlerClass) {\r\n\t\tif (!HandlerClass) { return this; }\r\n\r\n\t\tvar handler = this[name] = new HandlerClass(this);\r\n\r\n\t\tthis._handlers.push(handler);\r\n\r\n\t\tif (this.options[name]) {\r\n\t\t\thandler.enable();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremove: function () {\r\n\t\tif (this._loaded) {\r\n\t\t\tthis.fire('unload');\r\n\t\t}\r\n\r\n\t\tthis._initEvents('off');\r\n\r\n\t\ttry {\r\n\t\t\t// throws error in IE6-8\r\n\t\t\tdelete this._container._leaflet;\r\n\t\t} catch (e) {\r\n\t\t\tthis._container._leaflet = undefined;\r\n\t\t}\r\n\r\n\t\tthis._clearPanes();\r\n\t\tif (this._clearControlPos) {\r\n\t\t\tthis._clearControlPos();\r\n\t\t}\r\n\r\n\t\tthis._clearHandlers();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// public methods for getting map state\r\n\r\n\tgetCenter: function () { // (Boolean) -> LatLng\r\n\t\tthis._checkIfLoaded();\r\n\r\n\t\tif (this._initialCenter && !this._moved()) {\r\n\t\t\treturn this._initialCenter;\r\n\t\t}\r\n\t\treturn this.layerPointToLatLng(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\tgetZoom: function () {\r\n\t\treturn this._zoom;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = this.getPixelBounds(),\r\n\t\t    sw = this.unproject(bounds.getBottomLeft()),\r\n\t\t    ne = this.unproject(bounds.getTopRight());\r\n\r\n\t\treturn new L.LatLngBounds(sw, ne);\r\n\t},\r\n\r\n\tgetMinZoom: function () {\r\n\t\treturn this.options.minZoom === undefined ?\r\n\t\t\t(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :\r\n\t\t\tthis.options.minZoom;\r\n\t},\r\n\r\n\tgetMaxZoom: function () {\r\n\t\treturn this.options.maxZoom === undefined ?\r\n\t\t\t(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :\r\n\t\t\tthis.options.maxZoom;\r\n\t},\r\n\r\n\tgetBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number\r\n\t\tbounds = L.latLngBounds(bounds);\r\n\r\n\t\tvar zoom = this.getMinZoom() - (inside ? 1 : 0),\r\n\t\t    maxZoom = this.getMaxZoom(),\r\n\t\t    size = this.getSize(),\r\n\r\n\t\t    nw = bounds.getNorthWest(),\r\n\t\t    se = bounds.getSouthEast(),\r\n\r\n\t\t    zoomNotFound = true,\r\n\t\t    boundsSize;\r\n\r\n\t\tpadding = L.point(padding || [0, 0]);\r\n\r\n\t\tdo {\r\n\t\t\tzoom++;\r\n\t\t\tboundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);\r\n\t\t\tzoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;\r\n\r\n\t\t} while (zoomNotFound && zoom <= maxZoom);\r\n\r\n\t\tif (zoomNotFound && inside) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn inside ? zoom : zoom - 1;\r\n\t},\r\n\r\n\tgetSize: function () {\r\n\t\tif (!this._size || this._sizeChanged) {\r\n\t\t\tthis._size = new L.Point(\r\n\t\t\t\tthis._container.clientWidth,\r\n\t\t\t\tthis._container.clientHeight);\r\n\r\n\t\t\tthis._sizeChanged = false;\r\n\t\t}\r\n\t\treturn this._size.clone();\r\n\t},\r\n\r\n\tgetPixelBounds: function () {\r\n\t\tvar topLeftPoint = this._getTopLeftPoint();\r\n\t\treturn new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\r\n\t},\r\n\r\n\tgetPixelOrigin: function () {\r\n\t\tthis._checkIfLoaded();\r\n\t\treturn this._initialTopLeftPoint;\r\n\t},\r\n\r\n\tgetPanes: function () {\r\n\t\treturn this._panes;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\r\n\t// TODO replace with universal implementation after refactoring projections\r\n\r\n\tgetZoomScale: function (toZoom) {\r\n\t\tvar crs = this.options.crs;\r\n\t\treturn crs.scale(toZoom) / crs.scale(this._zoom);\r\n\t},\r\n\r\n\tgetScaleZoom: function (scale) {\r\n\t\treturn this._zoom + (Math.log(scale) / Math.LN2);\r\n\t},\r\n\r\n\r\n\t// conversion methods\r\n\r\n\tproject: function (latlng, zoom) { // (LatLng[, Number]) -> Point\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.latLngToPoint(L.latLng(latlng), zoom);\r\n\t},\r\n\r\n\tunproject: function (point, zoom) { // (Point[, Number]) -> LatLng\r\n\t\tzoom = zoom === undefined ? this._zoom : zoom;\r\n\t\treturn this.options.crs.pointToLatLng(L.point(point), zoom);\r\n\t},\r\n\r\n\tlayerPointToLatLng: function (point) { // (Point)\r\n\t\tvar projectedPoint = L.point(point).add(this.getPixelOrigin());\r\n\t\treturn this.unproject(projectedPoint);\r\n\t},\r\n\r\n\tlatLngToLayerPoint: function (latlng) { // (LatLng)\r\n\t\tvar projectedPoint = this.project(L.latLng(latlng))._round();\r\n\t\treturn projectedPoint._subtract(this.getPixelOrigin());\r\n\t},\r\n\r\n\tcontainerPointToLayerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\tlayerPointToContainerPoint: function (point) { // (Point)\r\n\t\treturn L.point(point).add(this._getMapPanePos());\r\n\t},\r\n\r\n\tcontainerPointToLatLng: function (point) {\r\n\t\tvar layerPoint = this.containerPointToLayerPoint(L.point(point));\r\n\t\treturn this.layerPointToLatLng(layerPoint);\r\n\t},\r\n\r\n\tlatLngToContainerPoint: function (latlng) {\r\n\t\treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));\r\n\t},\r\n\r\n\tmouseEventToContainerPoint: function (e) { // (MouseEvent)\r\n\t\treturn L.DomEvent.getMousePosition(e, this._container);\r\n\t},\r\n\r\n\tmouseEventToLayerPoint: function (e) { // (MouseEvent)\r\n\t\treturn this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));\r\n\t},\r\n\r\n\tmouseEventToLatLng: function (e) { // (MouseEvent)\r\n\t\treturn this.layerPointToLatLng(this.mouseEventToLayerPoint(e));\r\n\t},\r\n\r\n\r\n\t// map initialization methods\r\n\r\n\t_initContainer: function (id) {\r\n\t\tvar container = this._container = L.DomUtil.get(id);\r\n\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Map container not found.');\r\n\t\t} else if (container._leaflet) {\r\n\t\t\tthrow new Error('Map container is already initialized.');\r\n\t\t}\r\n\r\n\t\tcontainer._leaflet = true;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar container = this._container;\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-container' +\r\n\t\t\t(L.Browser.touch ? ' leaflet-touch' : '') +\r\n\t\t\t(L.Browser.retina ? ' leaflet-retina' : '') +\r\n\t\t\t(L.Browser.ielt9 ? ' leaflet-oldie' : '') +\r\n\t\t\t(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));\r\n\r\n\t\tvar position = L.DomUtil.getStyle(container, 'position');\r\n\r\n\t\tif (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {\r\n\t\t\tcontainer.style.position = 'relative';\r\n\t\t}\r\n\r\n\t\tthis._initPanes();\r\n\r\n\t\tif (this._initControlPos) {\r\n\t\t\tthis._initControlPos();\r\n\t\t}\r\n\t},\r\n\r\n\t_initPanes: function () {\r\n\t\tvar panes = this._panes = {};\r\n\r\n\t\tthis._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);\r\n\r\n\t\tthis._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);\r\n\t\tpanes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);\r\n\t\tpanes.shadowPane = this._createPane('leaflet-shadow-pane');\r\n\t\tpanes.overlayPane = this._createPane('leaflet-overlay-pane');\r\n\t\tpanes.markerPane = this._createPane('leaflet-marker-pane');\r\n\t\tpanes.popupPane = this._createPane('leaflet-popup-pane');\r\n\r\n\t\tvar zoomHide = ' leaflet-zoom-hide';\r\n\r\n\t\tif (!this.options.markerZoomAnimation) {\r\n\t\t\tL.DomUtil.addClass(panes.markerPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.shadowPane, zoomHide);\r\n\t\t\tL.DomUtil.addClass(panes.popupPane, zoomHide);\r\n\t\t}\r\n\t},\r\n\r\n\t_createPane: function (className, container) {\r\n\t\treturn L.DomUtil.create('div', className, container || this._panes.objectsPane);\r\n\t},\r\n\r\n\t_clearPanes: function () {\r\n\t\tthis._container.removeChild(this._mapPane);\r\n\t},\r\n\r\n\t_addLayers: function (layers) {\r\n\t\tlayers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];\r\n\r\n\t\tfor (var i = 0, len = layers.length; i < len; i++) {\r\n\t\t\tthis.addLayer(layers[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private methods that modify map state\r\n\r\n\t_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {\r\n\r\n\t\tvar zoomChanged = (this._zoom !== zoom);\r\n\r\n\t\tif (!afterZoomAnim) {\r\n\t\t\tthis.fire('movestart');\r\n\r\n\t\t\tif (zoomChanged) {\r\n\t\t\t\tthis.fire('zoomstart');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._zoom = zoom;\r\n\t\tthis._initialCenter = center;\r\n\r\n\t\tthis._initialTopLeftPoint = this._getNewTopLeftPoint(center);\r\n\r\n\t\tif (!preserveMapOffset) {\r\n\t\t\tL.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\r\n\t\t} else {\r\n\t\t\tthis._initialTopLeftPoint._add(this._getMapPanePos());\r\n\t\t}\r\n\r\n\t\tthis._tileLayersToLoad = this._tileLayersNum;\r\n\r\n\t\tvar loading = !this._loaded;\r\n\t\tthis._loaded = true;\r\n\r\n\t\tthis.fire('viewreset', {hard: !preserveMapOffset});\r\n\r\n\t\tif (loading) {\r\n\t\t\tthis.fire('load');\r\n\t\t\tthis.eachLayer(this._layerAdd, this);\r\n\t\t}\r\n\r\n\t\tthis.fire('move');\r\n\r\n\t\tif (zoomChanged || afterZoomAnim) {\r\n\t\t\tthis.fire('zoomend');\r\n\t\t}\r\n\r\n\t\tthis.fire('moveend', {hard: !preserveMapOffset});\r\n\t},\r\n\r\n\t_rawPanBy: function (offset) {\r\n\t\tL.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));\r\n\t},\r\n\r\n\t_getZoomSpan: function () {\r\n\t\treturn this.getMaxZoom() - this.getMinZoom();\r\n\t},\r\n\r\n\t_updateZoomLevels: function () {\r\n\t\tvar i,\r\n\t\t\tminZoom = Infinity,\r\n\t\t\tmaxZoom = -Infinity,\r\n\t\t\toldZoomSpan = this._getZoomSpan();\r\n\r\n\t\tfor (i in this._zoomBoundLayers) {\r\n\t\t\tvar layer = this._zoomBoundLayers[i];\r\n\t\t\tif (!isNaN(layer.options.minZoom)) {\r\n\t\t\t\tminZoom = Math.min(minZoom, layer.options.minZoom);\r\n\t\t\t}\r\n\t\t\tif (!isNaN(layer.options.maxZoom)) {\r\n\t\t\t\tmaxZoom = Math.max(maxZoom, layer.options.maxZoom);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (i === undefined) { // we have no tilelayers\r\n\t\t\tthis._layersMaxZoom = this._layersMinZoom = undefined;\r\n\t\t} else {\r\n\t\t\tthis._layersMaxZoom = maxZoom;\r\n\t\t\tthis._layersMinZoom = minZoom;\r\n\t\t}\r\n\r\n\t\tif (oldZoomSpan !== this._getZoomSpan()) {\r\n\t\t\tthis.fire('zoomlevelschange');\r\n\t\t}\r\n\t},\r\n\r\n\t_panInsideMaxBounds: function () {\r\n\t\tthis.panInsideBounds(this.options.maxBounds);\r\n\t},\r\n\r\n\t_checkIfLoaded: function () {\r\n\t\tif (!this._loaded) {\r\n\t\t\tthrow new Error('Set map center and zoom first.');\r\n\t\t}\r\n\t},\r\n\r\n\t// map events\r\n\r\n\t_initEvents: function (onOff) {\r\n\t\tif (!L.DomEvent) { return; }\r\n\r\n\t\tonOff = onOff || 'on';\r\n\r\n\t\tL.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\tvar events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',\r\n\t\t              'mouseleave', 'mousemove', 'contextmenu'],\r\n\t\t    i, len;\r\n\r\n\t\tfor (i = 0, len = events.length; i < len; i++) {\r\n\t\t\tL.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (this.options.trackResize) {\r\n\t\t\tL.DomEvent[onOff](window, 'resize', this._onResize, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onResize: function () {\r\n\t\tL.Util.cancelAnimFrame(this._resizeRequest);\r\n\t\tthis._resizeRequest = L.Util.requestAnimFrame(\r\n\t\t        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (!this._loaded || (!e._simulated &&\r\n\t\t        ((this.dragging && this.dragging.moved()) ||\r\n\t\t         (this.boxZoom  && this.boxZoom.moved()))) ||\r\n\t\t            L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tthis.fire('preclick');\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this._loaded || L.DomEvent._skipped(e)) { return; }\r\n\r\n\t\tvar type = e.type;\r\n\r\n\t\ttype = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));\r\n\r\n\t\tif (!this.hasEventListeners(type)) { return; }\r\n\r\n\t\tif (type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\r\n\t\tvar containerPoint = this.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = this.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = this.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\t},\r\n\r\n\t_onTileLayerLoad: function () {\r\n\t\tthis._tileLayersToLoad--;\r\n\t\tif (this._tileLayersNum && !this._tileLayersToLoad) {\r\n\t\t\tthis.fire('tilelayersload');\r\n\t\t}\r\n\t},\r\n\r\n\t_clearHandlers: function () {\r\n\t\tfor (var i = 0, len = this._handlers.length; i < len; i++) {\r\n\t\t\tthis._handlers[i].disable();\r\n\t\t}\r\n\t},\r\n\r\n\twhenReady: function (callback, context) {\r\n\t\tif (this._loaded) {\r\n\t\t\tcallback.call(context || this, this);\r\n\t\t} else {\r\n\t\t\tthis.on('load', callback, context);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_layerAdd: function (layer) {\r\n\t\tlayer.onAdd(this);\r\n\t\tthis.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\r\n\t// private methods for getting map state\r\n\r\n\t_getMapPanePos: function () {\r\n\t\treturn L.DomUtil.getPosition(this._mapPane);\r\n\t},\r\n\r\n\t_moved: function () {\r\n\t\tvar pos = this._getMapPanePos();\r\n\t\treturn pos && !pos.equals([0, 0]);\r\n\t},\r\n\r\n\t_getTopLeftPoint: function () {\r\n\t\treturn this.getPixelOrigin().subtract(this._getMapPanePos());\r\n\t},\r\n\r\n\t_getNewTopLeftPoint: function (center, zoom) {\r\n\t\tvar viewHalf = this.getSize()._divideBy(2);\r\n\t\t// TODO round on display, not calculation to increase precision?\r\n\t\treturn this.project(center, zoom)._subtract(viewHalf)._round();\r\n\t},\r\n\r\n\t_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {\r\n\t\tvar topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());\r\n\t\treturn this.project(latlng, newZoom)._subtract(topLeft);\r\n\t},\r\n\r\n\t// layer point of the current center\r\n\t_getCenterLayerPoint: function () {\r\n\t\treturn this.containerPointToLayerPoint(this.getSize()._divideBy(2));\r\n\t},\r\n\r\n\t// offset of the specified place to the current center in pixels\r\n\t_getCenterOffset: function (latlng) {\r\n\t\treturn this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());\r\n\t},\r\n\r\n\t// adjust center for view to get inside bounds\r\n\t_limitCenter: function (center, zoom, bounds) {\r\n\r\n\t\tif (!bounds) { return center; }\r\n\r\n\t\tvar centerPoint = this.project(center, zoom),\r\n\t\t    viewHalf = this.getSize().divideBy(2),\r\n\t\t    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\r\n\t\t    offset = this._getBoundsOffset(viewBounds, bounds, zoom);\r\n\r\n\t\treturn this.unproject(centerPoint.add(offset), zoom);\r\n\t},\r\n\r\n\t// adjust offset for view to get inside bounds\r\n\t_limitOffset: function (offset, bounds) {\r\n\t\tif (!bounds) { return offset; }\r\n\r\n\t\tvar viewBounds = this.getPixelBounds(),\r\n\t\t    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));\r\n\r\n\t\treturn offset.add(this._getBoundsOffset(newBounds, bounds));\r\n\t},\r\n\r\n\t// returns offset needed for pxBounds to get inside maxBounds at a specified zoom\r\n\t_getBoundsOffset: function (pxBounds, maxBounds, zoom) {\r\n\t\tvar nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),\r\n\t\t    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),\r\n\r\n\t\t    dx = this._rebound(nwOffset.x, -seOffset.x),\r\n\t\t    dy = this._rebound(nwOffset.y, -seOffset.y);\r\n\r\n\t\treturn new L.Point(dx, dy);\r\n\t},\r\n\r\n\t_rebound: function (left, right) {\r\n\t\treturn left + right > 0 ?\r\n\t\t\tMath.round(left - right) / 2 :\r\n\t\t\tMath.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));\r\n\t},\r\n\r\n\t_limitZoom: function (zoom) {\r\n\t\tvar min = this.getMinZoom(),\r\n\t\t    max = this.getMaxZoom();\r\n\r\n\t\treturn Math.max(min, Math.min(max, zoom));\r\n\t}\r\n});\r\n\r\nL.map = function (id, options) {\r\n\treturn new L.Map(id, options);\r\n};\r\n\n\n/*\r\n * Mercator projection that takes into account that the Earth is not a perfect sphere.\r\n * Less popular than spherical mercator; used by projections like EPSG:3395.\r\n */\r\n\r\nL.Projection.Mercator = {\r\n\tMAX_LATITUDE: 85.0840591556,\r\n\r\n\tR_MINOR: 6356752.314245179,\r\n\tR_MAJOR: 6378137,\r\n\r\n\tproject: function (latlng) { // (LatLng) -> Point\r\n\t\tvar d = L.LatLng.DEG_TO_RAD,\r\n\t\t    max = this.MAX_LATITUDE,\r\n\t\t    lat = Math.max(Math.min(max, latlng.lat), -max),\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    x = latlng.lng * d * r,\r\n\t\t    y = lat * d,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1.0 - tmp * tmp),\r\n\t\t    con = eccent * Math.sin(y);\r\n\r\n\t\tcon = Math.pow((1 - con) / (1 + con), eccent * 0.5);\r\n\r\n\t\tvar ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;\r\n\t\ty = -r * Math.log(ts);\r\n\r\n\t\treturn new L.Point(x, y);\r\n\t},\r\n\r\n\tunproject: function (point) { // (Point, Boolean) -> LatLng\r\n\t\tvar d = L.LatLng.RAD_TO_DEG,\r\n\t\t    r = this.R_MAJOR,\r\n\t\t    r2 = this.R_MINOR,\r\n\t\t    lng = point.x * d / r,\r\n\t\t    tmp = r2 / r,\r\n\t\t    eccent = Math.sqrt(1 - (tmp * tmp)),\r\n\t\t    ts = Math.exp(- point.y / r),\r\n\t\t    phi = (Math.PI / 2) - 2 * Math.atan(ts),\r\n\t\t    numIter = 15,\r\n\t\t    tol = 1e-7,\r\n\t\t    i = numIter,\r\n\t\t    dphi = 0.1,\r\n\t\t    con;\r\n\r\n\t\twhile ((Math.abs(dphi) > tol) && (--i > 0)) {\r\n\t\t\tcon = eccent * Math.sin(phi);\r\n\t\t\tdphi = (Math.PI / 2) - 2 * Math.atan(ts *\r\n\t\t\t            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;\r\n\t\t\tphi += dphi;\r\n\t\t}\r\n\r\n\t\treturn new L.LatLng(phi * d, lng);\r\n\t}\r\n};\r\n\n\n\r\nL.CRS.EPSG3395 = L.extend({}, L.CRS, {\r\n\tcode: 'EPSG:3395',\r\n\r\n\tprojection: L.Projection.Mercator,\r\n\r\n\ttransformation: (function () {\r\n\t\tvar m = L.Projection.Mercator,\r\n\t\t    r = m.R_MAJOR,\r\n\t\t    scale = 0.5 / (Math.PI * r);\r\n\r\n\t\treturn new L.Transformation(scale, 0.5, -scale, 0.5);\r\n\t}())\r\n});\r\n\n\n/*\r\n * L.TileLayer is used for standard xyz-numbered tile layers.\r\n */\r\n\r\nL.TileLayer = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminZoom: 0,\r\n\t\tmaxZoom: 18,\r\n\t\ttileSize: 256,\r\n\t\tsubdomains: 'abc',\r\n\t\terrorTileUrl: '',\r\n\t\tattribution: '',\r\n\t\tzoomOffset: 0,\r\n\t\topacity: 1,\r\n\t\t/*\r\n\t\tmaxNativeZoom: null,\r\n\t\tzIndex: null,\r\n\t\ttms: false,\r\n\t\tcontinuousWorld: false,\r\n\t\tnoWrap: false,\r\n\t\tzoomReverse: false,\r\n\t\tdetectRetina: false,\r\n\t\treuseTiles: false,\r\n\t\tbounds: false,\r\n\t\t*/\r\n\t\tunloadInvisibleTiles: L.Browser.mobile,\r\n\t\tupdateWhenIdle: L.Browser.mobile\r\n\t},\r\n\r\n\tinitialize: function (url, options) {\r\n\t\toptions = L.setOptions(this, options);\r\n\r\n\t\t// detecting retina displays, adjusting tileSize and zoom levels\r\n\t\tif (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {\r\n\r\n\t\t\toptions.tileSize = Math.floor(options.tileSize / 2);\r\n\t\t\toptions.zoomOffset++;\r\n\r\n\t\t\tif (options.minZoom > 0) {\r\n\t\t\t\toptions.minZoom--;\r\n\t\t\t}\r\n\t\t\tthis.options.maxZoom--;\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\toptions.bounds = L.latLngBounds(options.bounds);\r\n\t\t}\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar subdomains = this.options.subdomains;\r\n\r\n\t\tif (typeof subdomains === 'string') {\r\n\t\t\tthis.options.subdomains = subdomains.split('');\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis._animated = map._zoomAnimated;\r\n\r\n\t\t// create a container div for tiles\r\n\t\tthis._initContainer();\r\n\r\n\t\t// set up events\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.on({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tthis._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);\r\n\t\t\tmap.on('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t\tthis._update();\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis._container.parentNode.removeChild(this._container);\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this._reset,\r\n\t\t\t'moveend': this._update\r\n\t\t}, this);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tmap.off({\r\n\t\t\t\t'zoomanim': this._animateZoom,\r\n\t\t\t\t'zoomend': this._endZoomAnim\r\n\t\t\t}, this);\r\n\t\t}\r\n\r\n\t\tif (!this.options.updateWhenIdle) {\r\n\t\t\tmap.off('move', this._limitedUpdate, this);\r\n\t\t}\r\n\r\n\t\tthis._container = null;\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.appendChild(this._container);\r\n\t\t\tthis._setAutoZIndex(pane, Math.max);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.tilePane;\r\n\r\n\t\tif (this._container) {\r\n\t\t\tpane.insertBefore(this._container, pane.firstChild);\r\n\t\t\tthis._setAutoZIndex(pane, Math.min);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\tthis.options.zIndex = zIndex;\r\n\t\tthis._updateZIndex();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url, noRedraw) {\r\n\t\tthis._url = url;\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateZIndex: function () {\r\n\t\tif (this._container && this.options.zIndex !== undefined) {\r\n\t\t\tthis._container.style.zIndex = this.options.zIndex;\r\n\t\t}\r\n\t},\r\n\r\n\t_setAutoZIndex: function (pane, compare) {\r\n\r\n\t\tvar layers = pane.children,\r\n\t\t    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min\r\n\t\t    zIndex, i, len;\r\n\r\n\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\r\n\t\t\tif (layers[i] !== this._container) {\r\n\t\t\t\tzIndex = parseInt(layers[i].style.zIndex, 10);\r\n\r\n\t\t\t\tif (!isNaN(zIndex)) {\r\n\t\t\t\t\tedgeZIndex = compare(edgeZIndex, zIndex);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.options.zIndex = this._container.style.zIndex =\r\n\t\t        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tvar i,\r\n\t\t    tiles = this._tiles;\r\n\r\n\t\tif (L.Browser.ielt9) {\r\n\t\t\tfor (i in tiles) {\r\n\t\t\t\tL.DomUtil.setOpacity(tiles[i], this.options.opacity);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tL.DomUtil.setOpacity(this._container, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_initContainer: function () {\r\n\t\tvar tilePane = this._map._panes.tilePane;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._container = L.DomUtil.create('div', 'leaflet-layer');\r\n\r\n\t\t\tthis._updateZIndex();\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\tvar className = 'leaflet-tile-container';\r\n\r\n\t\t\t\tthis._bgBuffer = L.DomUtil.create('div', className, this._container);\r\n\t\t\t\tthis._tileContainer = L.DomUtil.create('div', className, this._container);\r\n\r\n\t\t\t} else {\r\n\t\t\t\tthis._tileContainer = this._container;\r\n\t\t\t}\r\n\r\n\t\t\ttilePane.appendChild(this._container);\r\n\r\n\t\t\tif (this.options.opacity < 1) {\r\n\t\t\t\tthis._updateOpacity();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_reset: function (e) {\r\n\t\tfor (var key in this._tiles) {\r\n\t\t\tthis.fire('tileunload', {tile: this._tiles[key]});\r\n\t\t}\r\n\r\n\t\tthis._tiles = {};\r\n\t\tthis._tilesToLoad = 0;\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tthis._unusedTiles = [];\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.innerHTML = '';\r\n\r\n\t\tif (this._animated && e && e.hard) {\r\n\t\t\tthis._clearBgBuffer();\r\n\t\t}\r\n\r\n\t\tthis._initContainer();\r\n\t},\r\n\r\n\t_getTileSize: function () {\r\n\t\tvar map = this._map,\r\n\t\t    zoom = map.getZoom() + this.options.zoomOffset,\r\n\t\t    zoomN = this.options.maxNativeZoom,\r\n\t\t    tileSize = this.options.tileSize;\r\n\r\n\t\tif (zoomN && zoom > zoomN) {\r\n\t\t\ttileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);\r\n\t\t}\r\n\r\n\t\treturn tileSize;\r\n\t},\r\n\r\n\t_update: function () {\r\n\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    bounds = map.getPixelBounds(),\r\n\t\t    zoom = map.getZoom(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\tif (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar tileBounds = L.bounds(\r\n\t\t        bounds.min.divideBy(tileSize)._floor(),\r\n\t\t        bounds.max.divideBy(tileSize)._floor());\r\n\r\n\t\tthis._addTilesFromCenterOut(tileBounds);\r\n\r\n\t\tif (this.options.unloadInvisibleTiles || this.options.reuseTiles) {\r\n\t\t\tthis._removeOtherTiles(tileBounds);\r\n\t\t}\r\n\t},\r\n\r\n\t_addTilesFromCenterOut: function (bounds) {\r\n\t\tvar queue = [],\r\n\t\t    center = bounds.getCenter();\r\n\r\n\t\tvar j, i, point;\r\n\r\n\t\tfor (j = bounds.min.y; j <= bounds.max.y; j++) {\r\n\t\t\tfor (i = bounds.min.x; i <= bounds.max.x; i++) {\r\n\t\t\t\tpoint = new L.Point(i, j);\r\n\r\n\t\t\t\tif (this._tileShouldBeLoaded(point)) {\r\n\t\t\t\t\tqueue.push(point);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar tilesToLoad = queue.length;\r\n\r\n\t\tif (tilesToLoad === 0) { return; }\r\n\r\n\t\t// load tiles in order of their distance to center\r\n\t\tqueue.sort(function (a, b) {\r\n\t\t\treturn a.distanceTo(center) - b.distanceTo(center);\r\n\t\t});\r\n\r\n\t\tvar fragment = document.createDocumentFragment();\r\n\r\n\t\t// if its the first batch of tiles to load\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('loading');\r\n\t\t}\r\n\r\n\t\tthis._tilesToLoad += tilesToLoad;\r\n\r\n\t\tfor (i = 0; i < tilesToLoad; i++) {\r\n\t\t\tthis._addTile(queue[i], fragment);\r\n\t\t}\r\n\r\n\t\tthis._tileContainer.appendChild(fragment);\r\n\t},\r\n\r\n\t_tileShouldBeLoaded: function (tilePoint) {\r\n\t\tif ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {\r\n\t\t\treturn false; // already loaded\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (!options.continuousWorld) {\r\n\t\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t\t// don't load if exceeds world bounds\r\n\t\t\tif ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||\r\n\t\t\t\ttilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }\r\n\t\t}\r\n\r\n\t\tif (options.bounds) {\r\n\t\t\tvar tileSize = options.tileSize,\r\n\t\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\t\t\t    nw = this._map.unproject(nwPoint),\r\n\t\t\t    se = this._map.unproject(sePoint);\r\n\r\n\t\t\t// TODO temporary hack, will be removed after refactoring projections\r\n\t\t\t// https://github.com/Leaflet/Leaflet/issues/1618\r\n\t\t\tif (!options.continuousWorld && !options.noWrap) {\r\n\t\t\t\tnw = nw.wrap();\r\n\t\t\t\tse = se.wrap();\r\n\t\t\t}\r\n\r\n\t\t\tif (!options.bounds.intersects([nw, se])) { return false; }\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\t_removeOtherTiles: function (bounds) {\r\n\t\tvar kArr, x, y, key;\r\n\r\n\t\tfor (key in this._tiles) {\r\n\t\t\tkArr = key.split(':');\r\n\t\t\tx = parseInt(kArr[0], 10);\r\n\t\t\ty = parseInt(kArr[1], 10);\r\n\r\n\t\t\t// remove tile if it's out of bounds\r\n\t\t\tif (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\r\n\t\t\t\tthis._removeTile(key);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_removeTile: function (key) {\r\n\t\tvar tile = this._tiles[key];\r\n\r\n\t\tthis.fire('tileunload', {tile: tile, url: tile.src});\r\n\r\n\t\tif (this.options.reuseTiles) {\r\n\t\t\tL.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\r\n\t\t\tthis._unusedTiles.push(tile);\r\n\r\n\t\t} else if (tile.parentNode === this._tileContainer) {\r\n\t\t\tthis._tileContainer.removeChild(tile);\r\n\t\t}\r\n\r\n\t\t// for https://github.com/CloudMade/Leaflet/issues/137\r\n\t\tif (!L.Browser.android) {\r\n\t\t\ttile.onload = null;\r\n\t\t\ttile.src = L.Util.emptyImageUrl;\r\n\t\t}\r\n\r\n\t\tdelete this._tiles[key];\r\n\t},\r\n\r\n\t_addTile: function (tilePoint, container) {\r\n\t\tvar tilePos = this._getTilePos(tilePoint);\r\n\r\n\t\t// get unused tile - or create a new tile\r\n\t\tvar tile = this._getTile();\r\n\r\n\t\t/*\r\n\t\tChrome 20 layouts much faster with top/left (verify with timeline, frames)\r\n\t\tAndroid 4 browser has display issues with top/left and requires transform instead\r\n\t\t(other browsers don't currently care) - see debug/hacks/jitter.html for an example\r\n\t\t*/\r\n\t\tL.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);\r\n\r\n\t\tthis._tiles[tilePoint.x + ':' + tilePoint.y] = tile;\r\n\r\n\t\tthis._loadTile(tile, tilePoint);\r\n\r\n\t\tif (tile.parentNode !== this._tileContainer) {\r\n\t\t\tcontainer.appendChild(tile);\r\n\t\t}\r\n\t},\r\n\r\n\t_getZoomForUrl: function () {\r\n\r\n\t\tvar options = this.options,\r\n\t\t    zoom = this._map.getZoom();\r\n\r\n\t\tif (options.zoomReverse) {\r\n\t\t\tzoom = options.maxZoom - zoom;\r\n\t\t}\r\n\r\n\t\tzoom += options.zoomOffset;\r\n\r\n\t\treturn options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;\r\n\t},\r\n\r\n\t_getTilePos: function (tilePoint) {\r\n\t\tvar origin = this._map.getPixelOrigin(),\r\n\t\t    tileSize = this._getTileSize();\r\n\r\n\t\treturn tilePoint.multiplyBy(tileSize).subtract(origin);\r\n\t},\r\n\r\n\t// image-specific code (override to implement e.g. Canvas or SVG tile layer)\r\n\r\n\tgetTileUrl: function (tilePoint) {\r\n\t\treturn L.Util.template(this._url, L.extend({\r\n\t\t\ts: this._getSubdomain(tilePoint),\r\n\t\t\tz: tilePoint.z,\r\n\t\t\tx: tilePoint.x,\r\n\t\t\ty: tilePoint.y\r\n\t\t}, this.options));\r\n\t},\r\n\r\n\t_getWrapTileNum: function () {\r\n\t\tvar crs = this._map.options.crs,\r\n\t\t    size = crs.getSize(this._map.getZoom());\r\n\t\treturn size.divideBy(this._getTileSize())._floor();\r\n\t},\r\n\r\n\t_adjustTilePoint: function (tilePoint) {\r\n\r\n\t\tvar limit = this._getWrapTileNum();\r\n\r\n\t\t// wrap tile coordinates\r\n\t\tif (!this.options.continuousWorld && !this.options.noWrap) {\r\n\t\t\ttilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;\r\n\t\t}\r\n\r\n\t\tif (this.options.tms) {\r\n\t\t\ttilePoint.y = limit.y - tilePoint.y - 1;\r\n\t\t}\r\n\r\n\t\ttilePoint.z = this._getZoomForUrl();\r\n\t},\r\n\r\n\t_getSubdomain: function (tilePoint) {\r\n\t\tvar index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;\r\n\t\treturn this.options.subdomains[index];\r\n\t},\r\n\r\n\t_getTile: function () {\r\n\t\tif (this.options.reuseTiles && this._unusedTiles.length > 0) {\r\n\t\t\tvar tile = this._unusedTiles.pop();\r\n\t\t\tthis._resetTile(tile);\r\n\t\t\treturn tile;\r\n\t\t}\r\n\t\treturn this._createTile();\r\n\t},\r\n\r\n\t// Override if data stored on a tile needs to be cleaned up before reuse\r\n\t_resetTile: function (/*tile*/) {},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('img', 'leaflet-tile');\r\n\t\ttile.style.width = tile.style.height = this._getTileSize() + 'px';\r\n\t\ttile.galleryimg = 'no';\r\n\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\r\n\t\tif (L.Browser.ielt9 && this.options.opacity !== undefined) {\r\n\t\t\tL.DomUtil.setOpacity(tile, this.options.opacity);\r\n\t\t}\r\n\t\t// without this hack, tiles disappear after zoom on Chrome for Android\r\n\t\t// https://github.com/Leaflet/Leaflet/issues/2078\r\n\t\tif (L.Browser.mobileWebkit3d) {\r\n\t\t\ttile.style.WebkitBackfaceVisibility = 'hidden';\r\n\t\t}\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer  = this;\r\n\t\ttile.onload  = this._tileOnLoad;\r\n\t\ttile.onerror = this._tileOnError;\r\n\r\n\t\tthis._adjustTilePoint(tilePoint);\r\n\t\ttile.src     = this.getTileUrl(tilePoint);\r\n\r\n\t\tthis.fire('tileloadstart', {\r\n\t\t\ttile: tile,\r\n\t\t\turl: tile.src\r\n\t\t});\r\n\t},\r\n\r\n\t_tileLoaded: function () {\r\n\t\tthis._tilesToLoad--;\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tL.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');\r\n\t\t}\r\n\r\n\t\tif (!this._tilesToLoad) {\r\n\t\t\tthis.fire('load');\r\n\r\n\t\t\tif (this._animated) {\r\n\t\t\t\t// clear scaled tiles after all new tiles are loaded (for performance)\r\n\t\t\t\tclearTimeout(this._clearBgBufferTimer);\r\n\t\t\t\tthis._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_tileOnLoad: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\t//Only if we are loading an actual image\r\n\t\tif (this.src !== L.Util.emptyImageUrl) {\r\n\t\t\tL.DomUtil.addClass(this, 'leaflet-tile-loaded');\r\n\r\n\t\t\tlayer.fire('tileload', {\r\n\t\t\t\ttile: this,\r\n\t\t\t\turl: this.src\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t},\r\n\r\n\t_tileOnError: function () {\r\n\t\tvar layer = this._layer;\r\n\r\n\t\tlayer.fire('tileerror', {\r\n\t\t\ttile: this,\r\n\t\t\turl: this.src\r\n\t\t});\r\n\r\n\t\tvar newUrl = layer.options.errorTileUrl;\r\n\t\tif (newUrl) {\r\n\t\t\tthis.src = newUrl;\r\n\t\t}\r\n\r\n\t\tlayer._tileLoaded();\r\n\t}\r\n});\r\n\r\nL.tileLayer = function (url, options) {\r\n\treturn new L.TileLayer(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.WMS is used for putting WMS tile layers on the map.\r\n */\r\n\r\nL.TileLayer.WMS = L.TileLayer.extend({\r\n\r\n\tdefaultWmsParams: {\r\n\t\tservice: 'WMS',\r\n\t\trequest: 'GetMap',\r\n\t\tversion: '1.1.1',\r\n\t\tlayers: '',\r\n\t\tstyles: '',\r\n\t\tformat: 'image/jpeg',\r\n\t\ttransparent: false\r\n\t},\r\n\r\n\tinitialize: function (url, options) { // (String, Object)\r\n\r\n\t\tthis._url = url;\r\n\r\n\t\tvar wmsParams = L.extend({}, this.defaultWmsParams),\r\n\t\t    tileSize = options.tileSize || this.options.tileSize;\r\n\r\n\t\tif (options.detectRetina && L.Browser.retina) {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize * 2;\r\n\t\t} else {\r\n\t\t\twmsParams.width = wmsParams.height = tileSize;\r\n\t\t}\r\n\r\n\t\tfor (var i in options) {\r\n\t\t\t// all keys that are not TileLayer options go to WMS params\r\n\t\t\tif (!this.options.hasOwnProperty(i) && i !== 'crs') {\r\n\t\t\t\twmsParams[i] = options[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.wmsParams = wmsParams;\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\r\n\t\tthis._crs = this.options.crs || map.options.crs;\r\n\r\n\t\tthis._wmsVersion = parseFloat(this.wmsParams.version);\r\n\r\n\t\tvar projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';\r\n\t\tthis.wmsParams[projectionKey] = this._crs.code;\r\n\r\n\t\tL.TileLayer.prototype.onAdd.call(this, map);\r\n\t},\r\n\r\n\tgetTileUrl: function (tilePoint) { // (Point, Number) -> String\r\n\r\n\t\tvar map = this._map,\r\n\t\t    tileSize = this.options.tileSize,\r\n\r\n\t\t    nwPoint = tilePoint.multiplyBy(tileSize),\r\n\t\t    sePoint = nwPoint.add([tileSize, tileSize]),\r\n\r\n\t\t    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),\r\n\t\t    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),\r\n\t\t    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?\r\n\t\t        [se.y, nw.x, nw.y, se.x].join(',') :\r\n\t\t        [nw.x, se.y, se.x, nw.y].join(','),\r\n\r\n\t\t    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});\r\n\r\n\t\treturn url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;\r\n\t},\r\n\r\n\tsetParams: function (params, noRedraw) {\r\n\r\n\t\tL.extend(this.wmsParams, params);\r\n\r\n\t\tif (!noRedraw) {\r\n\t\t\tthis.redraw();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.tileLayer.wms = function (url, options) {\r\n\treturn new L.TileLayer.WMS(url, options);\r\n};\r\n\n\n/*\r\n * L.TileLayer.Canvas is a class that you can use as a base for creating\r\n * dynamically drawn Canvas-based tile layers.\r\n */\r\n\r\nL.TileLayer.Canvas = L.TileLayer.extend({\r\n\toptions: {\r\n\t\tasync: false\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._reset({hard: true});\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tfor (var i in this._tiles) {\r\n\t\t\tthis._redrawTile(this._tiles[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_redrawTile: function (tile) {\r\n\t\tthis.drawTile(tile, tile._tilePoint, this._map._zoom);\r\n\t},\r\n\r\n\t_createTile: function () {\r\n\t\tvar tile = L.DomUtil.create('canvas', 'leaflet-tile');\r\n\t\ttile.width = tile.height = this.options.tileSize;\r\n\t\ttile.onselectstart = tile.onmousemove = L.Util.falseFn;\r\n\t\treturn tile;\r\n\t},\r\n\r\n\t_loadTile: function (tile, tilePoint) {\r\n\t\ttile._layer = this;\r\n\t\ttile._tilePoint = tilePoint;\r\n\r\n\t\tthis._redrawTile(tile);\r\n\r\n\t\tif (!this.options.async) {\r\n\t\t\tthis.tileDrawn(tile);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawTile: function (/*tile, tilePoint*/) {\r\n\t\t// override with rendering code\r\n\t},\r\n\r\n\ttileDrawn: function (tile) {\r\n\t\tthis._tileOnLoad.call(tile);\r\n\t}\r\n});\r\n\r\n\r\nL.tileLayer.canvas = function (options) {\r\n\treturn new L.TileLayer.Canvas(options);\r\n};\r\n\n\n/*\r\n * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).\r\n */\r\n\r\nL.ImageOverlay = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\topacity: 1\r\n\t},\r\n\r\n\tinitialize: function (url, bounds, options) { // (String, LatLngBounds, Object)\r\n\t\tthis._url = url;\r\n\t\tthis._bounds = L.latLngBounds(bounds);\r\n\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._image) {\r\n\t\t\tthis._initImage();\r\n\t\t}\r\n\r\n\t\tmap._panes.overlayPane.appendChild(this._image);\r\n\r\n\t\tmap.on('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\r\n\t\tthis._reset();\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.getPanes().overlayPane.removeChild(this._image);\r\n\r\n\t\tmap.off('viewreset', this._reset, this);\r\n\r\n\t\tif (map.options.zoomAnimation) {\r\n\t\t\tmap.off('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tthis._updateOpacity();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// TODO remove bringToFront/bringToBack duplication from TileLayer/Path\r\n\tbringToFront: function () {\r\n\t\tif (this._image) {\r\n\t\t\tthis._map._panes.overlayPane.appendChild(this._image);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar pane = this._map._panes.overlayPane;\r\n\t\tif (this._image) {\r\n\t\t\tpane.insertBefore(this._image, pane.firstChild);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetUrl: function (url) {\r\n\t\tthis._url = url;\r\n\t\tthis._image.src = this._url;\r\n\t},\r\n\r\n\tgetAttribution: function () {\r\n\t\treturn this.options.attribution;\r\n\t},\r\n\r\n\t_initImage: function () {\r\n\t\tthis._image = L.DomUtil.create('img', 'leaflet-image-layer');\r\n\r\n\t\tif (this._map.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-animated');\r\n\t\t} else {\r\n\t\t\tL.DomUtil.addClass(this._image, 'leaflet-zoom-hide');\r\n\t\t}\r\n\r\n\t\tthis._updateOpacity();\r\n\r\n\t\t//TODO createImage util method to remove duplication\r\n\t\tL.extend(this._image, {\r\n\t\t\tgalleryimg: 'no',\r\n\t\t\tonselectstart: L.Util.falseFn,\r\n\t\t\tonmousemove: L.Util.falseFn,\r\n\t\t\tonload: L.bind(this._onImageLoad, this),\r\n\t\t\tsrc: this._url\r\n\t\t});\r\n\t},\r\n\r\n\t_animateZoom: function (e) {\r\n\t\tvar map = this._map,\r\n\t\t    image = this._image,\r\n\t\t    scale = map.getZoomScale(e.zoom),\r\n\t\t    nw = this._bounds.getNorthWest(),\r\n\t\t    se = this._bounds.getSouthEast(),\r\n\r\n\t\t    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),\r\n\t\t    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),\r\n\t\t    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));\r\n\r\n\t\timage.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';\r\n\t},\r\n\r\n\t_reset: function () {\r\n\t\tvar image   = this._image,\r\n\t\t    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),\r\n\t\t    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);\r\n\r\n\t\tL.DomUtil.setPosition(image, topLeft);\r\n\r\n\t\timage.style.width  = size.x + 'px';\r\n\t\timage.style.height = size.y + 'px';\r\n\t},\r\n\r\n\t_onImageLoad: function () {\r\n\t\tthis.fire('load');\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._image, this.options.opacity);\r\n\t}\r\n});\r\n\r\nL.imageOverlay = function (url, bounds, options) {\r\n\treturn new L.ImageOverlay(url, bounds, options);\r\n};\r\n\n\n/*\r\n * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.\r\n */\r\n\r\nL.Icon = L.Class.extend({\r\n\toptions: {\r\n\t\t/*\r\n\t\ticonUrl: (String) (required)\r\n\t\ticonRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\ticonSize: (Point) (can be set through CSS)\r\n\t\ticonAnchor: (Point) (centered by default, can be set in CSS with negative margins)\r\n\t\tpopupAnchor: (Point) (if not specified, popup opens in the anchor point)\r\n\t\tshadowUrl: (String) (no shadow by default)\r\n\t\tshadowRetinaUrl: (String) (optional, used for retina devices if detected)\r\n\t\tshadowSize: (Point)\r\n\t\tshadowAnchor: (Point)\r\n\t\t*/\r\n\t\tclassName: ''\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tcreateIcon: function (oldIcon) {\r\n\t\treturn this._createIcon('icon', oldIcon);\r\n\t},\r\n\r\n\tcreateShadow: function (oldIcon) {\r\n\t\treturn this._createIcon('shadow', oldIcon);\r\n\t},\r\n\r\n\t_createIcon: function (name, oldIcon) {\r\n\t\tvar src = this._getIconUrl(name);\r\n\r\n\t\tif (!src) {\r\n\t\t\tif (name === 'icon') {\r\n\t\t\t\tthrow new Error('iconUrl not set in Icon options (see the docs).');\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar img;\r\n\t\tif (!oldIcon || oldIcon.tagName !== 'IMG') {\r\n\t\t\timg = this._createImg(src);\r\n\t\t} else {\r\n\t\t\timg = this._createImg(src, oldIcon);\r\n\t\t}\r\n\t\tthis._setIconStyles(img, name);\r\n\r\n\t\treturn img;\r\n\t},\r\n\r\n\t_setIconStyles: function (img, name) {\r\n\t\tvar options = this.options,\r\n\t\t    size = L.point(options[name + 'Size']),\r\n\t\t    anchor;\r\n\r\n\t\tif (name === 'shadow') {\r\n\t\t\tanchor = L.point(options.shadowAnchor || options.iconAnchor);\r\n\t\t} else {\r\n\t\t\tanchor = L.point(options.iconAnchor);\r\n\t\t}\r\n\r\n\t\tif (!anchor && size) {\r\n\t\t\tanchor = size.divideBy(2, true);\r\n\t\t}\r\n\r\n\t\timg.className = 'leaflet-marker-' + name + ' ' + options.className;\r\n\r\n\t\tif (anchor) {\r\n\t\t\timg.style.marginLeft = (-anchor.x) + 'px';\r\n\t\t\timg.style.marginTop  = (-anchor.y) + 'px';\r\n\t\t}\r\n\r\n\t\tif (size) {\r\n\t\t\timg.style.width  = size.x + 'px';\r\n\t\t\timg.style.height = size.y + 'px';\r\n\t\t}\r\n\t},\r\n\r\n\t_createImg: function (src, el) {\r\n\t\tel = el || document.createElement('img');\r\n\t\tel.src = src;\r\n\t\treturn el;\r\n\t},\r\n\r\n\t_getIconUrl: function (name) {\r\n\t\tif (L.Browser.retina && this.options[name + 'RetinaUrl']) {\r\n\t\t\treturn this.options[name + 'RetinaUrl'];\r\n\t\t}\r\n\t\treturn this.options[name + 'Url'];\r\n\t}\r\n});\r\n\r\nL.icon = function (options) {\r\n\treturn new L.Icon(options);\r\n};\r\n\n\n/*\n * L.Icon.Default is the blue marker icon used by default in Leaflet.\n */\n\nL.Icon.Default = L.Icon.extend({\n\n\toptions: {\n\t\ticonSize: [25, 41],\n\t\ticonAnchor: [12, 41],\n\t\tpopupAnchor: [1, -34],\n\n\t\tshadowSize: [41, 41]\n\t},\n\n\t_getIconUrl: function (name) {\n\t\tvar key = name + 'Url';\n\n\t\tif (this.options[key]) {\n\t\t\treturn this.options[key];\n\t\t}\n\n\t\tif (L.Browser.retina && name === 'icon') {\n\t\t\tname += '-2x';\n\t\t}\n\n\t\tvar path = L.Icon.Default.imagePath;\n\n\t\tif (!path) {\n\t\t\tthrow new Error('Couldn\\'t autodetect L.Icon.Default.imagePath, set it manually.');\n\t\t}\n\n\t\treturn path + '/marker-' + name + '.png';\n\t}\n});\n\nL.Icon.Default.imagePath = (function () {\n\tvar scripts = document.getElementsByTagName('script'),\n\t    leafletRe = /[\\/^]leaflet[\\-\\._]?([\\w\\-\\._]*)\\.js\\??/;\n\n\tvar i, len, src, matches, path;\n\n\tfor (i = 0, len = scripts.length; i < len; i++) {\n\t\tsrc = scripts[i].src;\n\t\tmatches = src.match(leafletRe);\n\n\t\tif (matches) {\n\t\t\tpath = src.split(leafletRe)[0];\n\t\t\treturn (path ? path + '/' : '') + 'images';\n\t\t}\n\t}\n}());\n\n\n/*\r\n * L.Marker is used to display clickable/draggable icons on the map.\r\n */\r\n\r\nL.Marker = L.Class.extend({\r\n\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\ticon: new L.Icon.Default(),\r\n\t\ttitle: '',\r\n\t\talt: '',\r\n\t\tclickable: true,\r\n\t\tdraggable: false,\r\n\t\tkeyboard: true,\r\n\t\tzIndexOffset: 0,\r\n\t\topacity: 1,\r\n\t\triseOnHover: false,\r\n\t\triseOffset: 250\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tmap.on('viewreset', this.update, this);\r\n\r\n\t\tthis._initIcon();\r\n\t\tthis.update();\r\n\t\tthis.fire('add');\r\n\r\n\t\tif (map.options.zoomAnimation && map.options.markerZoomAnimation) {\r\n\t\t\tmap.on('zoomanim', this._animateZoom, this);\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tif (this.dragging) {\r\n\t\t\tthis.dragging.disable();\r\n\t\t}\r\n\r\n\t\tthis._removeIcon();\r\n\t\tthis._removeShadow();\r\n\r\n\t\tthis.fire('remove');\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.update,\r\n\t\t\t'zoomanim': this._animateZoom\r\n\t\t}, this);\r\n\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\r\n\t\tthis.update();\r\n\r\n\t\treturn this.fire('move', { latlng: this._latlng });\r\n\t},\r\n\r\n\tsetZIndexOffset: function (offset) {\r\n\t\tthis.options.zIndexOffset = offset;\r\n\t\tthis.update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetIcon: function (icon) {\r\n\r\n\t\tthis.options.icon = icon;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._initIcon();\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\tif (this._popup) {\r\n\t\t\tthis.bindPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (this._icon) {\r\n\t\t\tvar pos = this._map.latLngToLayerPoint(this._latlng).round();\r\n\t\t\tthis._setPos(pos);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initIcon: function () {\r\n\t\tvar options = this.options,\r\n\t\t    map = this._map,\r\n\t\t    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),\r\n\t\t    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';\r\n\r\n\t\tvar icon = options.icon.createIcon(this._icon),\r\n\t\t\taddIcon = false;\r\n\r\n\t\t// if we're not reusing the icon, remove the old one and init new one\r\n\t\tif (icon !== this._icon) {\r\n\t\t\tif (this._icon) {\r\n\t\t\t\tthis._removeIcon();\r\n\t\t\t}\r\n\t\t\taddIcon = true;\r\n\r\n\t\t\tif (options.title) {\r\n\t\t\t\ticon.title = options.title;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (options.alt) {\r\n\t\t\t\ticon.alt = options.alt;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tL.DomUtil.addClass(icon, classToAdd);\r\n\r\n\t\tif (options.keyboard) {\r\n\t\t\ticon.tabIndex = '0';\r\n\t\t}\r\n\r\n\t\tthis._icon = icon;\r\n\r\n\t\tthis._initInteraction();\r\n\r\n\t\tif (options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.on(icon, 'mouseover', this._bringToFront, this)\r\n\t\t\t\t.on(icon, 'mouseout', this._resetZIndex, this);\r\n\t\t}\r\n\r\n\t\tvar newShadow = options.icon.createShadow(this._shadow),\r\n\t\t\taddShadow = false;\r\n\r\n\t\tif (newShadow !== this._shadow) {\r\n\t\t\tthis._removeShadow();\r\n\t\t\taddShadow = true;\r\n\t\t}\r\n\r\n\t\tif (newShadow) {\r\n\t\t\tL.DomUtil.addClass(newShadow, classToAdd);\r\n\t\t}\r\n\t\tthis._shadow = newShadow;\r\n\r\n\r\n\t\tif (options.opacity < 1) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\r\n\t\tvar panes = this._map._panes;\r\n\r\n\t\tif (addIcon) {\r\n\t\t\tpanes.markerPane.appendChild(this._icon);\r\n\t\t}\r\n\r\n\t\tif (newShadow && addShadow) {\r\n\t\t\tpanes.shadowPane.appendChild(this._shadow);\r\n\t\t}\r\n\t},\r\n\r\n\t_removeIcon: function () {\r\n\t\tif (this.options.riseOnHover) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(this._icon, 'mouseover', this._bringToFront)\r\n\t\t\t    .off(this._icon, 'mouseout', this._resetZIndex);\r\n\t\t}\r\n\r\n\t\tthis._map._panes.markerPane.removeChild(this._icon);\r\n\r\n\t\tthis._icon = null;\r\n\t},\r\n\r\n\t_removeShadow: function () {\r\n\t\tif (this._shadow) {\r\n\t\t\tthis._map._panes.shadowPane.removeChild(this._shadow);\r\n\t\t}\r\n\t\tthis._shadow = null;\r\n\t},\r\n\r\n\t_setPos: function (pos) {\r\n\t\tL.DomUtil.setPosition(this._icon, pos);\r\n\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setPosition(this._shadow, pos);\r\n\t\t}\r\n\r\n\t\tthis._zIndex = pos.y + this.options.zIndexOffset;\r\n\r\n\t\tthis._resetZIndex();\r\n\t},\r\n\r\n\t_updateZIndex: function (offset) {\r\n\t\tthis._icon.style.zIndex = this._zIndex + offset;\r\n\t},\r\n\r\n\t_animateZoom: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();\r\n\r\n\t\tthis._setPos(pos);\r\n\t},\r\n\r\n\t_initInteraction: function () {\r\n\r\n\t\tif (!this.options.clickable) { return; }\r\n\r\n\t\t// TODO refactor into something shared with Map/Path/etc. to DRY it up\r\n\r\n\t\tvar icon = this._icon,\r\n\t\t    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];\r\n\r\n\t\tL.DomUtil.addClass(icon, 'leaflet-clickable');\r\n\t\tL.DomEvent.on(icon, 'click', this._onMouseClick, this);\r\n\t\tL.DomEvent.on(icon, 'keypress', this._onKeyPress, this);\r\n\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tL.DomEvent.on(icon, events[i], this._fireMouseEvent, this);\r\n\t\t}\r\n\r\n\t\tif (L.Handler.MarkerDrag) {\r\n\t\t\tthis.dragging = new L.Handler.MarkerDrag(this);\r\n\r\n\t\t\tif (this.options.draggable) {\r\n\t\t\t\tthis.dragging.enable();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tvar wasDragged = this.dragging && this.dragging.moved();\r\n\r\n\t\tif (this.hasEventListeners(e.type) || wasDragged) {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\r\n\t\tif (wasDragged) { return; }\r\n\r\n\t\tif ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\t},\r\n\r\n\t_onKeyPress: function (e) {\r\n\t\tif (e.keyCode === 13) {\r\n\t\t\tthis.fire('click', {\r\n\t\t\t\toriginalEvent: e,\r\n\t\t\t\tlatlng: this._latlng\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\toriginalEvent: e,\r\n\t\t\tlatlng: this._latlng\r\n\t\t});\r\n\r\n\t\t// TODO proper custom event propagation\r\n\t\t// this line will always be called if marker is in a FeatureGroup\r\n\t\tif (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousedown') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t},\r\n\r\n\tsetOpacity: function (opacity) {\r\n\t\tthis.options.opacity = opacity;\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateOpacity();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_updateOpacity: function () {\r\n\t\tL.DomUtil.setOpacity(this._icon, this.options.opacity);\r\n\t\tif (this._shadow) {\r\n\t\t\tL.DomUtil.setOpacity(this._shadow, this.options.opacity);\r\n\t\t}\r\n\t},\r\n\r\n\t_bringToFront: function () {\r\n\t\tthis._updateZIndex(this.options.riseOffset);\r\n\t},\r\n\r\n\t_resetZIndex: function () {\r\n\t\tthis._updateZIndex(0);\r\n\t}\r\n});\r\n\r\nL.marker = function (latlng, options) {\r\n\treturn new L.Marker(latlng, options);\r\n};\r\n\n\n/*\n * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)\n * to use with L.Marker.\n */\n\nL.DivIcon = L.Icon.extend({\n\toptions: {\n\t\ticonSize: [12, 12], // also can be set through CSS\n\t\t/*\n\t\ticonAnchor: (Point)\n\t\tpopupAnchor: (Point)\n\t\thtml: (String)\n\t\tbgPos: (Point)\n\t\t*/\n\t\tclassName: 'leaflet-div-icon',\n\t\thtml: false\n\t},\n\n\tcreateIcon: function (oldIcon) {\n\t\tvar div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),\n\t\t    options = this.options;\n\n\t\tif (options.html !== false) {\n\t\t\tdiv.innerHTML = options.html;\n\t\t} else {\n\t\t\tdiv.innerHTML = '';\n\t\t}\n\n\t\tif (options.bgPos) {\n\t\t\tdiv.style.backgroundPosition =\n\t\t\t        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';\n\t\t}\n\n\t\tthis._setIconStyles(div, 'icon');\n\t\treturn div;\n\t},\n\n\tcreateShadow: function () {\n\t\treturn null;\n\t}\n});\n\nL.divIcon = function (options) {\n\treturn new L.DivIcon(options);\n};\n\n\n/*\r\n * L.Popup is used for displaying popups on the map.\r\n */\r\n\r\nL.Map.mergeOptions({\r\n\tclosePopupOnClick: true\r\n});\r\n\r\nL.Popup = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\toptions: {\r\n\t\tminWidth: 50,\r\n\t\tmaxWidth: 300,\r\n\t\t// maxHeight: null,\r\n\t\tautoPan: true,\r\n\t\tcloseButton: true,\r\n\t\toffset: [0, 7],\r\n\t\tautoPanPadding: [5, 5],\r\n\t\t// autoPanPaddingTopLeft: null,\r\n\t\t// autoPanPaddingBottomRight: null,\r\n\t\tkeepInView: false,\r\n\t\tclassName: '',\r\n\t\tzoomAnimation: true\r\n\t},\r\n\r\n\tinitialize: function (options, source) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._source = source;\r\n\t\tthis._animated = L.Browser.any3d && this.options.zoomAnimation;\r\n\t\tthis._isOpen = false;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initLayout();\r\n\t\t}\r\n\r\n\t\tvar animFade = map.options.fadeAnimation;\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\t\tmap._panes.popupPane.appendChild(this._container);\r\n\r\n\t\tmap.on(this._getEvents(), this);\r\n\r\n\t\tthis.update();\r\n\r\n\t\tif (animFade) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 1);\r\n\t\t}\r\n\r\n\t\tthis.fire('open');\r\n\r\n\t\tmap.fire('popupopen', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupopen', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenOn: function (map) {\r\n\t\tmap.openPopup(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._panes.popupPane.removeChild(this._container);\r\n\r\n\t\tL.Util.falseFn(this._container.offsetWidth); // force reflow\r\n\r\n\t\tmap.off(this._getEvents(), this);\r\n\r\n\t\tif (map.options.fadeAnimation) {\r\n\t\t\tL.DomUtil.setOpacity(this._container, 0);\r\n\t\t}\r\n\r\n\t\tthis._map = null;\r\n\r\n\t\tthis.fire('close');\r\n\r\n\t\tmap.fire('popupclose', {popup: this});\r\n\r\n\t\tif (this._source) {\r\n\t\t\tthis._source.fire('popupclose', {popup: this});\r\n\t\t}\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tif (this._map) {\r\n\t\t\tthis._updatePosition();\r\n\t\t\tthis._adjustPan();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContent: function () {\r\n\t\treturn this._content;\r\n\t},\r\n\r\n\tsetContent: function (content) {\r\n\t\tthis._content = content;\r\n\t\tthis.update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tupdate: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._container.style.visibility = 'hidden';\r\n\r\n\t\tthis._updateContent();\r\n\t\tthis._updateLayout();\r\n\t\tthis._updatePosition();\r\n\r\n\t\tthis._container.style.visibility = '';\r\n\r\n\t\tthis._adjustPan();\r\n\t},\r\n\r\n\t_getEvents: function () {\r\n\t\tvar events = {\r\n\t\t\tviewreset: this._updatePosition\r\n\t\t};\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tevents.zoomanim = this._zoomAnimation;\r\n\t\t}\r\n\t\tif ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {\r\n\t\t\tevents.preclick = this._close;\r\n\t\t}\r\n\t\tif (this.options.keepInView) {\r\n\t\t\tevents.moveend = this._adjustPan;\r\n\t\t}\r\n\r\n\t\treturn events;\r\n\t},\r\n\r\n\t_close: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.closePopup(this);\r\n\t\t}\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar prefix = 'leaflet-popup',\r\n\t\t\tcontainerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +\r\n\t\t\t        (this._animated ? 'animated' : 'hide'),\r\n\t\t\tcontainer = this._container = L.DomUtil.create('div', containerClass),\r\n\t\t\tcloseButton;\r\n\r\n\t\tif (this.options.closeButton) {\r\n\t\t\tcloseButton = this._closeButton =\r\n\t\t\t        L.DomUtil.create('a', prefix + '-close-button', container);\r\n\t\t\tcloseButton.href = '#close';\r\n\t\t\tcloseButton.innerHTML = '&#215;';\r\n\t\t\tL.DomEvent.disableClickPropagation(closeButton);\r\n\r\n\t\t\tL.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);\r\n\t\t}\r\n\r\n\t\tvar wrapper = this._wrapper =\r\n\t\t        L.DomUtil.create('div', prefix + '-content-wrapper', container);\r\n\t\tL.DomEvent.disableClickPropagation(wrapper);\r\n\r\n\t\tthis._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);\r\n\r\n\t\tL.DomEvent.disableScrollPropagation(this._contentNode);\r\n\t\tL.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);\r\n\r\n\t\tthis._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);\r\n\t\tthis._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);\r\n\t},\r\n\r\n\t_updateContent: function () {\r\n\t\tif (!this._content) { return; }\r\n\r\n\t\tif (typeof this._content === 'string') {\r\n\t\t\tthis._contentNode.innerHTML = this._content;\r\n\t\t} else {\r\n\t\t\twhile (this._contentNode.hasChildNodes()) {\r\n\t\t\t\tthis._contentNode.removeChild(this._contentNode.firstChild);\r\n\t\t\t}\r\n\t\t\tthis._contentNode.appendChild(this._content);\r\n\t\t}\r\n\t\tthis.fire('contentupdate');\r\n\t},\r\n\r\n\t_updateLayout: function () {\r\n\t\tvar container = this._contentNode,\r\n\t\t    style = container.style;\r\n\r\n\t\tstyle.width = '';\r\n\t\tstyle.whiteSpace = 'nowrap';\r\n\r\n\t\tvar width = container.offsetWidth;\r\n\t\twidth = Math.min(width, this.options.maxWidth);\r\n\t\twidth = Math.max(width, this.options.minWidth);\r\n\r\n\t\tstyle.width = (width + 1) + 'px';\r\n\t\tstyle.whiteSpace = '';\r\n\r\n\t\tstyle.height = '';\r\n\r\n\t\tvar height = container.offsetHeight,\r\n\t\t    maxHeight = this.options.maxHeight,\r\n\t\t    scrolledClass = 'leaflet-popup-scrolled';\r\n\r\n\t\tif (maxHeight && height > maxHeight) {\r\n\t\t\tstyle.height = maxHeight + 'px';\r\n\t\t\tL.DomUtil.addClass(container, scrolledClass);\r\n\t\t} else {\r\n\t\t\tL.DomUtil.removeClass(container, scrolledClass);\r\n\t\t}\r\n\r\n\t\tthis._containerWidth = this._container.offsetWidth;\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar pos = this._map.latLngToLayerPoint(this._latlng),\r\n\t\t    animated = this._animated,\r\n\t\t    offset = L.point(this.options.offset);\r\n\r\n\t\tif (animated) {\r\n\t\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t\t}\r\n\r\n\t\tthis._containerBottom = -offset.y - (animated ? 0 : pos.y);\r\n\t\tthis._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);\r\n\r\n\t\t// bottom position the popup in case the height of the popup changes (images loading etc)\r\n\t\tthis._container.style.bottom = this._containerBottom + 'px';\r\n\t\tthis._container.style.left = this._containerLeft + 'px';\r\n\t},\r\n\r\n\t_zoomAnimation: function (opt) {\r\n\t\tvar pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);\r\n\r\n\t\tL.DomUtil.setPosition(this._container, pos);\r\n\t},\r\n\r\n\t_adjustPan: function () {\r\n\t\tif (!this.options.autoPan) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerHeight = this._container.offsetHeight,\r\n\t\t    containerWidth = this._containerWidth,\r\n\r\n\t\t    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\r\n\r\n\t\tif (this._animated) {\r\n\t\t\tlayerPos._add(L.DomUtil.getPosition(this._container));\r\n\t\t}\r\n\r\n\t\tvar containerPos = map.layerPointToContainerPoint(layerPos),\r\n\t\t    padding = L.point(this.options.autoPanPadding),\r\n\t\t    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\r\n\t\t    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\r\n\t\t    size = map.getSize(),\r\n\t\t    dx = 0,\r\n\t\t    dy = 0;\r\n\r\n\t\tif (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\r\n\t\t\tdx = containerPos.x + containerWidth - size.x + paddingBR.x;\r\n\t\t}\r\n\t\tif (containerPos.x - dx - paddingTL.x < 0) { // left\r\n\t\t\tdx = containerPos.x - paddingTL.x;\r\n\t\t}\r\n\t\tif (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\r\n\t\t\tdy = containerPos.y + containerHeight - size.y + paddingBR.y;\r\n\t\t}\r\n\t\tif (containerPos.y - dy - paddingTL.y < 0) { // top\r\n\t\t\tdy = containerPos.y - paddingTL.y;\r\n\t\t}\r\n\r\n\t\tif (dx || dy) {\r\n\t\t\tmap\r\n\t\t\t    .fire('autopanstart')\r\n\t\t\t    .panBy([dx, dy]);\r\n\t\t}\r\n\t},\r\n\r\n\t_onCloseButtonClick: function (e) {\r\n\t\tthis._close();\r\n\t\tL.DomEvent.stop(e);\r\n\t}\r\n});\r\n\r\nL.popup = function (options, source) {\r\n\treturn new L.Popup(options, source);\r\n};\r\n\r\n\r\nL.Map.include({\r\n\topenPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])\r\n\t\tthis.closePopup();\r\n\r\n\t\tif (!(popup instanceof L.Popup)) {\r\n\t\t\tvar content = popup;\r\n\r\n\t\t\tpopup = new L.Popup(options)\r\n\t\t\t    .setLatLng(latlng)\r\n\t\t\t    .setContent(content);\r\n\t\t}\r\n\t\tpopup._isOpen = true;\r\n\r\n\t\tthis._popup = popup;\r\n\t\treturn this.addLayer(popup);\r\n\t},\r\n\r\n\tclosePopup: function (popup) {\r\n\t\tif (!popup || popup === this._popup) {\r\n\t\t\tpopup = this._popup;\r\n\t\t\tthis._popup = null;\r\n\t\t}\r\n\t\tif (popup) {\r\n\t\t\tthis.removeLayer(popup);\r\n\t\t\tpopup._isOpen = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Marker, adding popup-related methods.\r\n */\r\n\r\nL.Marker.include({\r\n\topenPopup: function () {\r\n\t\tif (this._popup && this._map && !this._map.hasLayer(this._popup)) {\r\n\t\t\tthis._popup.setLatLng(this._latlng);\r\n\t\t\tthis._map.openPopup(this._popup);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttogglePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tif (this._popup._isOpen) {\r\n\t\t\t\tthis.closePopup();\r\n\t\t\t} else {\r\n\t\t\t\tthis.openPopup();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tvar anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);\r\n\r\n\t\tanchor = anchor.add(L.Popup.prototype.options.offset);\r\n\r\n\t\tif (options && options.offset) {\r\n\t\t\tanchor = anchor.add(options.offset);\r\n\t\t}\r\n\r\n\t\toptions = L.extend({offset: anchor}, options);\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this.togglePopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this)\r\n\t\t\t    .on('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tL.setOptions(content, options);\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tthis._popup = new L.Popup(options, this)\r\n\t\t\t\t.setContent(content);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetPopupContent: function (content) {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this.togglePopup, this)\r\n\t\t\t    .off('remove', this.closePopup, this)\r\n\t\t\t    .off('move', this._movePopup, this);\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPopup: function () {\r\n\t\treturn this._popup;\r\n\t},\r\n\r\n\t_movePopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LayerGroup is a class to combine several layers into one so that\r\n * you can manipulate the group (e.g. add/remove it) as one layer.\r\n */\r\n\r\nL.LayerGroup = L.Class.extend({\r\n\tinitialize: function (layers) {\r\n\t\tthis._layers = {};\r\n\r\n\t\tvar i, len;\r\n\r\n\t\tif (layers) {\r\n\t\t\tfor (i = 0, len = layers.length; i < len; i++) {\r\n\t\t\t\tthis.addLayer(layers[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tvar id = this.getLayerId(layer);\r\n\r\n\t\tthis._layers[id] = layer;\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.addLayer(layer);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\r\n\r\n\t\tif (this._map && this._layers[id]) {\r\n\t\t\tthis._map.removeLayer(this._layers[id]);\r\n\t\t}\r\n\r\n\t\tdelete this._layers[id];\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\thasLayer: function (layer) {\r\n\t\tif (!layer) { return false; }\r\n\r\n\t\treturn (layer in this._layers || this.getLayerId(layer) in this._layers);\r\n\t},\r\n\r\n\tclearLayers: function () {\r\n\t\tthis.eachLayer(this.removeLayer, this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tinvoke: function (methodName) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1),\r\n\t\t    i, layer;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tlayer = this._layers[i];\r\n\r\n\t\t\tif (layer[methodName]) {\r\n\t\t\t\tlayer[methodName].apply(layer, args);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\t\tthis.eachLayer(map.addLayer, map);\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tthis.eachLayer(map.removeLayer, map);\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\teachLayer: function (method, context) {\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tmethod.call(context, this._layers[i]);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetLayer: function (id) {\r\n\t\treturn this._layers[id];\r\n\t},\r\n\r\n\tgetLayers: function () {\r\n\t\tvar layers = [];\r\n\r\n\t\tfor (var i in this._layers) {\r\n\t\t\tlayers.push(this._layers[i]);\r\n\t\t}\r\n\t\treturn layers;\r\n\t},\r\n\r\n\tsetZIndex: function (zIndex) {\r\n\t\treturn this.invoke('setZIndex', zIndex);\r\n\t},\r\n\r\n\tgetLayerId: function (layer) {\r\n\t\treturn L.stamp(layer);\r\n\t}\r\n});\r\n\r\nL.layerGroup = function (layers) {\r\n\treturn new L.LayerGroup(layers);\r\n};\r\n\n\n/*\r\n * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods\r\n * shared between a group of interactive layers (like vectors or markers).\r\n */\r\n\r\nL.FeatureGroup = L.LayerGroup.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tEVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'\r\n\t},\r\n\r\n\taddLayer: function (layer) {\r\n\t\tif (this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tif ('on' in layer) {\r\n\t\t\tlayer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\t\t}\r\n\r\n\t\tL.LayerGroup.prototype.addLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent && layer.bindPopup) {\r\n\t\t\tlayer.bindPopup(this._popupContent, this._popupOptions);\r\n\t\t}\r\n\r\n\t\treturn this.fire('layeradd', {layer: layer});\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tif (!this.hasLayer(layer)) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\t\tif (layer in this._layers) {\r\n\t\t\tlayer = this._layers[layer];\r\n\t\t}\r\n\r\n\t\tlayer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);\r\n\r\n\t\tL.LayerGroup.prototype.removeLayer.call(this, layer);\r\n\r\n\t\tif (this._popupContent) {\r\n\t\t\tthis.invoke('unbindPopup');\r\n\t\t}\r\n\r\n\t\treturn this.fire('layerremove', {layer: layer});\r\n\t},\r\n\r\n\tbindPopup: function (content, options) {\r\n\t\tthis._popupContent = content;\r\n\t\tthis._popupOptions = options;\r\n\t\treturn this.invoke('bindPopup', content, options);\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\t\t// open popup on the first layer\r\n\t\tfor (var id in this._layers) {\r\n\t\t\tthis._layers[id].openPopup(latlng);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\treturn this.invoke('setStyle', style);\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\treturn this.invoke('bringToFront');\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\treturn this.invoke('bringToBack');\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar bounds = new L.LatLngBounds();\r\n\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tbounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());\r\n\t\t});\r\n\r\n\t\treturn bounds;\r\n\t},\r\n\r\n\t_propagateEvent: function (e) {\r\n\t\te = L.extend({\r\n\t\t\tlayer: e.target,\r\n\t\t\ttarget: this\r\n\t\t}, e);\r\n\t\tthis.fire(e.type, e);\r\n\t}\r\n});\r\n\r\nL.featureGroup = function (layers) {\r\n\treturn new L.FeatureGroup(layers);\r\n};\r\n\n\n/*\r\n * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.\r\n */\r\n\r\nL.Path = L.Class.extend({\r\n\tincludes: [L.Mixin.Events],\r\n\r\n\tstatics: {\r\n\t\t// how much to extend the clip area around the map view\r\n\t\t// (relative to its size, e.g. 0.5 is half the screen in each direction)\r\n\t\t// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)\r\n\t\tCLIP_PADDING: (function () {\r\n\t\t\tvar max = L.Browser.mobile ? 1280 : 2000,\r\n\t\t\t    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;\r\n\t\t\treturn Math.max(0, Math.min(0.5, target));\r\n\t\t})()\r\n\t},\r\n\r\n\toptions: {\r\n\t\tstroke: true,\r\n\t\tcolor: '#0033ff',\r\n\t\tdashArray: null,\r\n\t\tlineCap: null,\r\n\t\tlineJoin: null,\r\n\t\tweight: 5,\r\n\t\topacity: 0.5,\r\n\r\n\t\tfill: false,\r\n\t\tfillColor: null, //same as color by default\r\n\t\tfillOpacity: 0.2,\r\n\r\n\t\tclickable: true\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tif (!this._container) {\r\n\t\t\tthis._initElements();\r\n\t\t\tthis._initEvents();\r\n\t\t}\r\n\r\n\t\tthis.projectLatlngs();\r\n\t\tthis._updatePath();\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._map._pathRoot.appendChild(this._container);\r\n\t\t}\r\n\r\n\t\tthis.fire('add');\r\n\r\n\t\tmap.on({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tmap.addLayer(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap._pathRoot.removeChild(this._container);\r\n\r\n\t\t// Need to fire remove event before we set _map to null as the event hooks might need the object\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\r\n\t\tif (L.Browser.vml) {\r\n\t\t\tthis._container = null;\r\n\t\t\tthis._stroke = null;\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\r\n\t\tmap.off({\r\n\t\t\t'viewreset': this.projectLatlngs,\r\n\t\t\t'moveend': this._updatePath\r\n\t\t}, this);\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\t// do all projection stuff here\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._container) {\r\n\t\t\tthis._updateStyle();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._updatePath();\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_updatePathViewport: function () {\r\n\t\tvar p = L.Path.CLIP_PADDING,\r\n\t\t    size = this.getSize(),\r\n\t\t    panePos = L.DomUtil.getPosition(this._mapPane),\r\n\t\t    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),\r\n\t\t    max = min.add(size.multiplyBy(1 + p * 2)._round());\r\n\r\n\t\tthis._pathViewport = new L.Bounds(min, max);\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Path with SVG-specific rendering code.\r\n */\r\n\r\nL.Path.SVG_NS = 'http://www.w3.org/2000/svg';\r\n\r\nL.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);\r\n\r\nL.Path = L.Path.extend({\r\n\tstatics: {\r\n\t\tSVG: L.Browser.svg\r\n\t},\r\n\r\n\tbringToFront: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container;\r\n\r\n\t\tif (path && root.lastChild !== path) {\r\n\t\t\troot.appendChild(path);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tbringToBack: function () {\r\n\t\tvar root = this._map._pathRoot,\r\n\t\t    path = this._container,\r\n\t\t    first = root.firstChild;\r\n\r\n\t\tif (path && first !== path) {\r\n\t\t\troot.insertBefore(path, first);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\t// form path string here\r\n\t},\r\n\r\n\t_createElement: function (name) {\r\n\t\treturn document.createElementNS(L.Path.SVG_NS, name);\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._initPath();\r\n\t\tthis._initStyle();\r\n\t},\r\n\r\n\t_initPath: function () {\r\n\t\tthis._container = this._createElement('g');\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\r\n\t\tif (this.options.className) {\r\n\t\t\tL.DomUtil.addClass(this._path, this.options.className);\r\n\t\t}\r\n\r\n\t\tthis._container.appendChild(this._path);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke-linejoin', 'round');\r\n\t\t\tthis._path.setAttribute('stroke-linecap', 'round');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill-rule', 'evenodd');\r\n\t\t}\r\n\t\tif (this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', this.options.pointerEvents);\r\n\t\t}\r\n\t\tif (!this.options.clickable && !this.options.pointerEvents) {\r\n\t\t\tthis._path.setAttribute('pointer-events', 'none');\r\n\t\t}\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tif (this.options.stroke) {\r\n\t\t\tthis._path.setAttribute('stroke', this.options.color);\r\n\t\t\tthis._path.setAttribute('stroke-opacity', this.options.opacity);\r\n\t\t\tthis._path.setAttribute('stroke-width', this.options.weight);\r\n\t\t\tif (this.options.dashArray) {\r\n\t\t\t\tthis._path.setAttribute('stroke-dasharray', this.options.dashArray);\r\n\t\t\t} else {\r\n\t\t\t\tthis._path.removeAttribute('stroke-dasharray');\r\n\t\t\t}\r\n\t\t\tif (this.options.lineCap) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linecap', this.options.lineCap);\r\n\t\t\t}\r\n\t\t\tif (this.options.lineJoin) {\r\n\t\t\t\tthis._path.setAttribute('stroke-linejoin', this.options.lineJoin);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('stroke', 'none');\r\n\t\t}\r\n\t\tif (this.options.fill) {\r\n\t\t\tthis._path.setAttribute('fill', this.options.fillColor || this.options.color);\r\n\t\t\tthis._path.setAttribute('fill-opacity', this.options.fillOpacity);\r\n\t\t} else {\r\n\t\t\tthis._path.setAttribute('fill', 'none');\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar str = this.getPathString();\r\n\t\tif (!str) {\r\n\t\t\t// fix webkit empty string parsing bug\r\n\t\t\tstr = 'M0 0';\r\n\t\t}\r\n\t\tthis._path.setAttribute('d', str);\r\n\t},\r\n\r\n\t// TODO remove duplication with L.Map\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\tif (L.Browser.svg || !L.Browser.vml) {\r\n\t\t\t\tL.DomUtil.addClass(this._path, 'leaflet-clickable');\r\n\t\t\t}\r\n\r\n\t\t\tL.DomEvent.on(this._container, 'click', this._onMouseClick, this);\r\n\r\n\t\t\tvar events = ['dblclick', 'mousedown', 'mouseover',\r\n\t\t\t              'mouseout', 'mousemove', 'contextmenu'];\r\n\t\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\t\tL.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseClick: function (e) {\r\n\t\tif (this._map.dragging && this._map.dragging.moved()) { return; }\r\n\r\n\t\tthis._fireMouseEvent(e);\r\n\t},\r\n\r\n\t_fireMouseEvent: function (e) {\r\n\t\tif (!this.hasEventListeners(e.type)) { return; }\r\n\r\n\t\tvar map = this._map,\r\n\t\t    containerPoint = map.mouseEventToContainerPoint(e),\r\n\t\t    layerPoint = map.containerPointToLayerPoint(containerPoint),\r\n\t\t    latlng = map.layerPointToLatLng(layerPoint);\r\n\r\n\t\tthis.fire(e.type, {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tlayerPoint: layerPoint,\r\n\t\t\tcontainerPoint: containerPoint,\r\n\t\t\toriginalEvent: e\r\n\t\t});\r\n\r\n\t\tif (e.type === 'contextmenu') {\r\n\t\t\tL.DomEvent.preventDefault(e);\r\n\t\t}\r\n\t\tif (e.type !== 'mousemove') {\r\n\t\t\tL.DomEvent.stopPropagation(e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include({\r\n\t_initPathRoot: function () {\r\n\t\tif (!this._pathRoot) {\r\n\t\t\tthis._pathRoot = L.Path.prototype._createElement('svg');\r\n\t\t\tthis._panes.overlayPane.appendChild(this._pathRoot);\r\n\r\n\t\t\tif (this.options.zoomAnimation && L.Browser.any3d) {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');\r\n\r\n\t\t\t\tthis.on({\r\n\t\t\t\t\t'zoomanim': this._animatePathZoom,\r\n\t\t\t\t\t'zoomend': this._endPathZoom\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tL.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');\r\n\t\t\t}\r\n\r\n\t\t\tthis.on('moveend', this._updateSvgViewport);\r\n\t\t\tthis._updateSvgViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_animatePathZoom: function (e) {\r\n\t\tvar scale = this.getZoomScale(e.zoom),\r\n\t\t    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);\r\n\r\n\t\tthis._pathRoot.style[L.DomUtil.TRANSFORM] =\r\n\t\t        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';\r\n\r\n\t\tthis._pathZooming = true;\r\n\t},\r\n\r\n\t_endPathZoom: function () {\r\n\t\tthis._pathZooming = false;\r\n\t},\r\n\r\n\t_updateSvgViewport: function () {\r\n\r\n\t\tif (this._pathZooming) {\r\n\t\t\t// Do not update SVGs while a zoom animation is going on otherwise the animation will break.\r\n\t\t\t// When the zoom animation ends we will be updated again anyway\r\n\t\t\t// This fixes the case where you do a momentum move and zoom while the move is still ongoing.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    max = vp.max,\r\n\t\t    width = max.x - min.x,\r\n\t\t    height = max.y - min.y,\r\n\t\t    root = this._pathRoot,\r\n\t\t    pane = this._panes.overlayPane;\r\n\r\n\t\t// Hack to make flicker on drag end on mobile webkit less irritating\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.removeChild(root);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.setAttribute('width', width);\r\n\t\troot.setAttribute('height', height);\r\n\t\troot.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));\r\n\r\n\t\tif (L.Browser.mobileWebkit) {\r\n\t\t\tpane.appendChild(root);\r\n\t\t}\r\n\t}\r\n});\r\n\n\n/*\r\n * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.\r\n */\r\n\r\nL.Path.include({\r\n\r\n\tbindPopup: function (content, options) {\r\n\r\n\t\tif (content instanceof L.Popup) {\r\n\t\t\tthis._popup = content;\r\n\t\t} else {\r\n\t\t\tif (!this._popup || options) {\r\n\t\t\t\tthis._popup = new L.Popup(options, this);\r\n\t\t\t}\r\n\t\t\tthis._popup.setContent(content);\r\n\t\t}\r\n\r\n\t\tif (!this._popupHandlersAdded) {\r\n\t\t\tthis\r\n\t\t\t    .on('click', this._openPopup, this)\r\n\t\t\t    .on('remove', this.closePopup, this);\r\n\r\n\t\t\tthis._popupHandlersAdded = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tunbindPopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup = null;\r\n\t\t\tthis\r\n\t\t\t    .off('click', this._openPopup)\r\n\t\t\t    .off('remove', this.closePopup);\r\n\r\n\t\t\tthis._popupHandlersAdded = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\topenPopup: function (latlng) {\r\n\r\n\t\tif (this._popup) {\r\n\t\t\t// open the popup from one of the path's points if not specified\r\n\t\t\tlatlng = latlng || this._latlng ||\r\n\t\t\t         this._latlngs[Math.floor(this._latlngs.length / 2)];\r\n\r\n\t\t\tthis._openPopup({latlng: latlng});\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclosePopup: function () {\r\n\t\tif (this._popup) {\r\n\t\t\tthis._popup._close();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_openPopup: function (e) {\r\n\t\tthis._popup.setLatLng(e.latlng);\r\n\t\tthis._map.openPopup(this._popup);\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for IE6-8 through VML.\r\n * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!\r\n */\r\n\r\nL.Browser.vml = !L.Browser.svg && (function () {\r\n\ttry {\r\n\t\tvar div = document.createElement('div');\r\n\t\tdiv.innerHTML = '<v:shape adj=\"1\"/>';\r\n\r\n\t\tvar shape = div.firstChild;\r\n\t\tshape.style.behavior = 'url(#default#VML)';\r\n\r\n\t\treturn shape && (typeof shape.adj === 'object');\r\n\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}());\r\n\r\nL.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\tVML: true,\r\n\t\tCLIP_PADDING: 0.02\r\n\t},\r\n\r\n\t_createElement: (function () {\r\n\t\ttry {\r\n\t\t\tdocument.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement('<lvml:' + name + ' class=\"lvml\">');\r\n\t\t\t};\r\n\t\t} catch (e) {\r\n\t\t\treturn function (name) {\r\n\t\t\t\treturn document.createElement(\r\n\t\t\t\t        '<' + name + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\r\n\t\t\t};\r\n\t\t}\r\n\t}()),\r\n\r\n\t_initPath: function () {\r\n\t\tvar container = this._container = this._createElement('shape');\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-vml-shape' +\r\n\t\t\t(this.options.className ? ' ' + this.options.className : ''));\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tL.DomUtil.addClass(container, 'leaflet-clickable');\r\n\t\t}\r\n\r\n\t\tcontainer.coordsize = '1 1';\r\n\r\n\t\tthis._path = this._createElement('path');\r\n\t\tcontainer.appendChild(this._path);\r\n\r\n\t\tthis._map._pathRoot.appendChild(container);\r\n\t},\r\n\r\n\t_initStyle: function () {\r\n\t\tthis._updateStyle();\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar stroke = this._stroke,\r\n\t\t    fill = this._fill,\r\n\t\t    options = this.options,\r\n\t\t    container = this._container;\r\n\r\n\t\tcontainer.stroked = options.stroke;\r\n\t\tcontainer.filled = options.fill;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tif (!stroke) {\r\n\t\t\t\tstroke = this._stroke = this._createElement('stroke');\r\n\t\t\t\tstroke.endcap = 'round';\r\n\t\t\t\tcontainer.appendChild(stroke);\r\n\t\t\t}\r\n\t\t\tstroke.weight = options.weight + 'px';\r\n\t\t\tstroke.color = options.color;\r\n\t\t\tstroke.opacity = options.opacity;\r\n\r\n\t\t\tif (options.dashArray) {\r\n\t\t\t\tstroke.dashStyle = L.Util.isArray(options.dashArray) ?\r\n\t\t\t\t    options.dashArray.join(' ') :\r\n\t\t\t\t    options.dashArray.replace(/( *, *)/g, ' ');\r\n\t\t\t} else {\r\n\t\t\t\tstroke.dashStyle = '';\r\n\t\t\t}\r\n\t\t\tif (options.lineCap) {\r\n\t\t\t\tstroke.endcap = options.lineCap.replace('butt', 'flat');\r\n\t\t\t}\r\n\t\t\tif (options.lineJoin) {\r\n\t\t\t\tstroke.joinstyle = options.lineJoin;\r\n\t\t\t}\r\n\r\n\t\t} else if (stroke) {\r\n\t\t\tcontainer.removeChild(stroke);\r\n\t\t\tthis._stroke = null;\r\n\t\t}\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tif (!fill) {\r\n\t\t\t\tfill = this._fill = this._createElement('fill');\r\n\t\t\t\tcontainer.appendChild(fill);\r\n\t\t\t}\r\n\t\t\tfill.color = options.fillColor || options.color;\r\n\t\t\tfill.opacity = options.fillOpacity;\r\n\r\n\t\t} else if (fill) {\r\n\t\t\tcontainer.removeChild(fill);\r\n\t\t\tthis._fill = null;\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tvar style = this._container.style;\r\n\r\n\t\tstyle.display = 'none';\r\n\t\tthis._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug\r\n\t\tstyle.display = '';\r\n\t}\r\n});\r\n\r\nL.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tif (this._pathRoot) { return; }\r\n\r\n\t\tvar root = this._pathRoot = document.createElement('div');\r\n\t\troot.className = 'leaflet-vml-container';\r\n\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\tthis.on('moveend', this._updatePathViewport);\r\n\t\tthis._updatePathViewport();\r\n\t}\r\n});\r\n\n\n/*\r\n * Vector rendering for all browsers that support canvas.\r\n */\r\n\r\nL.Browser.canvas = (function () {\r\n\treturn !!document.createElement('canvas').getContext;\r\n}());\r\n\r\nL.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({\r\n\tstatics: {\r\n\t\t//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value\r\n\t\tCANVAS: true,\r\n\t\tSVG: false\r\n\t},\r\n\r\n\tredraw: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis.projectLatlngs();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tL.setOptions(this, style);\r\n\r\n\t\tif (this._map) {\r\n\t\t\tthis._updateStyle();\r\n\t\t\tthis._requestUpdate();\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('viewreset', this.projectLatlngs, this)\r\n\t\t    .off('moveend', this._updatePath, this);\r\n\r\n\t\tif (this.options.clickable) {\r\n\t\t\tthis._map.off('click', this._onClick, this);\r\n\t\t\tthis._map.off('mousemove', this._onMouseMove, this);\r\n\t\t}\r\n\r\n\t\tthis._requestUpdate();\r\n\t\t\r\n\t\tthis.fire('remove');\r\n\t\tthis._map = null;\r\n\t},\r\n\r\n\t_requestUpdate: function () {\r\n\t\tif (this._map && !L.Path._updateRequest) {\r\n\t\t\tL.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);\r\n\t\t}\r\n\t},\r\n\r\n\t_fireMapMoveEnd: function () {\r\n\t\tL.Path._updateRequest = null;\r\n\t\tthis.fire('moveend');\r\n\t},\r\n\r\n\t_initElements: function () {\r\n\t\tthis._map._initPathRoot();\r\n\t\tthis._ctx = this._map._canvasCtx;\r\n\t},\r\n\r\n\t_updateStyle: function () {\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tthis._ctx.lineWidth = options.weight;\r\n\t\t\tthis._ctx.strokeStyle = options.color;\r\n\t\t}\r\n\t\tif (options.fill) {\r\n\t\t\tthis._ctx.fillStyle = options.fillColor || options.color;\r\n\t\t}\r\n\t},\r\n\r\n\t_drawPath: function () {\r\n\t\tvar i, j, len, len2, point, drawMethod;\r\n\r\n\t\tthis._ctx.beginPath();\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tfor (j = 0, len2 = this._parts[i].length; j < len2; j++) {\r\n\t\t\t\tpoint = this._parts[i][j];\r\n\t\t\t\tdrawMethod = (j === 0 ? 'move' : 'line') + 'To';\r\n\r\n\t\t\t\tthis._ctx[drawMethod](point.x, point.y);\r\n\t\t\t}\r\n\t\t\t// TODO refactor ugly hack\r\n\t\t\tif (this instanceof L.Polygon) {\r\n\t\t\t\tthis._ctx.closePath();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\treturn !this._parts.length;\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (this._checkIfEmpty()) { return; }\r\n\r\n\t\tvar ctx = this._ctx,\r\n\t\t    options = this.options;\r\n\r\n\t\tthis._drawPath();\r\n\t\tctx.save();\r\n\t\tthis._updateStyle();\r\n\r\n\t\tif (options.fill) {\r\n\t\t\tctx.globalAlpha = options.fillOpacity;\r\n\t\t\tctx.fill();\r\n\t\t}\r\n\r\n\t\tif (options.stroke) {\r\n\t\t\tctx.globalAlpha = options.opacity;\r\n\t\t\tctx.stroke();\r\n\t\t}\r\n\r\n\t\tctx.restore();\r\n\r\n\t\t// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tif (this.options.clickable) {\r\n\t\t\t// TODO dblclick\r\n\t\t\tthis._map.on('mousemove', this._onMouseMove, this);\r\n\t\t\tthis._map.on('click', this._onClick, this);\r\n\t\t}\r\n\t},\r\n\r\n\t_onClick: function (e) {\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis.fire('click', e);\r\n\t\t}\r\n\t},\r\n\r\n\t_onMouseMove: function (e) {\r\n\t\tif (!this._map || this._map._animatingZoom) { return; }\r\n\r\n\t\t// TODO don't do on each move\r\n\t\tif (this._containsPoint(e.layerPoint)) {\r\n\t\t\tthis._ctx.canvas.style.cursor = 'pointer';\r\n\t\t\tthis._mouseInside = true;\r\n\t\t\tthis.fire('mouseover', e);\r\n\r\n\t\t} else if (this._mouseInside) {\r\n\t\t\tthis._ctx.canvas.style.cursor = '';\r\n\t\t\tthis._mouseInside = false;\r\n\t\t\tthis.fire('mouseout', e);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {\r\n\t_initPathRoot: function () {\r\n\t\tvar root = this._pathRoot,\r\n\t\t    ctx;\r\n\r\n\t\tif (!root) {\r\n\t\t\troot = this._pathRoot = document.createElement('canvas');\r\n\t\t\troot.style.position = 'absolute';\r\n\t\t\tctx = this._canvasCtx = root.getContext('2d');\r\n\r\n\t\t\tctx.lineCap = 'round';\r\n\t\t\tctx.lineJoin = 'round';\r\n\r\n\t\t\tthis._panes.overlayPane.appendChild(root);\r\n\r\n\t\t\tif (this.options.zoomAnimation) {\r\n\t\t\t\tthis._pathRoot.className = 'leaflet-zoom-animated';\r\n\t\t\t\tthis.on('zoomanim', this._animatePathZoom);\r\n\t\t\t\tthis.on('zoomend', this._endPathZoom);\r\n\t\t\t}\r\n\t\t\tthis.on('moveend', this._updateCanvasViewport);\r\n\t\t\tthis._updateCanvasViewport();\r\n\t\t}\r\n\t},\r\n\r\n\t_updateCanvasViewport: function () {\r\n\t\t// don't redraw while zooming. See _updateSvgViewport for more details\r\n\t\tif (this._pathZooming) { return; }\r\n\t\tthis._updatePathViewport();\r\n\r\n\t\tvar vp = this._pathViewport,\r\n\t\t    min = vp.min,\r\n\t\t    size = vp.max.subtract(min),\r\n\t\t    root = this._pathRoot;\r\n\r\n\t\t//TODO check if this works properly on mobile webkit\r\n\t\tL.DomUtil.setPosition(root, min);\r\n\t\troot.width = size.x;\r\n\t\troot.height = size.y;\r\n\t\troot.getContext('2d').translate(-min.x, -min.y);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.LineUtil contains different utility functions for line segments\r\n * and polylines (clipping, simplification, distances, etc.)\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations for this file\r\n\r\nL.LineUtil = {\r\n\r\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\r\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\r\n\r\n\tsimplify: function (/*Point[]*/ points, /*Number*/ tolerance) {\r\n\t\tif (!tolerance || !points.length) {\r\n\t\t\treturn points.slice();\r\n\t\t}\r\n\r\n\t\tvar sqTolerance = tolerance * tolerance;\r\n\r\n\t\t// stage 1: vertex reduction\r\n\t\tpoints = this._reducePoints(points, sqTolerance);\r\n\r\n\t\t// stage 2: Douglas-Peucker simplification\r\n\t\tpoints = this._simplifyDP(points, sqTolerance);\r\n\r\n\t\treturn points;\r\n\t},\r\n\r\n\t// distance from a point to a segment between two points\r\n\tpointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));\r\n\t},\r\n\r\n\tclosestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {\r\n\t\treturn this._sqClosestPointOnSegment(p, p1, p2);\r\n\t},\r\n\r\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\r\n\t_simplifyDP: function (points, sqTolerance) {\r\n\r\n\t\tvar len = points.length,\r\n\t\t    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,\r\n\t\t    markers = new ArrayConstructor(len);\r\n\r\n\t\tmarkers[0] = markers[len - 1] = 1;\r\n\r\n\t\tthis._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\r\n\r\n\t\tvar i,\r\n\t\t    newPoints = [];\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (markers[i]) {\r\n\t\t\t\tnewPoints.push(points[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t},\r\n\r\n\t_simplifyDPStep: function (points, markers, sqTolerance, first, last) {\r\n\r\n\t\tvar maxSqDist = 0,\r\n\t\t    index, i, sqDist;\r\n\r\n\t\tfor (i = first + 1; i <= last - 1; i++) {\r\n\t\t\tsqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);\r\n\r\n\t\t\tif (sqDist > maxSqDist) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tmaxSqDist = sqDist;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxSqDist > sqTolerance) {\r\n\t\t\tmarkers[index] = 1;\r\n\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, first, index);\r\n\t\t\tthis._simplifyDPStep(points, markers, sqTolerance, index, last);\r\n\t\t}\r\n\t},\r\n\r\n\t// reduce points that are too close to each other to a single point\r\n\t_reducePoints: function (points, sqTolerance) {\r\n\t\tvar reducedPoints = [points[0]];\r\n\r\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\r\n\t\t\tif (this._sqDist(points[i], points[prev]) > sqTolerance) {\r\n\t\t\t\treducedPoints.push(points[i]);\r\n\t\t\t\tprev = i;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (prev < len - 1) {\r\n\t\t\treducedPoints.push(points[len - 1]);\r\n\t\t}\r\n\t\treturn reducedPoints;\r\n\t},\r\n\r\n\t// Cohen-Sutherland line clipping algorithm.\r\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\r\n\r\n\tclipSegment: function (a, b, bounds, useLastCode) {\r\n\t\tvar codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),\r\n\t\t    codeB = this._getBitCode(b, bounds),\r\n\r\n\t\t    codeOut, p, newCode;\r\n\r\n\t\t// save 2nd code to avoid calculating it on the next segment\r\n\t\tthis._lastCode = codeB;\r\n\r\n\t\twhile (true) {\r\n\t\t\t// if a,b is inside the clip window (trivial accept)\r\n\t\t\tif (!(codeA | codeB)) {\r\n\t\t\t\treturn [a, b];\r\n\t\t\t// if a,b is outside the clip window (trivial reject)\r\n\t\t\t} else if (codeA & codeB) {\r\n\t\t\t\treturn false;\r\n\t\t\t// other cases\r\n\t\t\t} else {\r\n\t\t\t\tcodeOut = codeA || codeB;\r\n\t\t\t\tp = this._getEdgeIntersection(a, b, codeOut, bounds);\r\n\t\t\t\tnewCode = this._getBitCode(p, bounds);\r\n\r\n\t\t\t\tif (codeOut === codeA) {\r\n\t\t\t\t\ta = p;\r\n\t\t\t\t\tcodeA = newCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb = p;\r\n\t\t\t\t\tcodeB = newCode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getEdgeIntersection: function (a, b, code, bounds) {\r\n\t\tvar dx = b.x - a.x,\r\n\t\t    dy = b.y - a.y,\r\n\t\t    min = bounds.min,\r\n\t\t    max = bounds.max;\r\n\r\n\t\tif (code & 8) { // top\r\n\t\t\treturn new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);\r\n\t\t} else if (code & 4) { // bottom\r\n\t\t\treturn new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);\r\n\t\t} else if (code & 2) { // right\r\n\t\t\treturn new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);\r\n\t\t} else if (code & 1) { // left\r\n\t\t\treturn new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);\r\n\t\t}\r\n\t},\r\n\r\n\t_getBitCode: function (/*Point*/ p, bounds) {\r\n\t\tvar code = 0;\r\n\r\n\t\tif (p.x < bounds.min.x) { // left\r\n\t\t\tcode |= 1;\r\n\t\t} else if (p.x > bounds.max.x) { // right\r\n\t\t\tcode |= 2;\r\n\t\t}\r\n\t\tif (p.y < bounds.min.y) { // bottom\r\n\t\t\tcode |= 4;\r\n\t\t} else if (p.y > bounds.max.y) { // top\r\n\t\t\tcode |= 8;\r\n\t\t}\r\n\r\n\t\treturn code;\r\n\t},\r\n\r\n\t// square distance (to avoid unnecessary Math.sqrt calls)\r\n\t_sqDist: function (p1, p2) {\r\n\t\tvar dx = p2.x - p1.x,\r\n\t\t    dy = p2.y - p1.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\t},\r\n\r\n\t// return closest point on segment or distance to that point\r\n\t_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {\r\n\t\tvar x = p1.x,\r\n\t\t    y = p1.y,\r\n\t\t    dx = p2.x - x,\r\n\t\t    dy = p2.y - y,\r\n\t\t    dot = dx * dx + dy * dy,\r\n\t\t    t;\r\n\r\n\t\tif (dot > 0) {\r\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\r\n\r\n\t\t\tif (t > 1) {\r\n\t\t\t\tx = p2.x;\r\n\t\t\t\ty = p2.y;\r\n\t\t\t} else if (t > 0) {\r\n\t\t\t\tx += dx * t;\r\n\t\t\t\ty += dy * t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdx = p.x - x;\r\n\t\tdy = p.y - y;\r\n\r\n\t\treturn sqDist ? dx * dx + dy * dy : new L.Point(x, y);\r\n\t}\r\n};\r\n\n\n/*\r\n * L.Polyline is used to display polylines on a map.\r\n */\r\n\r\nL.Polyline = L.Path.extend({\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t},\r\n\r\n\toptions: {\r\n\t\t// how much to simplify the polyline on each zoom level\r\n\t\t// more = better performance and smoother look, less = more accurate\r\n\t\tsmoothFactor: 1.0,\r\n\t\tnoClip: false\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._originalPoints = [];\r\n\r\n\t\tfor (var i = 0, len = this._latlngs.length; i < len; i++) {\r\n\t\t\tthis._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tfor (var i = 0, len = this._parts.length, str = ''; i < len; i++) {\r\n\t\t\tstr += this._getPathPartStr(this._parts[i]);\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\tgetLatLngs: function () {\r\n\t\treturn this._latlngs;\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tthis._latlngs = this._convertLatLngs(latlngs);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\taddLatLng: function (latlng) {\r\n\t\tthis._latlngs.push(L.latLng(latlng));\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tspliceLatLngs: function () { // (Number index, Number howMany)\r\n\t\tvar removed = [].splice.apply(this._latlngs, arguments);\r\n\t\tthis._convertLatLngs(this._latlngs, true);\r\n\t\tthis.redraw();\r\n\t\treturn removed;\r\n\t},\r\n\r\n\tclosestLayerPoint: function (p) {\r\n\t\tvar minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;\r\n\r\n\t\tfor (var j = 0, jLen = parts.length; j < jLen; j++) {\r\n\t\t\tvar points = parts[j];\r\n\t\t\tfor (var i = 1, len = points.length; i < len; i++) {\r\n\t\t\t\tp1 = points[i - 1];\r\n\t\t\t\tp2 = points[i];\r\n\t\t\t\tvar sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);\r\n\t\t\t\tif (sqDist < minDistance) {\r\n\t\t\t\t\tminDistance = sqDist;\r\n\t\t\t\t\tminPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (minPoint) {\r\n\t\t\tminPoint.distance = Math.sqrt(minDistance);\r\n\t\t}\r\n\t\treturn minPoint;\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\treturn new L.LatLngBounds(this.getLatLngs());\r\n\t},\r\n\r\n\t_convertLatLngs: function (latlngs, overwrite) {\r\n\t\tvar i, len, target = overwrite ? latlngs : [];\r\n\r\n\t\tfor (i = 0, len = latlngs.length; i < len; i++) {\r\n\t\t\tif (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttarget[i] = L.latLng(latlngs[i]);\r\n\t\t}\r\n\t\treturn target;\r\n\t},\r\n\r\n\t_initEvents: function () {\r\n\t\tL.Path.prototype._initEvents.call(this);\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar round = L.Path.VML;\r\n\r\n\t\tfor (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {\r\n\t\t\tp = points[j];\r\n\t\t\tif (round) {\r\n\t\t\t\tp._round();\r\n\t\t\t}\r\n\t\t\tstr += (j ? 'L' : 'M') + p.x + ' ' + p.y;\r\n\t\t}\r\n\t\treturn str;\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    len = points.length,\r\n\t\t    i, k, segment;\r\n\r\n\t\tif (this.options.noClip) {\r\n\t\t\tthis._parts = [points];\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._parts = [];\r\n\r\n\t\tvar parts = this._parts,\r\n\t\t    vp = this._map._pathViewport,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (i = 0, k = 0; i < len - 1; i++) {\r\n\t\t\tsegment = lu.clipSegment(points[i], points[i + 1], vp, i);\r\n\t\t\tif (!segment) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tparts[k] = parts[k] || [];\r\n\t\t\tparts[k].push(segment[0]);\r\n\r\n\t\t\t// if segment goes out of screen, or it's the last one, it's the end of the line part\r\n\t\t\tif ((segment[1] !== points[i + 1]) || (i === len - 2)) {\r\n\t\t\t\tparts[k].push(segment[1]);\r\n\t\t\t\tk++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// simplify each clipped part of the polyline\r\n\t_simplifyPoints: function () {\r\n\t\tvar parts = this._parts,\r\n\t\t    lu = L.LineUtil;\r\n\r\n\t\tfor (var i = 0, len = parts.length; i < len; i++) {\r\n\t\t\tparts[i] = lu.simplify(parts[i], this.options.smoothFactor);\r\n\t\t}\r\n\t},\r\n\r\n\t_updatePath: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tthis._clipPoints();\r\n\t\tthis._simplifyPoints();\r\n\r\n\t\tL.Path.prototype._updatePath.call(this);\r\n\t}\r\n});\r\n\r\nL.polyline = function (latlngs, options) {\r\n\treturn new L.Polyline(latlngs, options);\r\n};\r\n\n\n/*\r\n * L.PolyUtil contains utility functions for polygons (clipping, etc.).\r\n */\r\n\r\n/*jshint bitwise:false */ // allow bitwise operations here\r\n\r\nL.PolyUtil = {};\r\n\r\n/*\r\n * Sutherland-Hodgeman polygon clipping algorithm.\r\n * Used to avoid rendering parts of a polygon that are not currently visible.\r\n */\r\nL.PolyUtil.clipPolygon = function (points, bounds) {\r\n\tvar clippedPoints,\r\n\t    edges = [1, 4, 2, 8],\r\n\t    i, j, k,\r\n\t    a, b,\r\n\t    len, edge, p,\r\n\t    lu = L.LineUtil;\r\n\r\n\tfor (i = 0, len = points.length; i < len; i++) {\r\n\t\tpoints[i]._code = lu._getBitCode(points[i], bounds);\r\n\t}\r\n\r\n\t// for each edge (left, bottom, right, top)\r\n\tfor (k = 0; k < 4; k++) {\r\n\t\tedge = edges[k];\r\n\t\tclippedPoints = [];\r\n\r\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\r\n\t\t\ta = points[i];\r\n\t\t\tb = points[j];\r\n\r\n\t\t\t// if a is inside the clip window\r\n\t\t\tif (!(a._code & edge)) {\r\n\t\t\t\t// if b is outside the clip window (a->b goes out of screen)\r\n\t\t\t\tif (b._code & edge) {\r\n\t\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\t\tclippedPoints.push(p);\r\n\t\t\t\t}\r\n\t\t\t\tclippedPoints.push(a);\r\n\r\n\t\t\t// else if b is inside the clip window (a->b enters the screen)\r\n\t\t\t} else if (!(b._code & edge)) {\r\n\t\t\t\tp = lu._getEdgeIntersection(b, a, edge, bounds);\r\n\t\t\t\tp._code = lu._getBitCode(p, bounds);\r\n\t\t\t\tclippedPoints.push(p);\r\n\t\t\t}\r\n\t\t}\r\n\t\tpoints = clippedPoints;\r\n\t}\r\n\r\n\treturn points;\r\n};\r\n\n\n/*\r\n * L.Polygon is used to display polygons on a map.\r\n */\r\n\r\nL.Polygon = L.Polyline.extend({\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tinitialize: function (latlngs, options) {\r\n\t\tL.Polyline.prototype.initialize.call(this, latlngs, options);\r\n\t\tthis._initWithHoles(latlngs);\r\n\t},\r\n\r\n\t_initWithHoles: function (latlngs) {\r\n\t\tvar i, len, hole;\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._latlngs = this._convertLatLngs(latlngs[0]);\r\n\t\t\tthis._holes = latlngs.slice(1);\r\n\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = this._holes[i] = this._convertLatLngs(this._holes[i]);\r\n\t\t\t\tif (hole[0].equals(hole[hole.length - 1])) {\r\n\t\t\t\t\thole.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// filter out last point if its equal to the first one\r\n\t\tlatlngs = this._latlngs;\r\n\r\n\t\tif (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {\r\n\t\t\tlatlngs.pop();\r\n\t\t}\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tL.Polyline.prototype.projectLatlngs.call(this);\r\n\r\n\t\t// project polygon holes points\r\n\t\t// TODO move this logic to Polyline to get rid of duplication\r\n\t\tthis._holePoints = [];\r\n\r\n\t\tif (!this._holes) { return; }\r\n\r\n\t\tvar i, j, len, len2;\r\n\r\n\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\tthis._holePoints[i] = [];\r\n\r\n\t\t\tfor (j = 0, len2 = this._holes[i].length; j < len2; j++) {\r\n\t\t\t\tthis._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tsetLatLngs: function (latlngs) {\r\n\t\tif (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {\r\n\t\t\tthis._initWithHoles(latlngs);\r\n\t\t\treturn this.redraw();\r\n\t\t} else {\r\n\t\t\treturn L.Polyline.prototype.setLatLngs.call(this, latlngs);\r\n\t\t}\r\n\t},\r\n\r\n\t_clipPoints: function () {\r\n\t\tvar points = this._originalPoints,\r\n\t\t    newParts = [];\r\n\r\n\t\tthis._parts = [points].concat(this._holePoints);\r\n\r\n\t\tif (this.options.noClip) { return; }\r\n\r\n\t\tfor (var i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tvar clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);\r\n\t\t\tif (clipped.length) {\r\n\t\t\t\tnewParts.push(clipped);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._parts = newParts;\r\n\t},\r\n\r\n\t_getPathPartStr: function (points) {\r\n\t\tvar str = L.Polyline.prototype._getPathPartStr.call(this, points);\r\n\t\treturn str + (L.Browser.svg ? 'z' : 'x');\r\n\t}\r\n});\r\n\r\nL.polygon = function (latlngs, options) {\r\n\treturn new L.Polygon(latlngs, options);\r\n};\r\n\n\n/*\r\n * Contains L.MultiPolyline and L.MultiPolygon layers.\r\n */\r\n\r\n(function () {\r\n\tfunction createMulti(Klass) {\r\n\r\n\t\treturn L.FeatureGroup.extend({\r\n\r\n\t\t\tinitialize: function (latlngs, options) {\r\n\t\t\t\tthis._layers = {};\r\n\t\t\t\tthis._options = options;\r\n\t\t\t\tthis.setLatLngs(latlngs);\r\n\t\t\t},\r\n\r\n\t\t\tsetLatLngs: function (latlngs) {\r\n\t\t\t\tvar i = 0,\r\n\t\t\t\t    len = latlngs.length;\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tif (i < len) {\r\n\t\t\t\t\t\tlayer.setLatLngs(latlngs[i++]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeLayer(layer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t\twhile (i < len) {\r\n\t\t\t\t\tthis.addLayer(new Klass(latlngs[i++], this._options));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn this;\r\n\t\t\t},\r\n\r\n\t\t\tgetLatLngs: function () {\r\n\t\t\t\tvar latlngs = [];\r\n\r\n\t\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\t\tlatlngs.push(layer.getLatLngs());\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn latlngs;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tL.MultiPolyline = createMulti(L.Polyline);\r\n\tL.MultiPolygon = createMulti(L.Polygon);\r\n\r\n\tL.multiPolyline = function (latlngs, options) {\r\n\t\treturn new L.MultiPolyline(latlngs, options);\r\n\t};\r\n\r\n\tL.multiPolygon = function (latlngs, options) {\r\n\t\treturn new L.MultiPolygon(latlngs, options);\r\n\t};\r\n}());\r\n\n\n/*\r\n * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.\r\n */\r\n\r\nL.Rectangle = L.Polygon.extend({\r\n\tinitialize: function (latLngBounds, options) {\r\n\t\tL.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);\r\n\t},\r\n\r\n\tsetBounds: function (latLngBounds) {\r\n\t\tthis.setLatLngs(this._boundsToLatLngs(latLngBounds));\r\n\t},\r\n\r\n\t_boundsToLatLngs: function (latLngBounds) {\r\n\t\tlatLngBounds = L.latLngBounds(latLngBounds);\r\n\t\treturn [\r\n\t\t\tlatLngBounds.getSouthWest(),\r\n\t\t\tlatLngBounds.getNorthWest(),\r\n\t\t\tlatLngBounds.getNorthEast(),\r\n\t\t\tlatLngBounds.getSouthEast()\r\n\t\t];\r\n\t}\r\n});\r\n\r\nL.rectangle = function (latLngBounds, options) {\r\n\treturn new L.Rectangle(latLngBounds, options);\r\n};\r\n\n\n/*\r\n * L.Circle is a circle overlay (with a certain radius in meters).\r\n */\r\n\r\nL.Circle = L.Path.extend({\r\n\tinitialize: function (latlng, radius, options) {\r\n\t\tL.Path.prototype.initialize.call(this, options);\r\n\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\tthis._mRadius = radius;\r\n\t},\r\n\r\n\toptions: {\r\n\t\tfill: true\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tthis._latlng = L.latLng(latlng);\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis._mRadius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latlng = this._latlng,\r\n\t\t    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);\r\n\r\n\t\tthis._point = this._map.latLngToLayerPoint(latlng);\r\n\t\tthis._radius = Math.max(this._point.x - pointLeft.x, 1);\r\n\t},\r\n\r\n\tgetBounds: function () {\r\n\t\tvar lngRadius = this._getLngRadius(),\r\n\t\t    latRadius = (this._mRadius / 40075017) * 360,\r\n\t\t    latlng = this._latlng;\r\n\r\n\t\treturn new L.LatLngBounds(\r\n\t\t        [latlng.lat - latRadius, latlng.lng - lngRadius],\r\n\t\t        [latlng.lat + latRadius, latlng.lng + lngRadius]);\r\n\t},\r\n\r\n\tgetLatLng: function () {\r\n\t\treturn this._latlng;\r\n\t},\r\n\r\n\tgetPathString: function () {\r\n\t\tvar p = this._point,\r\n\t\t    r = this._radius;\r\n\r\n\t\tif (this._checkIfEmpty()) {\r\n\t\t\treturn '';\r\n\t\t}\r\n\r\n\t\tif (L.Browser.svg) {\r\n\t\t\treturn 'M' + p.x + ',' + (p.y - r) +\r\n\t\t\t       'A' + r + ',' + r + ',0,1,1,' +\r\n\t\t\t       (p.x - 0.1) + ',' + (p.y - r) + ' z';\r\n\t\t} else {\r\n\t\t\tp._round();\r\n\t\t\tr = Math.round(r);\r\n\t\t\treturn 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);\r\n\t\t}\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._mRadius;\r\n\t},\r\n\r\n\t// TODO Earth hardcoded, move into projection code!\r\n\r\n\t_getLatRadius: function () {\r\n\t\treturn (this._mRadius / 40075017) * 360;\r\n\t},\r\n\r\n\t_getLngRadius: function () {\r\n\t\treturn this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);\r\n\t},\r\n\r\n\t_checkIfEmpty: function () {\r\n\t\tif (!this._map) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tvar vp = this._map._pathViewport,\r\n\t\t    r = this._radius,\r\n\t\t    p = this._point;\r\n\r\n\t\treturn p.x - r > vp.max.x || p.y - r > vp.max.y ||\r\n\t\t       p.x + r < vp.min.x || p.y + r < vp.min.y;\r\n\t}\r\n});\r\n\r\nL.circle = function (latlng, radius, options) {\r\n\treturn new L.Circle(latlng, radius, options);\r\n};\r\n\n\n/*\r\n * L.CircleMarker is a circle overlay with a permanent pixel radius.\r\n */\r\n\r\nL.CircleMarker = L.Circle.extend({\r\n\toptions: {\r\n\t\tradius: 10,\r\n\t\tweight: 2\r\n\t},\r\n\r\n\tinitialize: function (latlng, options) {\r\n\t\tL.Circle.prototype.initialize.call(this, latlng, null, options);\r\n\t\tthis._radius = this.options.radius;\r\n\t},\r\n\r\n\tprojectLatlngs: function () {\r\n\t\tthis._point = this._map.latLngToLayerPoint(this._latlng);\r\n\t},\r\n\r\n\t_updateStyle : function () {\r\n\t\tL.Circle.prototype._updateStyle.call(this);\r\n\t\tthis.setRadius(this.options.radius);\r\n\t},\r\n\r\n\tsetLatLng: function (latlng) {\r\n\t\tL.Circle.prototype.setLatLng.call(this, latlng);\r\n\t\tif (this._popup && this._popup._isOpen) {\r\n\t\t\tthis._popup.setLatLng(latlng);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetRadius: function (radius) {\r\n\t\tthis.options.radius = this._radius = radius;\r\n\t\treturn this.redraw();\r\n\t},\r\n\r\n\tgetRadius: function () {\r\n\t\treturn this._radius;\r\n\t}\r\n});\r\n\r\nL.circleMarker = function (latlng, options) {\r\n\treturn new L.CircleMarker(latlng, options);\r\n};\r\n\n\n/*\r\n * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.\r\n */\r\n\r\nL.Polyline.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p, closed) {\r\n\t\tvar i, j, k, len, len2, dist, part,\r\n\t\t    w = this.options.weight / 2;\r\n\r\n\t\tif (L.Browser.touch) {\r\n\t\t\tw += 10; // polyline click tolerance on touch devices\r\n\t\t}\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tif (!closed && (j === 0)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);\r\n\r\n\t\t\t\tif (dist <= w) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.\r\n */\r\n\r\nL.Polygon.include(!L.Path.CANVAS ? {} : {\r\n\t_containsPoint: function (p) {\r\n\t\tvar inside = false,\r\n\t\t    part, p1, p2,\r\n\t\t    i, j, k,\r\n\t\t    len, len2;\r\n\r\n\t\t// TODO optimization: check if within bounds first\r\n\r\n\t\tif (L.Polyline.prototype._containsPoint.call(this, p, true)) {\r\n\t\t\t// click on polygon border\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// ray casting algorithm for detecting if point is in polygon\r\n\r\n\t\tfor (i = 0, len = this._parts.length; i < len; i++) {\r\n\t\t\tpart = this._parts[i];\r\n\r\n\t\t\tfor (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {\r\n\t\t\t\tp1 = part[j];\r\n\t\t\t\tp2 = part[k];\r\n\r\n\t\t\t\tif (((p1.y > p.y) !== (p2.y > p.y)) &&\r\n\t\t\t\t\t\t(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\r\n\t\t\t\t\tinside = !inside;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn inside;\r\n\t}\r\n});\r\n\n\n/*\r\n * Extends L.Circle with Canvas-specific code.\r\n */\r\n\r\nL.Circle.include(!L.Path.CANVAS ? {} : {\r\n\t_drawPath: function () {\r\n\t\tvar p = this._point;\r\n\t\tthis._ctx.beginPath();\r\n\t\tthis._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);\r\n\t},\r\n\r\n\t_containsPoint: function (p) {\r\n\t\tvar center = this._point,\r\n\t\t    w2 = this.options.stroke ? this.options.weight / 2 : 0;\r\n\r\n\t\treturn (p.distanceTo(center) <= this._radius + w2);\r\n\t}\r\n});\r\n\n\n/*\n * CircleMarker canvas specific drawing parts.\n */\n\nL.CircleMarker.include(!L.Path.CANVAS ? {} : {\n\t_updateStyle: function () {\n\t\tL.Path.prototype._updateStyle.call(this);\n\t}\n});\n\n\n/*\r\n * L.GeoJSON turns any GeoJSON data into a Leaflet layer.\r\n */\r\n\r\nL.GeoJSON = L.FeatureGroup.extend({\r\n\r\n\tinitialize: function (geojson, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\r\n\t\tif (geojson) {\r\n\t\t\tthis.addData(geojson);\r\n\t\t}\r\n\t},\r\n\r\n\taddData: function (geojson) {\r\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\r\n\t\t    i, len, feature;\r\n\r\n\t\tif (features) {\r\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\r\n\t\t\t\t// Only add this if geometry or geometries are set and not null\r\n\t\t\t\tfeature = features[i];\r\n\t\t\t\tif (feature.geometries || feature.geometry || feature.features || feature.coordinates) {\r\n\t\t\t\t\tthis.addData(features[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar options = this.options;\r\n\r\n\t\tif (options.filter && !options.filter(geojson)) { return; }\r\n\r\n\t\tvar layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);\r\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\r\n\r\n\t\tlayer.defaultOptions = layer.options;\r\n\t\tthis.resetStyle(layer);\r\n\r\n\t\tif (options.onEachFeature) {\r\n\t\t\toptions.onEachFeature(geojson, layer);\r\n\t\t}\r\n\r\n\t\treturn this.addLayer(layer);\r\n\t},\r\n\r\n\tresetStyle: function (layer) {\r\n\t\tvar style = this.options.style;\r\n\t\tif (style) {\r\n\t\t\t// reset any custom styles\r\n\t\t\tL.Util.extend(layer.options, layer.defaultOptions);\r\n\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}\r\n\t},\r\n\r\n\tsetStyle: function (style) {\r\n\t\tthis.eachLayer(function (layer) {\r\n\t\t\tthis._setLayerStyle(layer, style);\r\n\t\t}, this);\r\n\t},\r\n\r\n\t_setLayerStyle: function (layer, style) {\r\n\t\tif (typeof style === 'function') {\r\n\t\t\tstyle = style(layer.feature);\r\n\t\t}\r\n\t\tif (layer.setStyle) {\r\n\t\t\tlayer.setStyle(style);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.extend(L.GeoJSON, {\r\n\tgeometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {\r\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\r\n\t\t    coords = geometry.coordinates,\r\n\t\t    layers = [],\r\n\t\t    latlng, latlngs, i, len;\r\n\r\n\t\tcoordsToLatLng = coordsToLatLng || this.coordsToLatLng;\r\n\r\n\t\tswitch (geometry.type) {\r\n\t\tcase 'Point':\r\n\t\t\tlatlng = coordsToLatLng(coords);\r\n\t\t\treturn pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);\r\n\r\n\t\tcase 'MultiPoint':\r\n\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\t\tlatlng = coordsToLatLng(coords[i]);\r\n\t\t\t\tlayers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tcase 'LineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);\r\n\t\t\treturn new L.Polyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'Polygon':\r\n\t\t\tif (coords.length === 2 && !coords[1].length) {\r\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t\t}\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.Polygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiLineString':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolyline(latlngs, vectorOptions);\r\n\r\n\t\tcase 'MultiPolygon':\r\n\t\t\tlatlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);\r\n\t\t\treturn new L.MultiPolygon(latlngs, vectorOptions);\r\n\r\n\t\tcase 'GeometryCollection':\r\n\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\r\n\r\n\t\t\t\tlayers.push(this.geometryToLayer({\r\n\t\t\t\t\tgeometry: geometry.geometries[i],\r\n\t\t\t\t\ttype: 'Feature',\r\n\t\t\t\t\tproperties: geojson.properties\r\n\t\t\t\t}, pointToLayer, coordsToLatLng, vectorOptions));\r\n\t\t\t}\r\n\t\t\treturn new L.FeatureGroup(layers);\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error('Invalid GeoJSON object.');\r\n\t\t}\r\n\t},\r\n\r\n\tcoordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng\r\n\t\treturn new L.LatLng(coords[1], coords[0], coords[2]);\r\n\t},\r\n\r\n\tcoordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array\r\n\t\tvar latlng, i, len,\r\n\t\t    latlngs = [];\r\n\r\n\t\tfor (i = 0, len = coords.length; i < len; i++) {\r\n\t\t\tlatlng = levelsDeep ?\r\n\t\t\t        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :\r\n\t\t\t        (coordsToLatLng || this.coordsToLatLng)(coords[i]);\r\n\r\n\t\t\tlatlngs.push(latlng);\r\n\t\t}\r\n\r\n\t\treturn latlngs;\r\n\t},\r\n\r\n\tlatLngToCoords: function (latlng) {\r\n\t\tvar coords = [latlng.lng, latlng.lat];\r\n\r\n\t\tif (latlng.alt !== undefined) {\r\n\t\t\tcoords.push(latlng.alt);\r\n\t\t}\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tlatLngsToCoords: function (latLngs) {\r\n\t\tvar coords = [];\r\n\r\n\t\tfor (var i = 0, len = latLngs.length; i < len; i++) {\r\n\t\t\tcoords.push(L.GeoJSON.latLngToCoords(latLngs[i]));\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\t},\r\n\r\n\tgetFeature: function (layer, newGeometry) {\r\n\t\treturn layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);\r\n\t},\r\n\r\n\tasFeature: function (geoJSON) {\r\n\t\tif (geoJSON.type === 'Feature') {\r\n\t\t\treturn geoJSON;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttype: 'Feature',\r\n\t\t\tproperties: {},\r\n\t\t\tgeometry: geoJSON\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar PointToGeoJSON = {\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Point',\r\n\t\t\tcoordinates: L.GeoJSON.latLngToCoords(this.getLatLng())\r\n\t\t});\r\n\t}\r\n};\r\n\r\nL.Marker.include(PointToGeoJSON);\r\nL.Circle.include(PointToGeoJSON);\r\nL.CircleMarker.include(PointToGeoJSON);\r\n\r\nL.Polyline.include({\r\n\ttoGeoJSON: function () {\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'LineString',\r\n\t\t\tcoordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())\r\n\t\t});\r\n\t}\r\n});\r\n\r\nL.Polygon.include({\r\n\ttoGeoJSON: function () {\r\n\t\tvar coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],\r\n\t\t    i, len, hole;\r\n\r\n\t\tcoords[0].push(coords[0][0]);\r\n\r\n\t\tif (this._holes) {\r\n\t\t\tfor (i = 0, len = this._holes.length; i < len; i++) {\r\n\t\t\t\thole = L.GeoJSON.latLngsToCoords(this._holes[i]);\r\n\t\t\t\thole.push(hole[0]);\r\n\t\t\t\tcoords.push(hole);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\ttype: 'Polygon',\r\n\t\t\tcoordinates: coords\r\n\t\t});\r\n\t}\r\n});\r\n\r\n(function () {\r\n\tfunction multiToGeoJSON(type) {\r\n\t\treturn function () {\r\n\t\t\tvar coords = [];\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tcoords.push(layer.toGeoJSON().geometry.coordinates);\r\n\t\t\t});\r\n\r\n\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tcoordinates: coords\r\n\t\t\t});\r\n\t\t};\r\n\t}\r\n\r\n\tL.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});\r\n\tL.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});\r\n\r\n\tL.LayerGroup.include({\r\n\t\ttoGeoJSON: function () {\r\n\r\n\t\t\tvar geometry = this.feature && this.feature.geometry,\r\n\t\t\t\tjsons = [],\r\n\t\t\t\tjson;\r\n\r\n\t\t\tif (geometry && geometry.type === 'MultiPoint') {\r\n\t\t\t\treturn multiToGeoJSON('MultiPoint').call(this);\r\n\t\t\t}\r\n\r\n\t\t\tvar isGeometryCollection = geometry && geometry.type === 'GeometryCollection';\r\n\r\n\t\t\tthis.eachLayer(function (layer) {\r\n\t\t\t\tif (layer.toGeoJSON) {\r\n\t\t\t\t\tjson = layer.toGeoJSON();\r\n\t\t\t\t\tjsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tif (isGeometryCollection) {\r\n\t\t\t\treturn L.GeoJSON.getFeature(this, {\r\n\t\t\t\t\tgeometries: jsons,\r\n\t\t\t\t\ttype: 'GeometryCollection'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\ttype: 'FeatureCollection',\r\n\t\t\t\tfeatures: jsons\r\n\t\t\t};\r\n\t\t}\r\n\t});\r\n}());\r\n\r\nL.geoJson = function (geojson, options) {\r\n\treturn new L.GeoJSON(geojson, options);\r\n};\r\n\n\n/*\r\n * L.DomEvent contains functions for working with DOM events.\r\n */\r\n\r\nL.DomEvent = {\r\n\t/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */\r\n\taddListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler, originalHandler, newType;\r\n\r\n\t\tif (obj[key]) { return this; }\r\n\r\n\t\thandler = function (e) {\r\n\t\t\treturn fn.call(context || obj, e || L.DomEvent._getEvent());\r\n\t\t};\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\treturn this.addPointerListener(obj, type, handler, id);\r\n\t\t}\r\n\t\tif (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {\r\n\t\t\tthis.addDoubleTapListener(obj, handler, id);\r\n\t\t}\r\n\r\n\t\tif ('addEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.addEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\tnewType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');\r\n\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\tif (!L.DomEvent._checkMouse(obj, e)) { return; }\r\n\t\t\t\t\treturn originalHandler(e);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(newType, handler, false);\r\n\r\n\t\t\t} else if (type === 'click' && L.Browser.android) {\r\n\t\t\t\toriginalHandler = handler;\r\n\t\t\t\thandler = function (e) {\r\n\t\t\t\t\treturn L.DomEvent._filterClick(e, originalHandler);\r\n\t\t\t\t};\r\n\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.addEventListener(type, handler, false);\r\n\t\t\t}\r\n\r\n\t\t} else if ('attachEvent' in obj) {\r\n\t\t\tobj.attachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = handler;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveListener: function (obj, type, fn) {  // (HTMLElement, String, Function)\r\n\r\n\t\tvar id = L.stamp(fn),\r\n\t\t    key = '_leaflet_' + type + id,\r\n\t\t    handler = obj[key];\r\n\r\n\t\tif (!handler) { return this; }\r\n\r\n\t\tif (L.Browser.pointer && type.indexOf('touch') === 0) {\r\n\t\t\tthis.removePointerListener(obj, type, id);\r\n\t\t} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {\r\n\t\t\tthis.removeDoubleTapListener(obj, id);\r\n\r\n\t\t} else if ('removeEventListener' in obj) {\r\n\r\n\t\t\tif (type === 'mousewheel') {\r\n\t\t\t\tobj.removeEventListener('DOMMouseScroll', handler, false);\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\r\n\t\t\t} else if ((type === 'mouseenter') || (type === 'mouseleave')) {\r\n\t\t\t\tobj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);\r\n\t\t\t} else {\r\n\t\t\t\tobj.removeEventListener(type, handler, false);\r\n\t\t\t}\r\n\t\t} else if ('detachEvent' in obj) {\r\n\t\t\tobj.detachEvent('on' + type, handler);\r\n\t\t}\r\n\r\n\t\tobj[key] = null;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopPropagation: function (e) {\r\n\r\n\t\tif (e.stopPropagation) {\r\n\t\t\te.stopPropagation();\r\n\t\t} else {\r\n\t\t\te.cancelBubble = true;\r\n\t\t}\r\n\t\tL.DomEvent._skipped(e);\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdisableScrollPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'mousewheel', stop)\r\n\t\t\t.on(el, 'MozMousePixelScroll', stop);\r\n\t},\r\n\r\n\tdisableClickPropagation: function (el) {\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(el, L.Draggable.START[i], stop);\r\n\t\t}\r\n\r\n\t\treturn L.DomEvent\r\n\t\t\t.on(el, 'click', L.DomEvent._fakeStop)\r\n\t\t\t.on(el, 'dblclick', stop);\r\n\t},\r\n\r\n\tpreventDefault: function (e) {\r\n\r\n\t\tif (e.preventDefault) {\r\n\t\t\te.preventDefault();\r\n\t\t} else {\r\n\t\t\te.returnValue = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstop: function (e) {\r\n\t\treturn L.DomEvent\r\n\t\t\t.preventDefault(e)\r\n\t\t\t.stopPropagation(e);\r\n\t},\r\n\r\n\tgetMousePosition: function (e, container) {\r\n\t\tif (!container) {\r\n\t\t\treturn new L.Point(e.clientX, e.clientY);\r\n\t\t}\r\n\r\n\t\tvar rect = container.getBoundingClientRect();\r\n\r\n\t\treturn new L.Point(\r\n\t\t\te.clientX - rect.left - container.clientLeft,\r\n\t\t\te.clientY - rect.top - container.clientTop);\r\n\t},\r\n\r\n\tgetWheelDelta: function (e) {\r\n\r\n\t\tvar delta = 0;\r\n\r\n\t\tif (e.wheelDelta) {\r\n\t\t\tdelta = e.wheelDelta / 120;\r\n\t\t}\r\n\t\tif (e.detail) {\r\n\t\t\tdelta = -e.detail / 3;\r\n\t\t}\r\n\t\treturn delta;\r\n\t},\r\n\r\n\t_skipEvents: {},\r\n\r\n\t_fakeStop: function (e) {\r\n\t\t// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)\r\n\t\tL.DomEvent._skipEvents[e.type] = true;\r\n\t},\r\n\r\n\t_skipped: function (e) {\r\n\t\tvar skipped = this._skipEvents[e.type];\r\n\t\t// reset when checking, as it's only used in map container and propagates outside of the map\r\n\t\tthis._skipEvents[e.type] = false;\r\n\t\treturn skipped;\r\n\t},\r\n\r\n\t// check if element really left/entered the event target (for mouseenter/mouseleave)\r\n\t_checkMouse: function (el, e) {\r\n\r\n\t\tvar related = e.relatedTarget;\r\n\r\n\t\tif (!related) { return true; }\r\n\r\n\t\ttry {\r\n\t\t\twhile (related && (related !== el)) {\r\n\t\t\t\trelated = related.parentNode;\r\n\t\t\t}\r\n\t\t} catch (err) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn (related !== el);\r\n\t},\r\n\r\n\t_getEvent: function () { // evil magic for IE\r\n\t\t/*jshint noarg:false */\r\n\t\tvar e = window.event;\r\n\t\tif (!e) {\r\n\t\t\tvar caller = arguments.callee.caller;\r\n\t\t\twhile (caller) {\r\n\t\t\t\te = caller['arguments'][0];\r\n\t\t\t\tif (e && window.Event === e.constructor) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcaller = caller.caller;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn e;\r\n\t},\r\n\r\n\t// this is a horrible workaround for a bug in Android where a single touch triggers two click events\r\n\t_filterClick: function (e, handler) {\r\n\t\tvar timeStamp = (e.timeStamp || e.originalEvent.timeStamp),\r\n\t\t\telapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);\r\n\r\n\t\t// are they closer together than 500ms yet more than 100ms?\r\n\t\t// Android typically triggers them ~300ms apart while multiple listeners\r\n\t\t// on the same event should be triggered far faster;\r\n\t\t// or check if click is simulated on the element, and if it is, reject any non-simulated events\r\n\r\n\t\tif ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {\r\n\t\t\tL.DomEvent.stop(e);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tL.DomEvent._lastClick = timeStamp;\r\n\r\n\t\treturn handler(e);\r\n\t}\r\n};\r\n\r\nL.DomEvent.on = L.DomEvent.addListener;\r\nL.DomEvent.off = L.DomEvent.removeListener;\r\n\n\n/*\r\n * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.\r\n */\r\n\r\nL.Draggable = L.Class.extend({\r\n\tincludes: L.Mixin.Events,\r\n\r\n\tstatics: {\r\n\t\tSTART: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],\r\n\t\tEND: {\r\n\t\t\tmousedown: 'mouseup',\r\n\t\t\ttouchstart: 'touchend',\r\n\t\t\tpointerdown: 'touchend',\r\n\t\t\tMSPointerDown: 'touchend'\r\n\t\t},\r\n\t\tMOVE: {\r\n\t\t\tmousedown: 'mousemove',\r\n\t\t\ttouchstart: 'touchmove',\r\n\t\t\tpointerdown: 'touchmove',\r\n\t\t\tMSPointerDown: 'touchmove'\r\n\t\t}\r\n\t},\r\n\r\n\tinitialize: function (element, dragStartTarget) {\r\n\t\tthis._element = element;\r\n\t\tthis._dragStartTarget = dragStartTarget || element;\r\n\t},\r\n\r\n\tenable: function () {\r\n\t\tif (this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = true;\r\n\t},\r\n\r\n\tdisable: function () {\r\n\t\tif (!this._enabled) { return; }\r\n\r\n\t\tfor (var i = L.Draggable.START.length - 1; i >= 0; i--) {\r\n\t\t\tL.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);\r\n\t\t}\r\n\r\n\t\tthis._enabled = false;\r\n\t\tthis._moved = false;\r\n\t},\r\n\r\n\t_onDown: function (e) {\r\n\t\tthis._moved = false;\r\n\r\n\t\tif (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }\r\n\r\n\t\tL.DomEvent.stopPropagation(e);\r\n\r\n\t\tif (L.Draggable._disabled) { return; }\r\n\r\n\t\tL.DomUtil.disableImageDrag();\r\n\t\tL.DomUtil.disableTextSelection();\r\n\r\n\t\tif (this._moving) { return; }\r\n\r\n\t\tvar first = e.touches ? e.touches[0] : e;\r\n\r\n\t\tthis._startPoint = new L.Point(first.clientX, first.clientY);\r\n\t\tthis._startPos = this._newPos = L.DomUtil.getPosition(this._element);\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)\r\n\t\t    .on(document, L.Draggable.END[e.type], this._onUp, this);\r\n\t},\r\n\r\n\t_onMove: function (e) {\r\n\t\tif (e.touches && e.touches.length > 1) {\r\n\t\t\tthis._moved = true;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),\r\n\t\t    newPoint = new L.Point(first.clientX, first.clientY),\r\n\t\t    offset = newPoint.subtract(this._startPoint);\r\n\r\n\t\tif (!offset.x && !offset.y) { return; }\r\n\t\tif (L.Browser.touch && Math.abs(offset.x) + Math.abs(offset.y) < 3) { return; }\r\n\r\n\t\tL.DomEvent.preventDefault(e);\r\n\r\n\t\tif (!this._moved) {\r\n\t\t\tthis.fire('dragstart');\r\n\r\n\t\t\tthis._moved = true;\r\n\t\t\tthis._startPos = L.DomUtil.getPosition(this._element).subtract(offset);\r\n\r\n\t\t\tL.DomUtil.addClass(document.body, 'leaflet-dragging');\r\n\t\t\tthis._lastTarget = e.target || e.srcElement;\r\n\t\t\tL.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t}\r\n\r\n\t\tthis._newPos = this._startPos.add(offset);\r\n\t\tthis._moving = true;\r\n\r\n\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\t\tthis._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);\r\n\t},\r\n\r\n\t_updatePosition: function () {\r\n\t\tthis.fire('predrag');\r\n\t\tL.DomUtil.setPosition(this._element, this._newPos);\r\n\t\tthis.fire('drag');\r\n\t},\r\n\r\n\t_onUp: function () {\r\n\t\tL.DomUtil.removeClass(document.body, 'leaflet-dragging');\r\n\r\n\t\tif (this._lastTarget) {\r\n\t\t\tL.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');\r\n\t\t\tthis._lastTarget = null;\r\n\t\t}\r\n\r\n\t\tfor (var i in L.Draggable.MOVE) {\r\n\t\t\tL.DomEvent\r\n\t\t\t    .off(document, L.Draggable.MOVE[i], this._onMove)\r\n\t\t\t    .off(document, L.Draggable.END[i], this._onUp);\r\n\t\t}\r\n\r\n\t\tL.DomUtil.enableImageDrag();\r\n\t\tL.DomUtil.enableTextSelection();\r\n\r\n\t\tif (this._moved && this._moving) {\r\n\t\t\t// ensure drag is not fired after dragend\r\n\t\t\tL.Util.cancelAnimFrame(this._animRequest);\r\n\r\n\t\t\tthis.fire('dragend', {\r\n\t\t\t\tdistance: this._newPos.distanceTo(this._startPos)\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis._moving = false;\r\n\t}\r\n});\r\n\n\n/*\n\tL.Handler is a base class for handler classes that are used internally to inject\n\tinteraction features like dragging to classes like Map and Marker.\n*/\n\nL.Handler = L.Class.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t},\n\n\tenable: function () {\n\t\tif (this._enabled) { return; }\n\n\t\tthis._enabled = true;\n\t\tthis.addHooks();\n\t},\n\n\tdisable: function () {\n\t\tif (!this._enabled) { return; }\n\n\t\tthis._enabled = false;\n\t\tthis.removeHooks();\n\t},\n\n\tenabled: function () {\n\t\treturn !!this._enabled;\n\t}\n});\n\n\n/*\n * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdragging: true,\n\n\tinertia: !L.Browser.android23,\n\tinertiaDeceleration: 3400, // px/s^2\n\tinertiaMaxSpeed: Infinity, // px/s\n\tinertiaThreshold: L.Browser.touch ? 32 : 18, // ms\n\teaseLinearity: 0.25,\n\n\t// TODO refactor, move to CRS\n\tworldCopyJump: false\n});\n\nL.Map.Drag = L.Handler.extend({\n\taddHooks: function () {\n\t\tif (!this._draggable) {\n\t\t\tvar map = this._map;\n\n\t\t\tthis._draggable = new L.Draggable(map._mapPane, map._container);\n\n\t\t\tthis._draggable.on({\n\t\t\t\t'dragstart': this._onDragStart,\n\t\t\t\t'drag': this._onDrag,\n\t\t\t\t'dragend': this._onDragEnd\n\t\t\t}, this);\n\n\t\t\tif (map.options.worldCopyJump) {\n\t\t\t\tthis._draggable.on('predrag', this._onPreDrag, this);\n\t\t\t\tmap.on('viewreset', this._onViewReset, this);\n\n\t\t\t\tmap.whenReady(this._onViewReset, this);\n\t\t\t}\n\t\t}\n\t\tthis._draggable.enable();\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable.disable();\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tvar map = this._map;\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tmap\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\n\t\tif (map.options.inertia) {\n\t\t\tthis._positions = [];\n\t\t\tthis._times = [];\n\t\t}\n\t},\n\n\t_onDrag: function () {\n\t\tif (this._map.options.inertia) {\n\t\t\tvar time = this._lastTime = +new Date(),\n\t\t\t    pos = this._lastPos = this._draggable._newPos;\n\n\t\t\tthis._positions.push(pos);\n\t\t\tthis._times.push(time);\n\n\t\t\tif (time - this._times[0] > 200) {\n\t\t\t\tthis._positions.shift();\n\t\t\t\tthis._times.shift();\n\t\t\t}\n\t\t}\n\n\t\tthis._map\n\t\t    .fire('move')\n\t\t    .fire('drag');\n\t},\n\n\t_onViewReset: function () {\n\t\t// TODO fix hardcoded Earth values\n\t\tvar pxCenter = this._map.getSize()._divideBy(2),\n\t\t    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);\n\n\t\tthis._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;\n\t\tthis._worldWidth = this._map.project([0, 180]).x;\n\t},\n\n\t_onPreDrag: function () {\n\t\t// TODO refactor to be able to adjust map pane position after zoom\n\t\tvar worldWidth = this._worldWidth,\n\t\t    halfWidth = Math.round(worldWidth / 2),\n\t\t    dx = this._initialWorldOffset,\n\t\t    x = this._draggable._newPos.x,\n\t\t    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,\n\t\t    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,\n\t\t    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;\n\n\t\tthis._draggable._newPos.x = newX;\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tvar map = this._map,\n\t\t    options = map.options,\n\t\t    delay = +new Date() - this._lastTime,\n\n\t\t    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];\n\n\t\tmap.fire('dragend', e);\n\n\t\tif (noInertia) {\n\t\t\tmap.fire('moveend');\n\n\t\t} else {\n\n\t\t\tvar direction = this._lastPos.subtract(this._positions[0]),\n\t\t\t    duration = (this._lastTime + delay - this._times[0]) / 1000,\n\t\t\t    ease = options.easeLinearity,\n\n\t\t\t    speedVector = direction.multiplyBy(ease / duration),\n\t\t\t    speed = speedVector.distanceTo([0, 0]),\n\n\t\t\t    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),\n\t\t\t    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),\n\n\t\t\t    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),\n\t\t\t    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();\n\n\t\t\tif (!offset.x || !offset.y) {\n\t\t\t\tmap.fire('moveend');\n\n\t\t\t} else {\n\t\t\t\toffset = map._limitOffset(offset, map.options.maxBounds);\n\n\t\t\t\tL.Util.requestAnimFrame(function () {\n\t\t\t\t\tmap.panBy(offset, {\n\t\t\t\t\t\tduration: decelerationDuration,\n\t\t\t\t\t\teaseLinearity: ease,\n\t\t\t\t\t\tnoMoveStart: true\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);\n\n\n/*\n * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tdoubleClickZoom: true\n});\n\nL.Map.DoubleClickZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tthis._map.on('dblclick', this._onDoubleClick, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._map.off('dblclick', this._onDoubleClick, this);\n\t},\n\n\t_onDoubleClick: function (e) {\n\t\tvar map = this._map,\n\t\t    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);\n\n\t\tif (map.options.doubleClickZoom === 'center') {\n\t\t\tmap.setZoom(zoom);\n\t\t} else {\n\t\t\tmap.setZoomAround(e.containerPoint, zoom);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);\n\n\n/*\n * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.\n */\n\nL.Map.mergeOptions({\n\tscrollWheelZoom: true\n});\n\nL.Map.ScrollWheelZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);\n\t\tL.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t\tthis._delta = 0;\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);\n\t\tL.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);\n\t},\n\n\t_onWheelScroll: function (e) {\n\t\tvar delta = L.DomEvent.getWheelDelta(e);\n\n\t\tthis._delta += delta;\n\t\tthis._lastMousePos = this._map.mouseEventToContainerPoint(e);\n\n\t\tif (!this._startTime) {\n\t\t\tthis._startTime = +new Date();\n\t\t}\n\n\t\tvar left = Math.max(40 - (+new Date() - this._startTime), 0);\n\n\t\tclearTimeout(this._timer);\n\t\tthis._timer = setTimeout(L.bind(this._performZoom, this), left);\n\n\t\tL.DomEvent.preventDefault(e);\n\t\tL.DomEvent.stopPropagation(e);\n\t},\n\n\t_performZoom: function () {\n\t\tvar map = this._map,\n\t\t    delta = this._delta,\n\t\t    zoom = map.getZoom();\n\n\t\tdelta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\t\tdelta = Math.max(Math.min(delta, 4), -4);\n\t\tdelta = map._limitZoom(zoom + delta) - zoom;\n\n\t\tthis._delta = 0;\n\t\tthis._startTime = null;\n\n\t\tif (!delta) { return; }\n\n\t\tif (map.options.scrollWheelZoom === 'center') {\n\t\t\tmap.setZoom(zoom + delta);\n\t\t} else {\n\t\t\tmap.setZoomAround(this._lastMousePos, zoom + delta);\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);\n\n\n/*\r\n * Extends the event handling code with double tap support for mobile browsers.\r\n */\r\n\r\nL.extend(L.DomEvent, {\r\n\r\n\t_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',\r\n\t_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',\r\n\r\n\t// inspired by Zepto touch code by Thomas Fuchs\r\n\taddDoubleTapListener: function (obj, handler, id) {\r\n\t\tvar last,\r\n\t\t    doubleTap = false,\r\n\t\t    delay = 250,\r\n\t\t    touch,\r\n\t\t    pre = '_leaflet_',\r\n\t\t    touchstart = this._touchstart,\r\n\t\t    touchend = this._touchend,\r\n\t\t    trackedTouches = [];\r\n\r\n\t\tfunction onTouchStart(e) {\r\n\t\t\tvar count;\r\n\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\ttrackedTouches.push(e.pointerId);\r\n\t\t\t\tcount = trackedTouches.length;\r\n\t\t\t} else {\r\n\t\t\t\tcount = e.touches.length;\r\n\t\t\t}\r\n\t\t\tif (count > 1) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar now = Date.now(),\r\n\t\t\t\tdelta = now - (last || now);\r\n\r\n\t\t\ttouch = e.touches ? e.touches[0] : e;\r\n\t\t\tdoubleTap = (delta > 0 && delta <= delay);\r\n\t\t\tlast = now;\r\n\t\t}\r\n\r\n\t\tfunction onTouchEnd(e) {\r\n\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\tvar idx = trackedTouches.indexOf(e.pointerId);\r\n\t\t\t\tif (idx === -1) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\ttrackedTouches.splice(idx, 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (doubleTap) {\r\n\t\t\t\tif (L.Browser.pointer) {\r\n\t\t\t\t\t// work around .type being readonly with MSPointer* events\r\n\t\t\t\t\tvar newTouch = { },\r\n\t\t\t\t\t\tprop;\r\n\r\n\t\t\t\t\t// jshint forin:false\r\n\t\t\t\t\tfor (var i in touch) {\r\n\t\t\t\t\t\tprop = touch[i];\r\n\t\t\t\t\t\tif (typeof prop === 'function') {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop.bind(touch);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tnewTouch[i] = prop;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttouch = newTouch;\r\n\t\t\t\t}\r\n\t\t\t\ttouch.type = 'dblclick';\r\n\t\t\t\thandler(touch);\r\n\t\t\t\tlast = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tobj[pre + touchstart + id] = onTouchStart;\r\n\t\tobj[pre + touchend + id] = onTouchEnd;\r\n\r\n\t\t// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen\r\n\t\t// will not come through to us, so we will lose track of how many touches are ongoing\r\n\t\tvar endElement = L.Browser.pointer ? document.documentElement : obj;\r\n\r\n\t\tobj.addEventListener(touchstart, onTouchStart, false);\r\n\t\tendElement.addEventListener(touchend, onTouchEnd, false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tendElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveDoubleTapListener: function (obj, id) {\r\n\t\tvar pre = '_leaflet_';\r\n\r\n\t\tobj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);\r\n\t\t(L.Browser.pointer ? document.documentElement : obj).removeEventListener(\r\n\t\t        this._touchend, obj[pre + this._touchend + id], false);\r\n\r\n\t\tif (L.Browser.pointer) {\r\n\t\t\tdocument.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],\r\n\t\t\t\tfalse);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n});\r\n\n\n/*\n * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.\n */\n\nL.extend(L.DomEvent, {\n\n\t//static\n\tPOINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',\n\tPOINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',\n\tPOINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',\n\tPOINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',\n\n\t_pointers: [],\n\t_pointerDocumentListener: false,\n\n\t// Provides a touch events wrapper for (ms)pointer events.\n\t// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019\n\t//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890\n\n\taddPointerListener: function (obj, type, handler, id) {\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\treturn this.addPointerListenerStart(obj, type, handler, id);\n\t\tcase 'touchend':\n\t\t\treturn this.addPointerListenerEnd(obj, type, handler, id);\n\t\tcase 'touchmove':\n\t\t\treturn this.addPointerListenerMove(obj, type, handler, id);\n\t\tdefault:\n\t\t\tthrow 'Unknown touch event type';\n\t\t}\n\t},\n\n\taddPointerListenerStart: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    pointers = this._pointers;\n\n\t\tvar cb = function (e) {\n\n\t\t\tL.DomEvent.preventDefault(e);\n\n\t\t\tvar alreadyInArray = false;\n\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\talreadyInArray = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!alreadyInArray) {\n\t\t\t\tpointers.push(e);\n\t\t\t}\n\n\t\t\te.touches = pointers.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchstart' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_DOWN, cb, false);\n\n\t\t// need to also listen for end events to keep the _pointers list accurate\n\t\t// this needs to be on the body and never go away\n\t\tif (!this._pointerDocumentListener) {\n\t\t\tvar internalCb = function (e) {\n\t\t\t\tfor (var i = 0; i < pointers.length; i++) {\n\t\t\t\t\tif (pointers[i].pointerId === e.pointerId) {\n\t\t\t\t\t\tpointers.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\t//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_UP, internalCb, false);\n\t\t\tdocument.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);\n\n\t\t\tthis._pointerDocumentListener = true;\n\t\t}\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerMove: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tfunction cb(e) {\n\n\t\t\t// don't fire touch moves when mouse isn't down\n\t\t\tif ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }\n\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches[i] = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t}\n\n\t\tobj[pre + 'touchmove' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_MOVE, cb, false);\n\n\t\treturn this;\n\t},\n\n\taddPointerListenerEnd: function (obj, type, handler, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    touches = this._pointers;\n\n\t\tvar cb = function (e) {\n\t\t\tfor (var i = 0; i < touches.length; i++) {\n\t\t\t\tif (touches[i].pointerId === e.pointerId) {\n\t\t\t\t\ttouches.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\te.touches = touches.slice();\n\t\t\te.changedTouches = [e];\n\n\t\t\thandler(e);\n\t\t};\n\n\t\tobj[pre + 'touchend' + id] = cb;\n\t\tobj.addEventListener(this.POINTER_UP, cb, false);\n\t\tobj.addEventListener(this.POINTER_CANCEL, cb, false);\n\n\t\treturn this;\n\t},\n\n\tremovePointerListener: function (obj, type, id) {\n\t\tvar pre = '_leaflet_',\n\t\t    cb = obj[pre + type + id];\n\n\t\tswitch (type) {\n\t\tcase 'touchstart':\n\t\t\tobj.removeEventListener(this.POINTER_DOWN, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchmove':\n\t\t\tobj.removeEventListener(this.POINTER_MOVE, cb, false);\n\t\t\tbreak;\n\t\tcase 'touchend':\n\t\t\tobj.removeEventListener(this.POINTER_UP, cb, false);\n\t\t\tobj.removeEventListener(this.POINTER_CANCEL, cb, false);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\n\n/*\n * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.\n */\n\nL.Map.mergeOptions({\n\ttouchZoom: L.Browser.touch && !L.Browser.android23,\n\tbounceAtZoomLimits: true\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n\t},\n\n\t_onTouchStart: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]),\n\t\t    viewCenter = map._getCenterLayerPoint();\n\n\t\tthis._startCenter = p1.add(p2)._divideBy(2);\n\t\tthis._startDist = p1.distanceTo(p2);\n\n\t\tthis._moved = false;\n\t\tthis._zooming = true;\n\n\t\tthis._centerOffset = viewCenter.subtract(this._startCenter);\n\n\t\tif (map._panAnim) {\n\t\t\tmap._panAnim.stop();\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(document, 'touchmove', this._onTouchMove, this)\n\t\t    .on(document, 'touchend', this._onTouchEnd, this);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_onTouchMove: function (e) {\n\t\tvar map = this._map;\n\n\t\tif (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }\n\n\t\tvar p1 = map.mouseEventToLayerPoint(e.touches[0]),\n\t\t    p2 = map.mouseEventToLayerPoint(e.touches[1]);\n\n\t\tthis._scale = p1.distanceTo(p2) / this._startDist;\n\t\tthis._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);\n\n\t\tif (this._scale === 1) { return; }\n\n\t\tif (!map.options.bounceAtZoomLimits) {\n\t\t\tif ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||\n\t\t\t    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }\n\t\t}\n\n\t\tif (!this._moved) {\n\t\t\tL.DomUtil.addClass(map._mapPane, 'leaflet-touching');\n\n\t\t\tmap\n\t\t\t    .fire('movestart')\n\t\t\t    .fire('zoomstart');\n\n\t\t\tthis._moved = true;\n\t\t}\n\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\t\tthis._animRequest = L.Util.requestAnimFrame(\n\t\t        this._updateOnMove, this, true, this._map._container);\n\n\t\tL.DomEvent.preventDefault(e);\n\t},\n\n\t_updateOnMove: function () {\n\t\tvar map = this._map,\n\t\t    origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\t\t    zoom = map.getScaleZoom(this._scale);\n\n\t\tmap._animateZoom(center, zoom, this._startCenter, this._scale, this._delta, false, true);\n\t},\n\n\t_onTouchEnd: function () {\n\t\tif (!this._moved || !this._zooming) {\n\t\t\tthis._zooming = false;\n\t\t\treturn;\n\t\t}\n\n\t\tvar map = this._map;\n\n\t\tthis._zooming = false;\n\t\tL.DomUtil.removeClass(map._mapPane, 'leaflet-touching');\n\t\tL.Util.cancelAnimFrame(this._animRequest);\n\n\t\tL.DomEvent\n\t\t    .off(document, 'touchmove', this._onTouchMove)\n\t\t    .off(document, 'touchend', this._onTouchEnd);\n\n\t\tvar origin = this._getScaleOrigin(),\n\t\t    center = map.layerPointToLatLng(origin),\n\n\t\t    oldZoom = map.getZoom(),\n\t\t    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,\n\t\t    roundZoomDelta = (floatZoomDelta > 0 ?\n\t\t            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),\n\n\t\t    zoom = map._limitZoom(oldZoom + roundZoomDelta),\n\t\t    scale = map.getZoomScale(zoom) / this._scale;\n\n\t\tmap._animateZoom(center, zoom, origin, scale);\n\t},\n\n\t_getScaleOrigin: function () {\n\t\tvar centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);\n\t\treturn this._startCenter.add(centerOffset);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n\n\n/*\n * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.\n */\n\nL.Map.mergeOptions({\n\ttap: true,\n\ttapTolerance: 15\n});\n\nL.Map.Tap = L.Handler.extend({\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);\n\t},\n\n\t_onDown: function (e) {\n\t\tif (!e.touches) { return; }\n\n\t\tL.DomEvent.preventDefault(e);\n\n\t\tthis._fireClick = true;\n\n\t\t// don't simulate click or track longpress if more than 1 touch\n\t\tif (e.touches.length > 1) {\n\t\t\tthis._fireClick = false;\n\t\t\tclearTimeout(this._holdTimeout);\n\t\t\treturn;\n\t\t}\n\n\t\tvar first = e.touches[0],\n\t\t    el = first.target;\n\n\t\tthis._startPos = this._newPos = new L.Point(first.clientX, first.clientY);\n\n\t\t// if touching a link, highlight it\n\t\tif (el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\tL.DomUtil.addClass(el, 'leaflet-active');\n\t\t}\n\n\t\t// simulate long hold but setting a timeout\n\t\tthis._holdTimeout = setTimeout(L.bind(function () {\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._fireClick = false;\n\t\t\t\tthis._onUp();\n\t\t\t\tthis._simulateEvent('contextmenu', first);\n\t\t\t}\n\t\t}, this), 1000);\n\n\t\tL.DomEvent\n\t\t\t.on(document, 'touchmove', this._onMove, this)\n\t\t\t.on(document, 'touchend', this._onUp, this);\n\t},\n\n\t_onUp: function (e) {\n\t\tclearTimeout(this._holdTimeout);\n\n\t\tL.DomEvent\n\t\t\t.off(document, 'touchmove', this._onMove, this)\n\t\t\t.off(document, 'touchend', this._onUp, this);\n\n\t\tif (this._fireClick && e && e.changedTouches) {\n\n\t\t\tvar first = e.changedTouches[0],\n\t\t\t    el = first.target;\n\n\t\t\tif (el && el.tagName && el.tagName.toLowerCase() === 'a') {\n\t\t\t\tL.DomUtil.removeClass(el, 'leaflet-active');\n\t\t\t}\n\n\t\t\t// simulate click if the touch didn't move too much\n\t\t\tif (this._isTapValid()) {\n\t\t\t\tthis._simulateEvent('click', first);\n\t\t\t}\n\t\t}\n\t},\n\n\t_isTapValid: function () {\n\t\treturn this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n\t},\n\n\t_onMove: function (e) {\n\t\tvar first = e.touches[0];\n\t\tthis._newPos = new L.Point(first.clientX, first.clientY);\n\t},\n\n\t_simulateEvent: function (type, e) {\n\t\tvar simulatedEvent = document.createEvent('MouseEvents');\n\n\t\tsimulatedEvent._simulated = true;\n\t\te.target._simulatedClick = true;\n\n\t\tsimulatedEvent.initMouseEvent(\n\t\t        type, true, true, window, 1,\n\t\t        e.screenX, e.screenY,\n\t\t        e.clientX, e.clientY,\n\t\t        false, false, false, false, 0, null);\n\n\t\te.target.dispatchEvent(simulatedEvent);\n\t}\n});\n\nif (L.Browser.touch && !L.Browser.pointer) {\n\tL.Map.addInitHook('addHandler', 'tap', L.Map.Tap);\n}\n\n\n/*\n * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map\n  * (zoom to a selected bounding box), enabled by default.\n */\n\nL.Map.mergeOptions({\n\tboxZoom: true\n});\n\nL.Map.BoxZoom = L.Handler.extend({\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\t\tthis._container = map._container;\n\t\tthis._pane = map._panes.overlayPane;\n\t\tthis._moved = false;\n\t},\n\n\taddHooks: function () {\n\t\tL.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tL.DomEvent.off(this._container, 'mousedown', this._onMouseDown);\n\t\tthis._moved = false;\n\t},\n\n\tmoved: function () {\n\t\treturn this._moved;\n\t},\n\n\t_onMouseDown: function (e) {\n\t\tthis._moved = false;\n\n\t\tif (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }\n\n\t\tL.DomUtil.disableTextSelection();\n\t\tL.DomUtil.disableImageDrag();\n\n\t\tthis._startLayerPoint = this._map.mouseEventToLayerPoint(e);\n\n\t\tL.DomEvent\n\t\t    .on(document, 'mousemove', this._onMouseMove, this)\n\t\t    .on(document, 'mouseup', this._onMouseUp, this)\n\t\t    .on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onMouseMove: function (e) {\n\t\tif (!this._moved) {\n\t\t\tthis._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);\n\t\t\tL.DomUtil.setPosition(this._box, this._startLayerPoint);\n\n\t\t\t//TODO refactor: move cursor to styles\n\t\t\tthis._container.style.cursor = 'crosshair';\n\t\t\tthis._map.fire('boxzoomstart');\n\t\t}\n\n\t\tvar startPoint = this._startLayerPoint,\n\t\t    box = this._box,\n\n\t\t    layerPoint = this._map.mouseEventToLayerPoint(e),\n\t\t    offset = layerPoint.subtract(startPoint),\n\n\t\t    newPos = new L.Point(\n\t\t        Math.min(layerPoint.x, startPoint.x),\n\t\t        Math.min(layerPoint.y, startPoint.y));\n\n\t\tL.DomUtil.setPosition(box, newPos);\n\n\t\tthis._moved = true;\n\n\t\t// TODO refactor: remove hardcoded 4 pixels\n\t\tbox.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';\n\t\tbox.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';\n\t},\n\n\t_finish: function () {\n\t\tif (this._moved) {\n\t\t\tthis._pane.removeChild(this._box);\n\t\t\tthis._container.style.cursor = '';\n\t\t}\n\n\t\tL.DomUtil.enableTextSelection();\n\t\tL.DomUtil.enableImageDrag();\n\n\t\tL.DomEvent\n\t\t    .off(document, 'mousemove', this._onMouseMove)\n\t\t    .off(document, 'mouseup', this._onMouseUp)\n\t\t    .off(document, 'keydown', this._onKeyDown);\n\t},\n\n\t_onMouseUp: function (e) {\n\n\t\tthis._finish();\n\n\t\tvar map = this._map,\n\t\t    layerPoint = map.mouseEventToLayerPoint(e);\n\n\t\tif (this._startLayerPoint.equals(layerPoint)) { return; }\n\n\t\tvar bounds = new L.LatLngBounds(\n\t\t        map.layerPointToLatLng(this._startLayerPoint),\n\t\t        map.layerPointToLatLng(layerPoint));\n\n\t\tmap.fitBounds(bounds);\n\n\t\tmap.fire('boxzoomend', {\n\t\t\tboxZoomBounds: bounds\n\t\t});\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tif (e.keyCode === 27) {\n\t\t\tthis._finish();\n\t\t}\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);\n\n\n/*\n * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.\n */\n\nL.Map.mergeOptions({\n\tkeyboard: true,\n\tkeyboardPanOffset: 80,\n\tkeyboardZoomOffset: 1\n});\n\nL.Map.Keyboard = L.Handler.extend({\n\n\tkeyCodes: {\n\t\tleft:    [37],\n\t\tright:   [39],\n\t\tdown:    [40],\n\t\tup:      [38],\n\t\tzoomIn:  [187, 107, 61, 171],\n\t\tzoomOut: [189, 109, 173]\n\t},\n\n\tinitialize: function (map) {\n\t\tthis._map = map;\n\n\t\tthis._setPanOffset(map.options.keyboardPanOffset);\n\t\tthis._setZoomOffset(map.options.keyboardZoomOffset);\n\t},\n\n\taddHooks: function () {\n\t\tvar container = this._map._container;\n\n\t\t// make the container focusable by tabbing\n\t\tif (container.tabIndex === -1) {\n\t\t\tcontainer.tabIndex = '0';\n\t\t}\n\n\t\tL.DomEvent\n\t\t    .on(container, 'focus', this._onFocus, this)\n\t\t    .on(container, 'blur', this._onBlur, this)\n\t\t    .on(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .on('focus', this._addHooks, this)\n\t\t    .on('blur', this._removeHooks, this);\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._removeHooks();\n\n\t\tvar container = this._map._container;\n\n\t\tL.DomEvent\n\t\t    .off(container, 'focus', this._onFocus, this)\n\t\t    .off(container, 'blur', this._onBlur, this)\n\t\t    .off(container, 'mousedown', this._onMouseDown, this);\n\n\t\tthis._map\n\t\t    .off('focus', this._addHooks, this)\n\t\t    .off('blur', this._removeHooks, this);\n\t},\n\n\t_onMouseDown: function () {\n\t\tif (this._focused) { return; }\n\n\t\tvar body = document.body,\n\t\t    docEl = document.documentElement,\n\t\t    top = body.scrollTop || docEl.scrollTop,\n\t\t    left = body.scrollLeft || docEl.scrollLeft;\n\n\t\tthis._map._container.focus();\n\n\t\twindow.scrollTo(left, top);\n\t},\n\n\t_onFocus: function () {\n\t\tthis._focused = true;\n\t\tthis._map.fire('focus');\n\t},\n\n\t_onBlur: function () {\n\t\tthis._focused = false;\n\t\tthis._map.fire('blur');\n\t},\n\n\t_setPanOffset: function (pan) {\n\t\tvar keys = this._panKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.left.length; i < len; i++) {\n\t\t\tkeys[codes.left[i]] = [-1 * pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.right.length; i < len; i++) {\n\t\t\tkeys[codes.right[i]] = [pan, 0];\n\t\t}\n\t\tfor (i = 0, len = codes.down.length; i < len; i++) {\n\t\t\tkeys[codes.down[i]] = [0, pan];\n\t\t}\n\t\tfor (i = 0, len = codes.up.length; i < len; i++) {\n\t\t\tkeys[codes.up[i]] = [0, -1 * pan];\n\t\t}\n\t},\n\n\t_setZoomOffset: function (zoom) {\n\t\tvar keys = this._zoomKeys = {},\n\t\t    codes = this.keyCodes,\n\t\t    i, len;\n\n\t\tfor (i = 0, len = codes.zoomIn.length; i < len; i++) {\n\t\t\tkeys[codes.zoomIn[i]] = zoom;\n\t\t}\n\t\tfor (i = 0, len = codes.zoomOut.length; i < len; i++) {\n\t\t\tkeys[codes.zoomOut[i]] = -zoom;\n\t\t}\n\t},\n\n\t_addHooks: function () {\n\t\tL.DomEvent.on(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_removeHooks: function () {\n\t\tL.DomEvent.off(document, 'keydown', this._onKeyDown, this);\n\t},\n\n\t_onKeyDown: function (e) {\n\t\tvar key = e.keyCode,\n\t\t    map = this._map;\n\n\t\tif (key in this._panKeys) {\n\n\t\t\tif (map._panAnim && map._panAnim._inProgress) { return; }\n\n\t\t\tmap.panBy(this._panKeys[key]);\n\n\t\t\tif (map.options.maxBounds) {\n\t\t\t\tmap.panInsideBounds(map.options.maxBounds);\n\t\t\t}\n\n\t\t} else if (key in this._zoomKeys) {\n\t\t\tmap.setZoom(map.getZoom() + this._zoomKeys[key]);\n\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tL.DomEvent.stop(e);\n\t}\n});\n\nL.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);\n\n\n/*\n * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.\n */\n\nL.Handler.MarkerDrag = L.Handler.extend({\n\tinitialize: function (marker) {\n\t\tthis._marker = marker;\n\t},\n\n\taddHooks: function () {\n\t\tvar icon = this._marker._icon;\n\t\tif (!this._draggable) {\n\t\t\tthis._draggable = new L.Draggable(icon, icon);\n\t\t}\n\n\t\tthis._draggable\n\t\t\t.on('dragstart', this._onDragStart, this)\n\t\t\t.on('drag', this._onDrag, this)\n\t\t\t.on('dragend', this._onDragEnd, this);\n\t\tthis._draggable.enable();\n\t\tL.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tremoveHooks: function () {\n\t\tthis._draggable\n\t\t\t.off('dragstart', this._onDragStart, this)\n\t\t\t.off('drag', this._onDrag, this)\n\t\t\t.off('dragend', this._onDragEnd, this);\n\n\t\tthis._draggable.disable();\n\t\tL.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');\n\t},\n\n\tmoved: function () {\n\t\treturn this._draggable && this._draggable._moved;\n\t},\n\n\t_onDragStart: function () {\n\t\tthis._marker\n\t\t    .closePopup()\n\t\t    .fire('movestart')\n\t\t    .fire('dragstart');\n\t},\n\n\t_onDrag: function () {\n\t\tvar marker = this._marker,\n\t\t    shadow = marker._shadow,\n\t\t    iconPos = L.DomUtil.getPosition(marker._icon),\n\t\t    latlng = marker._map.layerPointToLatLng(iconPos);\n\n\t\t// update shadow position\n\t\tif (shadow) {\n\t\t\tL.DomUtil.setPosition(shadow, iconPos);\n\t\t}\n\n\t\tmarker._latlng = latlng;\n\n\t\tmarker\n\t\t    .fire('move', {latlng: latlng})\n\t\t    .fire('drag');\n\t},\n\n\t_onDragEnd: function (e) {\n\t\tthis._marker\n\t\t    .fire('moveend')\n\t\t    .fire('dragend', e);\n\t}\n});\n\n\n/*\r\n * L.Control is a base class for implementing map controls. Handles positioning.\r\n * All other controls extend from this class.\r\n */\r\n\r\nL.Control = L.Class.extend({\r\n\toptions: {\r\n\t\tposition: 'topright'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\t\treturn this.options.position;\r\n\t},\r\n\r\n\tsetPosition: function (position) {\r\n\t\tvar map = this._map;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.removeControl(this);\r\n\t\t}\r\n\r\n\t\tthis.options.position = position;\r\n\r\n\t\tif (map) {\r\n\t\t\tmap.addControl(this);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetContainer: function () {\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\taddTo: function (map) {\r\n\t\tthis._map = map;\r\n\r\n\t\tvar container = this._container = this.onAdd(map),\r\n\t\t    pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tL.DomUtil.addClass(container, 'leaflet-control');\r\n\r\n\t\tif (pos.indexOf('bottom') !== -1) {\r\n\t\t\tcorner.insertBefore(container, corner.firstChild);\r\n\t\t} else {\r\n\t\t\tcorner.appendChild(container);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveFrom: function (map) {\r\n\t\tvar pos = this.getPosition(),\r\n\t\t    corner = map._controlCorners[pos];\r\n\r\n\t\tcorner.removeChild(this._container);\r\n\t\tthis._map = null;\r\n\r\n\t\tif (this.onRemove) {\r\n\t\t\tthis.onRemove(map);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_refocusOnMap: function () {\r\n\t\tif (this._map) {\r\n\t\t\tthis._map.getContainer().focus();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.control = function (options) {\r\n\treturn new L.Control(options);\r\n};\r\n\r\n\r\n// adds control-related methods to L.Map\r\n\r\nL.Map.include({\r\n\taddControl: function (control) {\r\n\t\tcontrol.addTo(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveControl: function (control) {\r\n\t\tcontrol.removeFrom(this);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initControlPos: function () {\r\n\t\tvar corners = this._controlCorners = {},\r\n\t\t    l = 'leaflet-',\r\n\t\t    container = this._controlContainer =\r\n\t\t            L.DomUtil.create('div', l + 'control-container', this._container);\r\n\r\n\t\tfunction createCorner(vSide, hSide) {\r\n\t\t\tvar className = l + vSide + ' ' + l + hSide;\r\n\r\n\t\t\tcorners[vSide + hSide] = L.DomUtil.create('div', className, container);\r\n\t\t}\r\n\r\n\t\tcreateCorner('top', 'left');\r\n\t\tcreateCorner('top', 'right');\r\n\t\tcreateCorner('bottom', 'left');\r\n\t\tcreateCorner('bottom', 'right');\r\n\t},\r\n\r\n\t_clearControlPos: function () {\r\n\t\tthis._container.removeChild(this._controlContainer);\r\n\t}\r\n});\r\n\n\n/*\r\n * L.Control.Zoom is used for the default zoom buttons on the map.\r\n */\r\n\r\nL.Control.Zoom = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'topleft',\r\n\t\tzoomInText: '+',\r\n\t\tzoomInTitle: 'Zoom in',\r\n\t\tzoomOutText: '-',\r\n\t\tzoomOutTitle: 'Zoom out'\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tvar zoomName = 'leaflet-control-zoom',\r\n\t\t    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');\r\n\r\n\t\tthis._map = map;\r\n\r\n\t\tthis._zoomInButton  = this._createButton(\r\n\t\t        this.options.zoomInText, this.options.zoomInTitle,\r\n\t\t        zoomName + '-in',  container, this._zoomIn,  this);\r\n\t\tthis._zoomOutButton = this._createButton(\r\n\t\t        this.options.zoomOutText, this.options.zoomOutTitle,\r\n\t\t        zoomName + '-out', container, this._zoomOut, this);\r\n\r\n\t\tthis._updateDisabled();\r\n\t\tmap.on('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\r\n\t\treturn container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap.off('zoomend zoomlevelschange', this._updateDisabled, this);\r\n\t},\r\n\r\n\t_zoomIn: function (e) {\r\n\t\tthis._map.zoomIn(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_zoomOut: function (e) {\r\n\t\tthis._map.zoomOut(e.shiftKey ? 3 : 1);\r\n\t},\r\n\r\n\t_createButton: function (html, title, className, container, fn, context) {\r\n\t\tvar link = L.DomUtil.create('a', className, container);\r\n\t\tlink.innerHTML = html;\r\n\t\tlink.href = '#';\r\n\t\tlink.title = title;\r\n\r\n\t\tvar stop = L.DomEvent.stopPropagation;\r\n\r\n\t\tL.DomEvent\r\n\t\t    .on(link, 'click', stop)\r\n\t\t    .on(link, 'mousedown', stop)\r\n\t\t    .on(link, 'dblclick', stop)\r\n\t\t    .on(link, 'click', L.DomEvent.preventDefault)\r\n\t\t    .on(link, 'click', fn, context)\r\n\t\t    .on(link, 'click', this._refocusOnMap, context);\r\n\r\n\t\treturn link;\r\n\t},\r\n\r\n\t_updateDisabled: function () {\r\n\t\tvar map = this._map,\r\n\t\t\tclassName = 'leaflet-disabled';\r\n\r\n\t\tL.DomUtil.removeClass(this._zoomInButton, className);\r\n\t\tL.DomUtil.removeClass(this._zoomOutButton, className);\r\n\r\n\t\tif (map._zoom === map.getMinZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomOutButton, className);\r\n\t\t}\r\n\t\tif (map._zoom === map.getMaxZoom()) {\r\n\t\t\tL.DomUtil.addClass(this._zoomInButton, className);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tzoomControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.zoomControl) {\r\n\t\tthis.zoomControl = new L.Control.Zoom();\r\n\t\tthis.addControl(this.zoomControl);\r\n\t}\r\n});\r\n\r\nL.control.zoom = function (options) {\r\n\treturn new L.Control.Zoom(options);\r\n};\r\n\r\n\n\n/*\r\n * L.Control.Attribution is used for displaying attribution on the map (added by default).\r\n */\r\n\r\nL.Control.Attribution = L.Control.extend({\r\n\toptions: {\r\n\t\tposition: 'bottomright',\r\n\t\tprefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\r\n\t},\r\n\r\n\tinitialize: function (options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._attributions = {};\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._container = L.DomUtil.create('div', 'leaflet-control-attribution');\r\n\t\tL.DomEvent.disableClickPropagation(this._container);\r\n\r\n\t\tfor (var i in map._layers) {\r\n\t\t\tif (map._layers[i].getAttribution) {\r\n\t\t\t\tthis.addAttribution(map._layers[i].getAttribution());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerAdd, this)\r\n\t\t    .on('layerremove', this._onLayerRemove, this);\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerAdd)\r\n\t\t    .off('layerremove', this._onLayerRemove);\r\n\r\n\t},\r\n\r\n\tsetPrefix: function (prefix) {\r\n\t\tthis.options.prefix = prefix;\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (!this._attributions[text]) {\r\n\t\t\tthis._attributions[text] = 0;\r\n\t\t}\r\n\t\tthis._attributions[text]++;\r\n\r\n\t\tthis._update();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveAttribution: function (text) {\r\n\t\tif (!text) { return; }\r\n\r\n\t\tif (this._attributions[text]) {\r\n\t\t\tthis._attributions[text]--;\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._map) { return; }\r\n\r\n\t\tvar attribs = [];\r\n\r\n\t\tfor (var i in this._attributions) {\r\n\t\t\tif (this._attributions[i]) {\r\n\t\t\t\tattribs.push(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar prefixAndAttribs = [];\r\n\r\n\t\tif (this.options.prefix) {\r\n\t\t\tprefixAndAttribs.push(this.options.prefix);\r\n\t\t}\r\n\t\tif (attribs.length) {\r\n\t\t\tprefixAndAttribs.push(attribs.join(', '));\r\n\t\t}\r\n\r\n\t\tthis._container.innerHTML = prefixAndAttribs.join(' | ');\r\n\t},\r\n\r\n\t_onLayerAdd: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.addAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t},\r\n\r\n\t_onLayerRemove: function (e) {\r\n\t\tif (e.layer.getAttribution) {\r\n\t\t\tthis.removeAttribution(e.layer.getAttribution());\r\n\t\t}\r\n\t}\r\n});\r\n\r\nL.Map.mergeOptions({\r\n\tattributionControl: true\r\n});\r\n\r\nL.Map.addInitHook(function () {\r\n\tif (this.options.attributionControl) {\r\n\t\tthis.attributionControl = (new L.Control.Attribution()).addTo(this);\r\n\t}\r\n});\r\n\r\nL.control.attribution = function (options) {\r\n\treturn new L.Control.Attribution(options);\r\n};\r\n\n\n/*\n * L.Control.Scale is used for displaying metric/imperial scale on the map.\n */\n\nL.Control.Scale = L.Control.extend({\n\toptions: {\n\t\tposition: 'bottomleft',\n\t\tmaxWidth: 100,\n\t\tmetric: true,\n\t\timperial: true,\n\t\tupdateWhenIdle: false\n\t},\n\n\tonAdd: function (map) {\n\t\tthis._map = map;\n\n\t\tvar className = 'leaflet-control-scale',\n\t\t    container = L.DomUtil.create('div', className),\n\t\t    options = this.options;\n\n\t\tthis._addScales(options, className, container);\n\n\t\tmap.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t\tmap.whenReady(this._update, this);\n\n\t\treturn container;\n\t},\n\n\tonRemove: function (map) {\n\t\tmap.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);\n\t},\n\n\t_addScales: function (options, className, container) {\n\t\tif (options.metric) {\n\t\t\tthis._mScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t\tif (options.imperial) {\n\t\t\tthis._iScale = L.DomUtil.create('div', className + '-line', container);\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tvar bounds = this._map.getBounds(),\n\t\t    centerLat = bounds.getCenter().lat,\n\t\t    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),\n\t\t    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,\n\n\t\t    size = this._map.getSize(),\n\t\t    options = this.options,\n\t\t    maxMeters = 0;\n\n\t\tif (size.x > 0) {\n\t\t\tmaxMeters = dist * (options.maxWidth / size.x);\n\t\t}\n\n\t\tthis._updateScales(options, maxMeters);\n\t},\n\n\t_updateScales: function (options, maxMeters) {\n\t\tif (options.metric && maxMeters) {\n\t\t\tthis._updateMetric(maxMeters);\n\t\t}\n\n\t\tif (options.imperial && maxMeters) {\n\t\t\tthis._updateImperial(maxMeters);\n\t\t}\n\t},\n\n\t_updateMetric: function (maxMeters) {\n\t\tvar meters = this._getRoundNum(maxMeters);\n\n\t\tthis._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';\n\t\tthis._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';\n\t},\n\n\t_updateImperial: function (maxMeters) {\n\t\tvar maxFeet = maxMeters * 3.2808399,\n\t\t    scale = this._iScale,\n\t\t    maxMiles, miles, feet;\n\n\t\tif (maxFeet > 5280) {\n\t\t\tmaxMiles = maxFeet / 5280;\n\t\t\tmiles = this._getRoundNum(maxMiles);\n\n\t\t\tscale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';\n\t\t\tscale.innerHTML = miles + ' mi';\n\n\t\t} else {\n\t\t\tfeet = this._getRoundNum(maxFeet);\n\n\t\t\tscale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';\n\t\t\tscale.innerHTML = feet + ' ft';\n\t\t}\n\t},\n\n\t_getScaleWidth: function (ratio) {\n\t\treturn Math.round(this.options.maxWidth * ratio) - 10;\n\t},\n\n\t_getRoundNum: function (num) {\n\t\tvar pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),\n\t\t    d = num / pow10;\n\n\t\td = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;\n\n\t\treturn pow10 * d;\n\t}\n});\n\nL.control.scale = function (options) {\n\treturn new L.Control.Scale(options);\n};\n\n\n/*\r\n * L.Control.Layers is a control to allow users to switch between different layers on the map.\r\n */\r\n\r\nL.Control.Layers = L.Control.extend({\r\n\toptions: {\r\n\t\tcollapsed: true,\r\n\t\tposition: 'topright',\r\n\t\tautoZIndex: true\r\n\t},\r\n\r\n\tinitialize: function (baseLayers, overlays, options) {\r\n\t\tL.setOptions(this, options);\r\n\r\n\t\tthis._layers = {};\r\n\t\tthis._lastZIndex = 0;\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tfor (var i in baseLayers) {\r\n\t\t\tthis._addLayer(baseLayers[i], i);\r\n\t\t}\r\n\r\n\t\tfor (i in overlays) {\r\n\t\t\tthis._addLayer(overlays[i], i, true);\r\n\t\t}\r\n\t},\r\n\r\n\tonAdd: function (map) {\r\n\t\tthis._initLayout();\r\n\t\tthis._update();\r\n\r\n\t\tmap\r\n\t\t    .on('layeradd', this._onLayerChange, this)\r\n\t\t    .on('layerremove', this._onLayerChange, this);\r\n\r\n\t\treturn this._container;\r\n\t},\r\n\r\n\tonRemove: function (map) {\r\n\t\tmap\r\n\t\t    .off('layeradd', this._onLayerChange, this)\r\n\t\t    .off('layerremove', this._onLayerChange, this);\r\n\t},\r\n\r\n\taddBaseLayer: function (layer, name) {\r\n\t\tthis._addLayer(layer, name);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddOverlay: function (layer, name) {\r\n\t\tthis._addLayer(layer, name, true);\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\tremoveLayer: function (layer) {\r\n\t\tvar id = L.stamp(layer);\r\n\t\tdelete this._layers[id];\r\n\t\tthis._update();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_initLayout: function () {\r\n\t\tvar className = 'leaflet-control-layers',\r\n\t\t    container = this._container = L.DomUtil.create('div', className);\r\n\r\n\t\t//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released\r\n\t\tcontainer.setAttribute('aria-haspopup', true);\r\n\r\n\t\tif (!L.Browser.touch) {\r\n\t\t\tL.DomEvent\r\n\t\t\t\t.disableClickPropagation(container)\r\n\t\t\t\t.disableScrollPropagation(container);\r\n\t\t} else {\r\n\t\t\tL.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);\r\n\t\t}\r\n\r\n\t\tvar form = this._form = L.DomUtil.create('form', className + '-list');\r\n\r\n\t\tif (this.options.collapsed) {\r\n\t\t\tif (!L.Browser.android) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(container, 'mouseover', this._expand, this)\r\n\t\t\t\t    .on(container, 'mouseout', this._collapse, this);\r\n\t\t\t}\r\n\t\t\tvar link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);\r\n\t\t\tlink.href = '#';\r\n\t\t\tlink.title = 'Layers';\r\n\r\n\t\t\tif (L.Browser.touch) {\r\n\t\t\t\tL.DomEvent\r\n\t\t\t\t    .on(link, 'click', L.DomEvent.stop)\r\n\t\t\t\t    .on(link, 'click', this._expand, this);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tL.DomEvent.on(link, 'focus', this._expand, this);\r\n\t\t\t}\r\n\t\t\t//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033\r\n\t\t\tL.DomEvent.on(form, 'click', function () {\r\n\t\t\t\tsetTimeout(L.bind(this._onInputClick, this), 0);\r\n\t\t\t}, this);\r\n\r\n\t\t\tthis._map.on('click', this._collapse, this);\r\n\t\t\t// TODO keyboard accessibility\r\n\t\t} else {\r\n\t\t\tthis._expand();\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList = L.DomUtil.create('div', className + '-base', form);\r\n\t\tthis._separator = L.DomUtil.create('div', className + '-separator', form);\r\n\t\tthis._overlaysList = L.DomUtil.create('div', className + '-overlays', form);\r\n\r\n\t\tcontainer.appendChild(form);\r\n\t},\r\n\r\n\t_addLayer: function (layer, name, overlay) {\r\n\t\tvar id = L.stamp(layer);\r\n\r\n\t\tthis._layers[id] = {\r\n\t\t\tlayer: layer,\r\n\t\t\tname: name,\r\n\t\t\toverlay: overlay\r\n\t\t};\r\n\r\n\t\tif (this.options.autoZIndex && layer.setZIndex) {\r\n\t\t\tthis._lastZIndex++;\r\n\t\t\tlayer.setZIndex(this._lastZIndex);\r\n\t\t}\r\n\t},\r\n\r\n\t_update: function () {\r\n\t\tif (!this._container) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._baseLayersList.innerHTML = '';\r\n\t\tthis._overlaysList.innerHTML = '';\r\n\r\n\t\tvar baseLayersPresent = false,\r\n\t\t    overlaysPresent = false,\r\n\t\t    i, obj;\r\n\r\n\t\tfor (i in this._layers) {\r\n\t\t\tobj = this._layers[i];\r\n\t\t\tthis._addItem(obj);\r\n\t\t\toverlaysPresent = overlaysPresent || obj.overlay;\r\n\t\t\tbaseLayersPresent = baseLayersPresent || !obj.overlay;\r\n\t\t}\r\n\r\n\t\tthis._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';\r\n\t},\r\n\r\n\t_onLayerChange: function (e) {\r\n\t\tvar obj = this._layers[L.stamp(e.layer)];\r\n\r\n\t\tif (!obj) { return; }\r\n\r\n\t\tif (!this._handlingClick) {\r\n\t\t\tthis._update();\r\n\t\t}\r\n\r\n\t\tvar type = obj.overlay ?\r\n\t\t\t(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :\r\n\t\t\t(e.type === 'layeradd' ? 'baselayerchange' : null);\r\n\r\n\t\tif (type) {\r\n\t\t\tthis._map.fire(type, obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)\r\n\t_createRadioElement: function (name, checked) {\r\n\r\n\t\tvar radioHtml = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + name + '\"';\r\n\t\tif (checked) {\r\n\t\t\tradioHtml += ' checked=\"checked\"';\r\n\t\t}\r\n\t\tradioHtml += '/>';\r\n\r\n\t\tvar radioFragment = document.createElement('div');\r\n\t\tradioFragment.innerHTML = radioHtml;\r\n\r\n\t\treturn radioFragment.firstChild;\r\n\t},\r\n\r\n\t_addItem: function (obj) {\r\n\t\tvar label = document.createElement('label'),\r\n\t\t    input,\r\n\t\t    checked = this._map.hasLayer(obj.layer);\r\n\r\n\t\tif (obj.overlay) {\r\n\t\t\tinput = document.createElement('input');\r\n\t\t\tinput.type = 'checkbox';\r\n\t\t\tinput.className = 'leaflet-control-layers-selector';\r\n\t\t\tinput.defaultChecked = checked;\r\n\t\t} else {\r\n\t\t\tinput = this._createRadioElement('leaflet-base-layers', checked);\r\n\t\t}\r\n\r\n\t\tinput.layerId = L.stamp(obj.layer);\r\n\r\n\t\tL.DomEvent.on(input, 'click', this._onInputClick, this);\r\n\r\n\t\tvar name = document.createElement('span');\r\n\t\tname.innerHTML = ' ' + obj.name;\r\n\r\n\t\tlabel.appendChild(input);\r\n\t\tlabel.appendChild(name);\r\n\r\n\t\tvar container = obj.overlay ? this._overlaysList : this._baseLayersList;\r\n\t\tcontainer.appendChild(label);\r\n\r\n\t\treturn label;\r\n\t},\r\n\r\n\t_onInputClick: function () {\r\n\t\tvar i, input, obj,\r\n\t\t    inputs = this._form.getElementsByTagName('input'),\r\n\t\t    inputsLen = inputs.length;\r\n\r\n\t\tthis._handlingClick = true;\r\n\r\n\t\tfor (i = 0; i < inputsLen; i++) {\r\n\t\t\tinput = inputs[i];\r\n\t\t\tobj = this._layers[input.layerId];\r\n\r\n\t\t\tif (input.checked && !this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.addLayer(obj.layer);\r\n\r\n\t\t\t} else if (!input.checked && this._map.hasLayer(obj.layer)) {\r\n\t\t\t\tthis._map.removeLayer(obj.layer);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._handlingClick = false;\r\n\r\n\t\tthis._refocusOnMap();\r\n\t},\r\n\r\n\t_expand: function () {\r\n\t\tL.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');\r\n\t},\r\n\r\n\t_collapse: function () {\r\n\t\tthis._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');\r\n\t}\r\n});\r\n\r\nL.control.layers = function (baseLayers, overlays, options) {\r\n\treturn new L.Control.Layers(baseLayers, overlays, options);\r\n};\r\n\n\n/*\n * L.PosAnimation is used by Leaflet internally for pan animations.\n */\n\nL.PosAnimation = L.Class.extend({\n\tincludes: L.Mixin.Events,\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._newPos = newPos;\n\n\t\tthis.fire('start');\n\n\t\tel.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +\n\t\t        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';\n\n\t\tL.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\t\tL.DomUtil.setPosition(el, newPos);\n\n\t\t// toggle reflow, Chrome flickers for some reason if you don't do this\n\t\tL.Util.falseFn(el.offsetWidth);\n\n\t\t// there's no native way to track value updates of transitioned properties, so we imitate this\n\t\tthis._stepTimer = setInterval(L.bind(this._onStep, this), 50);\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\t// if we just removed the transition property, the element would jump to its final position,\n\t\t// so we need to make it stay at the current position\n\n\t\tL.DomUtil.setPosition(this._el, this._getPos());\n\t\tthis._onTransitionEnd();\n\t\tL.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation\n\t},\n\n\t_onStep: function () {\n\t\tvar stepPos = this._getPos();\n\t\tif (!stepPos) {\n\t\t\tthis._onTransitionEnd();\n\t\t\treturn;\n\t\t}\n\t\t// jshint camelcase: false\n\t\t// make L.DomUtil.getPosition return intermediate position value during animation\n\t\tthis._el._leaflet_pos = stepPos;\n\n\t\tthis.fire('step');\n\t},\n\n\t// you can't easily get intermediate values of properties animated with CSS3 Transitions,\n\t// we need to parse computed style (in case of transform it returns matrix string)\n\n\t_transformRe: /([-+]?(?:\\d*\\.)?\\d+)\\D*, ([-+]?(?:\\d*\\.)?\\d+)\\D*\\)/,\n\n\t_getPos: function () {\n\t\tvar left, top, matches,\n\t\t    el = this._el,\n\t\t    style = window.getComputedStyle(el);\n\n\t\tif (L.Browser.any3d) {\n\t\t\tmatches = style[L.DomUtil.TRANSFORM].match(this._transformRe);\n\t\t\tif (!matches) { return; }\n\t\t\tleft = parseFloat(matches[1]);\n\t\t\ttop  = parseFloat(matches[2]);\n\t\t} else {\n\t\t\tleft = parseFloat(style.left);\n\t\t\ttop  = parseFloat(style.top);\n\t\t}\n\n\t\treturn new L.Point(left, top, true);\n\t},\n\n\t_onTransitionEnd: function () {\n\t\tL.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);\n\n\t\tif (!this._inProgress) { return; }\n\t\tthis._inProgress = false;\n\n\t\tthis._el.style[L.DomUtil.TRANSITION] = '';\n\n\t\t// jshint camelcase: false\n\t\t// make sure L.DomUtil.getPosition returns the final position value after animation\n\t\tthis._el._leaflet_pos = this._newPos;\n\n\t\tclearInterval(this._stepTimer);\n\n\t\tthis.fire('step').fire('end');\n\t}\n\n});\n\n\n/*\n * Extends L.Map to handle panning animations.\n */\n\nL.Map.include({\n\n\tsetView: function (center, zoom, options) {\n\n\t\tzoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);\n\t\tcenter = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);\n\t\toptions = options || {};\n\n\t\tif (this._panAnim) {\n\t\t\tthis._panAnim.stop();\n\t\t}\n\n\t\tif (this._loaded && !options.reset && options !== true) {\n\n\t\t\tif (options.animate !== undefined) {\n\t\t\t\toptions.zoom = L.extend({animate: options.animate}, options.zoom);\n\t\t\t\toptions.pan = L.extend({animate: options.animate}, options.pan);\n\t\t\t}\n\n\t\t\t// try animating pan or zoom\n\t\t\tvar animated = (this._zoom !== zoom) ?\n\t\t\t\tthis._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :\n\t\t\t\tthis._tryAnimatedPan(center, options.pan);\n\n\t\t\tif (animated) {\n\t\t\t\t// prevent resize handler call, the view will refresh after animation anyway\n\t\t\t\tclearTimeout(this._sizeTimer);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// animation didn't start, just reset the map view\n\t\tthis._resetView(center, zoom);\n\n\t\treturn this;\n\t},\n\n\tpanBy: function (offset, options) {\n\t\toffset = L.point(offset).round();\n\t\toptions = options || {};\n\n\t\tif (!offset.x && !offset.y) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (!this._panAnim) {\n\t\t\tthis._panAnim = new L.PosAnimation();\n\n\t\t\tthis._panAnim.on({\n\t\t\t\t'step': this._onPanTransitionStep,\n\t\t\t\t'end': this._onPanTransitionEnd\n\t\t\t}, this);\n\t\t}\n\n\t\t// don't fire movestart if animating inertia\n\t\tif (!options.noMoveStart) {\n\t\t\tthis.fire('movestart');\n\t\t}\n\n\t\t// animate pan unless animate: false specified\n\t\tif (options.animate !== false) {\n\t\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');\n\n\t\t\tvar newPos = this._getMapPanePos().subtract(offset);\n\t\t\tthis._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);\n\t\t} else {\n\t\t\tthis._rawPanBy(offset);\n\t\t\tthis.fire('move').fire('moveend');\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t_onPanTransitionStep: function () {\n\t\tthis.fire('move');\n\t},\n\n\t_onPanTransitionEnd: function () {\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');\n\t\tthis.fire('moveend');\n\t},\n\n\t_tryAnimatedPan: function (center, options) {\n\t\t// difference between the new and current centers in pixels\n\t\tvar offset = this._getCenterOffset(center)._floor();\n\n\t\t// don't animate too far unless animate: true specified in options\n\t\tif ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis.panBy(offset, options);\n\n\t\treturn true;\n\t}\n});\n\n\n/*\n * L.PosAnimation fallback implementation that powers Leaflet pan animations\n * in browsers that don't support CSS3 Transitions.\n */\n\nL.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({\n\n\trun: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])\n\t\tthis.stop();\n\n\t\tthis._el = el;\n\t\tthis._inProgress = true;\n\t\tthis._duration = duration || 0.25;\n\t\tthis._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);\n\n\t\tthis._startPos = L.DomUtil.getPosition(el);\n\t\tthis._offset = newPos.subtract(this._startPos);\n\t\tthis._startTime = +new Date();\n\n\t\tthis.fire('start');\n\n\t\tthis._animate();\n\t},\n\n\tstop: function () {\n\t\tif (!this._inProgress) { return; }\n\n\t\tthis._step();\n\t\tthis._complete();\n\t},\n\n\t_animate: function () {\n\t\t// animation loop\n\t\tthis._animId = L.Util.requestAnimFrame(this._animate, this);\n\t\tthis._step();\n\t},\n\n\t_step: function () {\n\t\tvar elapsed = (+new Date()) - this._startTime,\n\t\t    duration = this._duration * 1000;\n\n\t\tif (elapsed < duration) {\n\t\t\tthis._runFrame(this._easeOut(elapsed / duration));\n\t\t} else {\n\t\t\tthis._runFrame(1);\n\t\t\tthis._complete();\n\t\t}\n\t},\n\n\t_runFrame: function (progress) {\n\t\tvar pos = this._startPos.add(this._offset.multiplyBy(progress));\n\t\tL.DomUtil.setPosition(this._el, pos);\n\n\t\tthis.fire('step');\n\t},\n\n\t_complete: function () {\n\t\tL.Util.cancelAnimFrame(this._animId);\n\n\t\tthis._inProgress = false;\n\t\tthis.fire('end');\n\t},\n\n\t_easeOut: function (t) {\n\t\treturn 1 - Math.pow(1 - t, this._easeOutPower);\n\t}\n});\n\n\n/*\n * Extends L.Map to handle zoom animations.\n */\n\nL.Map.mergeOptions({\n\tzoomAnimation: true,\n\tzoomAnimationThreshold: 4\n});\n\nif (L.DomUtil.TRANSITION) {\n\n\tL.Map.addInitHook(function () {\n\t\t// don't animate on browsers without hardware-accelerated transitions or old Android/Opera\n\t\tthis._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&\n\t\t\t\tL.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;\n\n\t\t// zoom transitions run with the same duration for all layers, so if one of transitionend events\n\t\t// happens after starting zoom animation (propagating to the map pane), we know that it ended globally\n\t\tif (this._zoomAnimated) {\n\t\t\tL.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);\n\t\t}\n\t});\n}\n\nL.Map.include(!L.DomUtil.TRANSITION ? {} : {\n\n\t_catchTransitionEnd: function (e) {\n\t\tif (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {\n\t\t\tthis._onZoomTransitionEnd();\n\t\t}\n\t},\n\n\t_nothingToAnimate: function () {\n\t\treturn !this._container.getElementsByClassName('leaflet-zoom-animated').length;\n\t},\n\n\t_tryAnimatedZoom: function (center, zoom, options) {\n\n\t\tif (this._animatingZoom) { return true; }\n\n\t\toptions = options || {};\n\n\t\t// don't animate if disabled, not supported or zoom difference is too large\n\t\tif (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||\n\t\t        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }\n\n\t\t// offset is the pixel coords of the zoom origin relative to the current center\n\t\tvar scale = this.getZoomScale(zoom),\n\t\t    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),\n\t\t\torigin = this._getCenterLayerPoint()._add(offset);\n\n\t\t// don't animate if the zoom origin isn't within one screen from the current center, unless forced\n\t\tif (options.animate !== true && !this.getSize().contains(offset)) { return false; }\n\n\t\tthis\n\t\t    .fire('movestart')\n\t\t    .fire('zoomstart');\n\n\t\tthis._animateZoom(center, zoom, origin, scale, null, true);\n\n\t\treturn true;\n\t},\n\n\t_animateZoom: function (center, zoom, origin, scale, delta, backwards, forTouchZoom) {\n\n\t\tif (!forTouchZoom) {\n\t\t\tthis._animatingZoom = true;\n\t\t}\n\n\t\t// put transform transition on all layers with leaflet-zoom-animated class\n\t\tL.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\t// remember what center/zoom to set after animation\n\t\tthis._animateToCenter = center;\n\t\tthis._animateToZoom = zoom;\n\n\t\t// disable any dragging during animation\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = true;\n\t\t}\n\n\t\tL.Util.requestAnimFrame(function () {\n\t\t\tthis.fire('zoomanim', {\n\t\t\t\tcenter: center,\n\t\t\t\tzoom: zoom,\n\t\t\t\torigin: origin,\n\t\t\t\tscale: scale,\n\t\t\t\tdelta: delta,\n\t\t\t\tbackwards: backwards\n\t\t\t});\n\t\t}, this);\n\t},\n\n\t_onZoomTransitionEnd: function () {\n\n\t\tthis._animatingZoom = false;\n\n\t\tL.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');\n\n\t\tthis._resetView(this._animateToCenter, this._animateToZoom, true, true);\n\n\t\tif (L.Draggable) {\n\t\t\tL.Draggable._disabled = false;\n\t\t}\n\t}\n});\n\n\n/*\n\tZoom animation logic for L.TileLayer.\n*/\n\nL.TileLayer.include({\n\t_animateZoom: function (e) {\n\t\tif (!this._animating) {\n\t\t\tthis._animating = true;\n\t\t\tthis._prepareBgBuffer();\n\t\t}\n\n\t\tvar bg = this._bgBuffer,\n\t\t    transform = L.DomUtil.TRANSFORM,\n\t\t    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],\n\t\t    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);\n\n\t\tbg.style[transform] = e.backwards ?\n\t\t\t\tscaleStr + ' ' + initialTransform :\n\t\t\t\tinitialTransform + ' ' + scaleStr;\n\t},\n\n\t_endZoomAnim: function () {\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\tfront.style.visibility = '';\n\t\tfront.parentNode.appendChild(front); // Bring to fore\n\n\t\t// force reflow\n\t\tL.Util.falseFn(bg.offsetWidth);\n\n\t\tthis._animating = false;\n\t},\n\n\t_clearBgBuffer: function () {\n\t\tvar map = this._map;\n\n\t\tif (map && !map._animatingZoom && !map.touchZoom._zooming) {\n\t\t\tthis._bgBuffer.innerHTML = '';\n\t\t\tthis._bgBuffer.style[L.DomUtil.TRANSFORM] = '';\n\t\t}\n\t},\n\n\t_prepareBgBuffer: function () {\n\n\t\tvar front = this._tileContainer,\n\t\t    bg = this._bgBuffer;\n\n\t\t// if foreground layer doesn't have many tiles but bg layer does,\n\t\t// keep the existing bg layer and just zoom it some more\n\n\t\tvar bgLoaded = this._getLoadedTilesPercentage(bg),\n\t\t    frontLoaded = this._getLoadedTilesPercentage(front);\n\n\t\tif (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {\n\n\t\t\tfront.style.visibility = 'hidden';\n\t\t\tthis._stopLoadingImages(front);\n\t\t\treturn;\n\t\t}\n\n\t\t// prepare the buffer to become the front tile pane\n\t\tbg.style.visibility = 'hidden';\n\t\tbg.style[L.DomUtil.TRANSFORM] = '';\n\n\t\t// switch out the current layer to be the new bg layer (and vice-versa)\n\t\tthis._tileContainer = bg;\n\t\tbg = this._bgBuffer = front;\n\n\t\tthis._stopLoadingImages(bg);\n\n\t\t//prevent bg buffer from clearing right after zoom\n\t\tclearTimeout(this._clearBgBufferTimer);\n\t},\n\n\t_getLoadedTilesPercentage: function (container) {\n\t\tvar tiles = container.getElementsByTagName('img'),\n\t\t    i, len, count = 0;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\tif (tiles[i].complete) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count / len;\n\t},\n\n\t// stops loading all tiles in the background layer\n\t_stopLoadingImages: function (container) {\n\t\tvar tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),\n\t\t    i, len, tile;\n\n\t\tfor (i = 0, len = tiles.length; i < len; i++) {\n\t\t\ttile = tiles[i];\n\n\t\t\tif (!tile.complete) {\n\t\t\t\ttile.onload = L.Util.falseFn;\n\t\t\t\ttile.onerror = L.Util.falseFn;\n\t\t\t\ttile.src = L.Util.emptyImageUrl;\n\n\t\t\t\ttile.parentNode.removeChild(tile);\n\t\t\t}\n\t\t}\n\t}\n});\n\n\n/*\r\n * Provides L.Map with convenient shortcuts for using browser geolocation features.\r\n */\r\n\r\nL.Map.include({\r\n\t_defaultLocateOptions: {\r\n\t\twatch: false,\r\n\t\tsetView: false,\r\n\t\tmaxZoom: Infinity,\r\n\t\ttimeout: 10000,\r\n\t\tmaximumAge: 0,\r\n\t\tenableHighAccuracy: false\r\n\t},\r\n\r\n\tlocate: function (/*Object*/ options) {\r\n\r\n\t\toptions = this._locateOptions = L.extend(this._defaultLocateOptions, options);\r\n\r\n\t\tif (!navigator.geolocation) {\r\n\t\t\tthis._handleGeolocationError({\r\n\t\t\t\tcode: 0,\r\n\t\t\t\tmessage: 'Geolocation not supported.'\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tvar onResponse = L.bind(this._handleGeolocationResponse, this),\r\n\t\t\tonError = L.bind(this._handleGeolocationError, this);\r\n\r\n\t\tif (options.watch) {\r\n\t\t\tthis._locationWatchId =\r\n\t\t\t        navigator.geolocation.watchPosition(onResponse, onError, options);\r\n\t\t} else {\r\n\t\t\tnavigator.geolocation.getCurrentPosition(onResponse, onError, options);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\tstopLocate: function () {\r\n\t\tif (navigator.geolocation) {\r\n\t\t\tnavigator.geolocation.clearWatch(this._locationWatchId);\r\n\t\t}\r\n\t\tif (this._locateOptions) {\r\n\t\t\tthis._locateOptions.setView = false;\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\r\n\t_handleGeolocationError: function (error) {\r\n\t\tvar c = error.code,\r\n\t\t    message = error.message ||\r\n\t\t            (c === 1 ? 'permission denied' :\r\n\t\t            (c === 2 ? 'position unavailable' : 'timeout'));\r\n\r\n\t\tif (this._locateOptions.setView && !this._loaded) {\r\n\t\t\tthis.fitWorld();\r\n\t\t}\r\n\r\n\t\tthis.fire('locationerror', {\r\n\t\t\tcode: c,\r\n\t\t\tmessage: 'Geolocation error: ' + message + '.'\r\n\t\t});\r\n\t},\r\n\r\n\t_handleGeolocationResponse: function (pos) {\r\n\t\tvar lat = pos.coords.latitude,\r\n\t\t    lng = pos.coords.longitude,\r\n\t\t    latlng = new L.LatLng(lat, lng),\r\n\r\n\t\t    latAccuracy = 180 * pos.coords.accuracy / 40075017,\r\n\t\t    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),\r\n\r\n\t\t    bounds = L.latLngBounds(\r\n\t\t            [lat - latAccuracy, lng - lngAccuracy],\r\n\t\t            [lat + latAccuracy, lng + lngAccuracy]),\r\n\r\n\t\t    options = this._locateOptions;\r\n\r\n\t\tif (options.setView) {\r\n\t\t\tvar zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);\r\n\t\t\tthis.setView(latlng, zoom);\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tlatlng: latlng,\r\n\t\t\tbounds: bounds,\r\n\t\t\ttimestamp: pos.timestamp\r\n\t\t};\r\n\r\n\t\tfor (var i in pos.coords) {\r\n\t\t\tif (typeof pos.coords[i] === 'number') {\r\n\t\t\t\tdata[i] = pos.coords[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.fire('locationfound', data);\r\n\t}\r\n});\r\n\n\n}(window, document));\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/mustache/mustache.js\":[function(require,module,exports){\n/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (root, factory) {\n  if (typeof exports === \"object\" && exports) {\n    factory(exports); // CommonJS\n  } else {\n    var mustache = {};\n    factory(mustache);\n    if (typeof define === \"function\" && define.amd) {\n      define(mustache); // AMD\n    } else {\n      root.Mustache = mustache; // <script>\n    }\n  }\n}(this, function (mustache) {\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var RegExp_test = RegExp.prototype.test;\n  function testRegExp(re, string) {\n    return RegExp_test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var Object_toString = Object.prototype.toString;\n  var isArray = Array.isArray || function (object) {\n    return Object_toString.call(object) === '[object Array]';\n  };\n\n  function isFunction(object) {\n    return typeof object === 'function';\n  }\n\n  function escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      var string = match[0];\n      this.tail = this.tail.substring(string.length);\n      this.pos += string.length;\n      return string;\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view == null ? {} : view;\n    this.parent = parent;\n    this._cache = { '.': this.view };\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value;\n    if (name in this._cache) {\n      value = this._cache[name];\n    } else {\n      var context = this;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n\n          var names = name.split('.'), i = 0;\n          while (value != null && i < names.length) {\n            value = value[names[i++]];\n          }\n        } else {\n          value = context.view[name];\n        }\n\n        if (value != null) break;\n\n        context = context.parent;\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (isFunction(value)) {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = mustache.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.getPartial = function (name) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    return this._partialCache[name];\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var self = this;\n    return function (view, partials) {\n      if (partials) {\n        if (isFunction(partials)) {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return renderTokens(tokens, self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  /**\n   * Low-level function that renders the given `tokens` using the given `writer`\n   * and `context`. The `template` string is only needed for templates that use\n   * higher-order sections to extract the portion of the original template that\n   * was contained in that section.\n   */\n  function renderTokens(tokens, writer, context, template) {\n    var buffer = '';\n\n    // This function is used to render an artbitrary template\n    // in the current context by higher-order functions.\n    function subRender(template) {\n      return writer.render(template, context);\n    }\n\n    var token, tokenValue, value;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      tokenValue = token[1];\n\n      switch (token[0]) {\n      case '#':\n        value = context.lookup(tokenValue);\n\n        if (typeof value === 'object' || typeof value === 'string') {\n          if (isArray(value)) {\n            for (var j = 0, jlen = value.length; j < jlen; ++j) {\n              buffer += renderTokens(token[4], writer, context.push(value[j]), template);\n            }\n          } else if (value) {\n            buffer += renderTokens(token[4], writer, context.push(value), template);\n          }\n        } else if (isFunction(value)) {\n          var text = template == null ? null : template.slice(token[3], token[5]);\n          value = value.call(context.view, text, subRender);\n          if (value != null) buffer += value;\n        } else if (value) {\n          buffer += renderTokens(token[4], writer, context, template);\n        }\n\n        break;\n      case '^':\n        value = context.lookup(tokenValue);\n\n        // Use JavaScript's definition of falsy. Include empty arrays.\n        // See https://github.com/janl/mustache.js/issues/186\n        if (!value || (isArray(value) && value.length === 0)) {\n          buffer += renderTokens(token[4], writer, context, template);\n        }\n\n        break;\n      case '>':\n        value = writer.getPartial(tokenValue);\n        if (isFunction(value)) buffer += value(context);\n        break;\n      case '&':\n        value = context.lookup(tokenValue);\n        if (value != null) buffer += value;\n        break;\n      case 'name':\n        value = context.lookup(tokenValue);\n        if (value != null) buffer += mustache.escape(value);\n        break;\n      case 'text':\n        buffer += tokenValue;\n        break;\n      }\n    }\n\n    return buffer;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n\n    var token;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      switch (token[0]) {\n      case '#':\n      case '^':\n        sections.push(token);\n        collector.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        var section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          lastToken = token;\n          squashedTokens.push(token);\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    return [\n      new RegExp(escapeRegExp(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRegExp(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  function parseTemplate(template, tags) {\n    template = template || '';\n    tags = tags || mustache.tags;\n\n    if (typeof tags === 'string') tags = tags.split(spaceRe);\n    if (tags.length !== 2) throw new Error('Invalid tags: ' + tags.join(', '));\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(tagRes[0]);\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr == '\\n') stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) break;\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === '{') {\n        value = scanner.scanUntil(new RegExp('\\\\s*' + escapeRegExp('}' + tags[1])));\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n        if (!openSection) {\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n        }\n        if (openSection[1] !== value) {\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n        }\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        tags = value.split(spaceRe);\n        if (tags.length !== 2) {\n          throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));\n        }\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n    if (openSection) {\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n    }\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  mustache.name = \"mustache.js\";\n  mustache.version = \"0.7.3\";\n  mustache.tags = [\"{{\", \"}}\"];\n\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  mustache.parse = parseTemplate;\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // All Mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  mustache.clearCache = function () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  mustache.compile = function (template, tags) {\n    return defaultWriter.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  mustache.compilePartial = function (name, template, tags) {\n    return defaultWriter.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  mustache.compileTokens = function (tokens, template) {\n    return defaultWriter.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function (template, view, partials) {\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  mustache.to_html = function (template, view, partials, send) {\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n}));\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/index.js\":[function(require,module,exports){\nvar html_sanitize = require('./sanitizer-bundle.js');\n\nmodule.exports = function(_) {\n    if (!_) return '';\n    return html_sanitize(_, cleanUrl, cleanId);\n};\n\n// https://bugzilla.mozilla.org/show_bug.cgi?id=255107\nfunction cleanUrl(url) {\n    'use strict';\n    if (/^https?/.test(url.getScheme())) return url.toString();\n    if (/^mailto?/.test(url.getScheme())) return url.toString();\n    if ('data' == url.getScheme() && /^image/.test(url.getPath())) {\n        return url.toString();\n    }\n}\n\nfunction cleanId(id) { return id; }\n\n},{\"./sanitizer-bundle.js\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/sanitizer-bundle.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/sanitizer-bundle.js\":[function(require,module,exports){\n\n// Copyright (C) 2010 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview\n * Implements RFC 3986 for parsing/formatting URIs.\n *\n * @author mikesamuel@gmail.com\n * \\@provides URI\n * \\@overrides window\n */\n\nvar URI = (function () {\n\n/**\n * creates a uri from the string form.  The parser is relaxed, so special\n * characters that aren't escaped but don't cause ambiguities will not cause\n * parse failures.\n *\n * @return {URI|null}\n */\nfunction parse(uriStr) {\n  var m = ('' + uriStr).match(URI_RE_);\n  if (!m) { return null; }\n  return new URI(\n      nullIfAbsent(m[1]),\n      nullIfAbsent(m[2]),\n      nullIfAbsent(m[3]),\n      nullIfAbsent(m[4]),\n      nullIfAbsent(m[5]),\n      nullIfAbsent(m[6]),\n      nullIfAbsent(m[7]));\n}\n\n\n/**\n * creates a uri from the given parts.\n *\n * @param scheme {string} an unencoded scheme such as \"http\" or null\n * @param credentials {string} unencoded user credentials or null\n * @param domain {string} an unencoded domain name or null\n * @param port {number} a port number in [1, 32768].\n *    -1 indicates no port, as does null.\n * @param path {string} an unencoded path\n * @param query {Array.<string>|string|null} a list of unencoded cgi\n *   parameters where even values are keys and odds the corresponding values\n *   or an unencoded query.\n * @param fragment {string} an unencoded fragment without the \"#\" or null.\n * @return {URI}\n */\nfunction create(scheme, credentials, domain, port, path, query, fragment) {\n  var uri = new URI(\n      encodeIfExists2(scheme, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),\n      encodeIfExists2(\n          credentials, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),\n      encodeIfExists(domain),\n      port > 0 ? port.toString() : null,\n      encodeIfExists2(path, URI_DISALLOWED_IN_PATH_),\n      null,\n      encodeIfExists(fragment));\n  if (query) {\n    if ('string' === typeof query) {\n      uri.setRawQuery(query.replace(/[^?&=0-9A-Za-z_\\-~.%]/g, encodeOne));\n    } else {\n      uri.setAllParameters(query);\n    }\n  }\n  return uri;\n}\nfunction encodeIfExists(unescapedPart) {\n  if ('string' == typeof unescapedPart) {\n    return encodeURIComponent(unescapedPart);\n  }\n  return null;\n};\n/**\n * if unescapedPart is non null, then escapes any characters in it that aren't\n * valid characters in a url and also escapes any special characters that\n * appear in extra.\n *\n * @param unescapedPart {string}\n * @param extra {RegExp} a character set of characters in [\\01-\\177].\n * @return {string|null} null iff unescapedPart == null.\n */\nfunction encodeIfExists2(unescapedPart, extra) {\n  if ('string' == typeof unescapedPart) {\n    return encodeURI(unescapedPart).replace(extra, encodeOne);\n  }\n  return null;\n};\n/** converts a character in [\\01-\\177] to its url encoded equivalent. */\nfunction encodeOne(ch) {\n  var n = ch.charCodeAt(0);\n  return '%' + '0123456789ABCDEF'.charAt((n >> 4) & 0xf) +\n      '0123456789ABCDEF'.charAt(n & 0xf);\n}\n\n/**\n * {@updoc\n *  $ normPath('foo/./bar')\n *  # 'foo/bar'\n *  $ normPath('./foo')\n *  # 'foo'\n *  $ normPath('foo/.')\n *  # 'foo'\n *  $ normPath('foo//bar')\n *  # 'foo/bar'\n * }\n */\nfunction normPath(path) {\n  return path.replace(/(^|\\/)\\.(?:\\/|$)/g, '$1').replace(/\\/{2,}/g, '/');\n}\n\nvar PARENT_DIRECTORY_HANDLER = new RegExp(\n    ''\n    // A path break\n    + '(/|^)'\n    // followed by a non .. path element\n    // (cannot be . because normPath is used prior to this RegExp)\n    + '(?:[^./][^/]*|\\\\.{2,}(?:[^./][^/]*)|\\\\.{3,}[^/]*)'\n    // followed by .. followed by a path break.\n    + '/\\\\.\\\\.(?:/|$)');\n\nvar PARENT_DIRECTORY_HANDLER_RE = new RegExp(PARENT_DIRECTORY_HANDLER);\n\nvar EXTRA_PARENT_PATHS_RE = /^(?:\\.\\.\\/)*(?:\\.\\.$)?/;\n\n/**\n * Normalizes its input path and collapses all . and .. sequences except for\n * .. sequences that would take it above the root of the current parent\n * directory.\n * {@updoc\n *  $ collapse_dots('foo/../bar')\n *  # 'bar'\n *  $ collapse_dots('foo/./bar')\n *  # 'foo/bar'\n *  $ collapse_dots('foo/../bar/./../../baz')\n *  # 'baz'\n *  $ collapse_dots('../foo')\n *  # '../foo'\n *  $ collapse_dots('../foo').replace(EXTRA_PARENT_PATHS_RE, '')\n *  # 'foo'\n * }\n */\nfunction collapse_dots(path) {\n  if (path === null) { return null; }\n  var p = normPath(path);\n  // Only /../ left to flatten\n  var r = PARENT_DIRECTORY_HANDLER_RE;\n  // We replace with $1 which matches a / before the .. because this\n  // guarantees that:\n  // (1) we have at most 1 / between the adjacent place,\n  // (2) always have a slash if there is a preceding path section, and\n  // (3) we never turn a relative path into an absolute path.\n  for (var q; (q = p.replace(r, '$1')) != p; p = q) {};\n  return p;\n}\n\n/**\n * resolves a relative url string to a base uri.\n * @return {URI}\n */\nfunction resolve(baseUri, relativeUri) {\n  // there are several kinds of relative urls:\n  // 1. //foo - replaces everything from the domain on.  foo is a domain name\n  // 2. foo - replaces the last part of the path, the whole query and fragment\n  // 3. /foo - replaces the the path, the query and fragment\n  // 4. ?foo - replace the query and fragment\n  // 5. #foo - replace the fragment only\n\n  var absoluteUri = baseUri.clone();\n  // we satisfy these conditions by looking for the first part of relativeUri\n  // that is not blank and applying defaults to the rest\n\n  var overridden = relativeUri.hasScheme();\n\n  if (overridden) {\n    absoluteUri.setRawScheme(relativeUri.getRawScheme());\n  } else {\n    overridden = relativeUri.hasCredentials();\n  }\n\n  if (overridden) {\n    absoluteUri.setRawCredentials(relativeUri.getRawCredentials());\n  } else {\n    overridden = relativeUri.hasDomain();\n  }\n\n  if (overridden) {\n    absoluteUri.setRawDomain(relativeUri.getRawDomain());\n  } else {\n    overridden = relativeUri.hasPort();\n  }\n\n  var rawPath = relativeUri.getRawPath();\n  var simplifiedPath = collapse_dots(rawPath);\n  if (overridden) {\n    absoluteUri.setPort(relativeUri.getPort());\n    simplifiedPath = simplifiedPath\n        && simplifiedPath.replace(EXTRA_PARENT_PATHS_RE, '');\n  } else {\n    overridden = !!rawPath;\n    if (overridden) {\n      // resolve path properly\n      if (simplifiedPath.charCodeAt(0) !== 0x2f /* / */) {  // path is relative\n        var absRawPath = collapse_dots(absoluteUri.getRawPath() || '')\n            .replace(EXTRA_PARENT_PATHS_RE, '');\n        var slash = absRawPath.lastIndexOf('/') + 1;\n        simplifiedPath = collapse_dots(\n            (slash ? absRawPath.substring(0, slash) : '')\n            + collapse_dots(rawPath))\n            .replace(EXTRA_PARENT_PATHS_RE, '');\n      }\n    } else {\n      simplifiedPath = simplifiedPath\n          && simplifiedPath.replace(EXTRA_PARENT_PATHS_RE, '');\n      if (simplifiedPath !== rawPath) {\n        absoluteUri.setRawPath(simplifiedPath);\n      }\n    }\n  }\n\n  if (overridden) {\n    absoluteUri.setRawPath(simplifiedPath);\n  } else {\n    overridden = relativeUri.hasQuery();\n  }\n\n  if (overridden) {\n    absoluteUri.setRawQuery(relativeUri.getRawQuery());\n  } else {\n    overridden = relativeUri.hasFragment();\n  }\n\n  if (overridden) {\n    absoluteUri.setRawFragment(relativeUri.getRawFragment());\n  }\n\n  return absoluteUri;\n}\n\n/**\n * a mutable URI.\n *\n * This class contains setters and getters for the parts of the URI.\n * The <tt>getXYZ</tt>/<tt>setXYZ</tt> methods return the decoded part -- so\n * <code>uri.parse('/foo%20bar').getPath()</code> will return the decoded path,\n * <tt>/foo bar</tt>.\n *\n * <p>The raw versions of fields are available too.\n * <code>uri.parse('/foo%20bar').getRawPath()</code> will return the raw path,\n * <tt>/foo%20bar</tt>.  Use the raw setters with care, since\n * <code>URI::toString</code> is not guaranteed to return a valid url if a\n * raw setter was used.\n *\n * <p>All setters return <tt>this</tt> and so may be chained, a la\n * <code>uri.parse('/foo').setFragment('part').toString()</code>.\n *\n * <p>You should not use this constructor directly -- please prefer the factory\n * functions {@link uri.parse}, {@link uri.create}, {@link uri.resolve}\n * instead.</p>\n *\n * <p>The parameters are all raw (assumed to be properly escaped) parts, and\n * any (but not all) may be null.  Undefined is not allowed.</p>\n *\n * @constructor\n */\nfunction URI(\n    rawScheme,\n    rawCredentials, rawDomain, port,\n    rawPath, rawQuery, rawFragment) {\n  this.scheme_ = rawScheme;\n  this.credentials_ = rawCredentials;\n  this.domain_ = rawDomain;\n  this.port_ = port;\n  this.path_ = rawPath;\n  this.query_ = rawQuery;\n  this.fragment_ = rawFragment;\n  /**\n   * @type {Array|null}\n   */\n  this.paramCache_ = null;\n}\n\n/** returns the string form of the url. */\nURI.prototype.toString = function () {\n  var out = [];\n  if (null !== this.scheme_) { out.push(this.scheme_, ':'); }\n  if (null !== this.domain_) {\n    out.push('//');\n    if (null !== this.credentials_) { out.push(this.credentials_, '@'); }\n    out.push(this.domain_);\n    if (null !== this.port_) { out.push(':', this.port_.toString()); }\n  }\n  if (null !== this.path_) { out.push(this.path_); }\n  if (null !== this.query_) { out.push('?', this.query_); }\n  if (null !== this.fragment_) { out.push('#', this.fragment_); }\n  return out.join('');\n};\n\nURI.prototype.clone = function () {\n  return new URI(this.scheme_, this.credentials_, this.domain_, this.port_,\n                 this.path_, this.query_, this.fragment_);\n};\n\nURI.prototype.getScheme = function () {\n  // HTML5 spec does not require the scheme to be lowercased but\n  // all common browsers except Safari lowercase the scheme.\n  return this.scheme_ && decodeURIComponent(this.scheme_).toLowerCase();\n};\nURI.prototype.getRawScheme = function () {\n  return this.scheme_;\n};\nURI.prototype.setScheme = function (newScheme) {\n  this.scheme_ = encodeIfExists2(\n      newScheme, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);\n  return this;\n};\nURI.prototype.setRawScheme = function (newScheme) {\n  this.scheme_ = newScheme ? newScheme : null;\n  return this;\n};\nURI.prototype.hasScheme = function () {\n  return null !== this.scheme_;\n};\n\n\nURI.prototype.getCredentials = function () {\n  return this.credentials_ && decodeURIComponent(this.credentials_);\n};\nURI.prototype.getRawCredentials = function () {\n  return this.credentials_;\n};\nURI.prototype.setCredentials = function (newCredentials) {\n  this.credentials_ = encodeIfExists2(\n      newCredentials, URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);\n\n  return this;\n};\nURI.prototype.setRawCredentials = function (newCredentials) {\n  this.credentials_ = newCredentials ? newCredentials : null;\n  return this;\n};\nURI.prototype.hasCredentials = function () {\n  return null !== this.credentials_;\n};\n\n\nURI.prototype.getDomain = function () {\n  return this.domain_ && decodeURIComponent(this.domain_);\n};\nURI.prototype.getRawDomain = function () {\n  return this.domain_;\n};\nURI.prototype.setDomain = function (newDomain) {\n  return this.setRawDomain(newDomain && encodeURIComponent(newDomain));\n};\nURI.prototype.setRawDomain = function (newDomain) {\n  this.domain_ = newDomain ? newDomain : null;\n  // Maintain the invariant that paths must start with a slash when the URI\n  // is not path-relative.\n  return this.setRawPath(this.path_);\n};\nURI.prototype.hasDomain = function () {\n  return null !== this.domain_;\n};\n\n\nURI.prototype.getPort = function () {\n  return this.port_ && decodeURIComponent(this.port_);\n};\nURI.prototype.setPort = function (newPort) {\n  if (newPort) {\n    newPort = Number(newPort);\n    if (newPort !== (newPort & 0xffff)) {\n      throw new Error('Bad port number ' + newPort);\n    }\n    this.port_ = '' + newPort;\n  } else {\n    this.port_ = null;\n  }\n  return this;\n};\nURI.prototype.hasPort = function () {\n  return null !== this.port_;\n};\n\n\nURI.prototype.getPath = function () {\n  return this.path_ && decodeURIComponent(this.path_);\n};\nURI.prototype.getRawPath = function () {\n  return this.path_;\n};\nURI.prototype.setPath = function (newPath) {\n  return this.setRawPath(encodeIfExists2(newPath, URI_DISALLOWED_IN_PATH_));\n};\nURI.prototype.setRawPath = function (newPath) {\n  if (newPath) {\n    newPath = String(newPath);\n    this.path_ = \n      // Paths must start with '/' unless this is a path-relative URL.\n      (!this.domain_ || /^\\//.test(newPath)) ? newPath : '/' + newPath;\n  } else {\n    this.path_ = null;\n  }\n  return this;\n};\nURI.prototype.hasPath = function () {\n  return null !== this.path_;\n};\n\n\nURI.prototype.getQuery = function () {\n  // From http://www.w3.org/Addressing/URL/4_URI_Recommentations.html\n  // Within the query string, the plus sign is reserved as shorthand notation\n  // for a space.\n  return this.query_ && decodeURIComponent(this.query_).replace(/\\+/g, ' ');\n};\nURI.prototype.getRawQuery = function () {\n  return this.query_;\n};\nURI.prototype.setQuery = function (newQuery) {\n  this.paramCache_ = null;\n  this.query_ = encodeIfExists(newQuery);\n  return this;\n};\nURI.prototype.setRawQuery = function (newQuery) {\n  this.paramCache_ = null;\n  this.query_ = newQuery ? newQuery : null;\n  return this;\n};\nURI.prototype.hasQuery = function () {\n  return null !== this.query_;\n};\n\n/**\n * sets the query given a list of strings of the form\n * [ key0, value0, key1, value1, ... ].\n *\n * <p><code>uri.setAllParameters(['a', 'b', 'c', 'd']).getQuery()</code>\n * will yield <code>'a=b&c=d'</code>.\n */\nURI.prototype.setAllParameters = function (params) {\n  if (typeof params === 'object') {\n    if (!(params instanceof Array)\n        && (params instanceof Object\n            || Object.prototype.toString.call(params) !== '[object Array]')) {\n      var newParams = [];\n      var i = -1;\n      for (var k in params) {\n        var v = params[k];\n        if ('string' === typeof v) {\n          newParams[++i] = k;\n          newParams[++i] = v;\n        }\n      }\n      params = newParams;\n    }\n  }\n  this.paramCache_ = null;\n  var queryBuf = [];\n  var separator = '';\n  for (var j = 0; j < params.length;) {\n    var k = params[j++];\n    var v = params[j++];\n    queryBuf.push(separator, encodeURIComponent(k.toString()));\n    separator = '&';\n    if (v) {\n      queryBuf.push('=', encodeURIComponent(v.toString()));\n    }\n  }\n  this.query_ = queryBuf.join('');\n  return this;\n};\nURI.prototype.checkParameterCache_ = function () {\n  if (!this.paramCache_) {\n    var q = this.query_;\n    if (!q) {\n      this.paramCache_ = [];\n    } else {\n      var cgiParams = q.split(/[&\\?]/);\n      var out = [];\n      var k = -1;\n      for (var i = 0; i < cgiParams.length; ++i) {\n        var m = cgiParams[i].match(/^([^=]*)(?:=(.*))?$/);\n        // From http://www.w3.org/Addressing/URL/4_URI_Recommentations.html\n        // Within the query string, the plus sign is reserved as shorthand\n        // notation for a space.\n        out[++k] = decodeURIComponent(m[1]).replace(/\\+/g, ' ');\n        out[++k] = decodeURIComponent(m[2] || '').replace(/\\+/g, ' ');\n      }\n      this.paramCache_ = out;\n    }\n  }\n};\n/**\n * sets the values of the named cgi parameters.\n *\n * <p>So, <code>uri.parse('foo?a=b&c=d&e=f').setParameterValues('c', ['new'])\n * </code> yields <tt>foo?a=b&c=new&e=f</tt>.</p>\n *\n * @param key {string}\n * @param values {Array.<string>} the new values.  If values is a single string\n *   then it will be treated as the sole value.\n */\nURI.prototype.setParameterValues = function (key, values) {\n  // be nice and avoid subtle bugs where [] operator on string performs charAt\n  // on some browsers and crashes on IE\n  if (typeof values === 'string') {\n    values = [ values ];\n  }\n\n  this.checkParameterCache_();\n  var newValueIndex = 0;\n  var pc = this.paramCache_;\n  var params = [];\n  for (var i = 0, k = 0; i < pc.length; i += 2) {\n    if (key === pc[i]) {\n      if (newValueIndex < values.length) {\n        params.push(key, values[newValueIndex++]);\n      }\n    } else {\n      params.push(pc[i], pc[i + 1]);\n    }\n  }\n  while (newValueIndex < values.length) {\n    params.push(key, values[newValueIndex++]);\n  }\n  this.setAllParameters(params);\n  return this;\n};\nURI.prototype.removeParameter = function (key) {\n  return this.setParameterValues(key, []);\n};\n/**\n * returns the parameters specified in the query part of the uri as a list of\n * keys and values like [ key0, value0, key1, value1, ... ].\n *\n * @return {Array.<string>}\n */\nURI.prototype.getAllParameters = function () {\n  this.checkParameterCache_();\n  return this.paramCache_.slice(0, this.paramCache_.length);\n};\n/**\n * returns the value<b>s</b> for a given cgi parameter as a list of decoded\n * query parameter values.\n * @return {Array.<string>}\n */\nURI.prototype.getParameterValues = function (paramNameUnescaped) {\n  this.checkParameterCache_();\n  var values = [];\n  for (var i = 0; i < this.paramCache_.length; i += 2) {\n    if (paramNameUnescaped === this.paramCache_[i]) {\n      values.push(this.paramCache_[i + 1]);\n    }\n  }\n  return values;\n};\n/**\n * returns a map of cgi parameter names to (non-empty) lists of values.\n * @return {Object.<string,Array.<string>>}\n */\nURI.prototype.getParameterMap = function (paramNameUnescaped) {\n  this.checkParameterCache_();\n  var paramMap = {};\n  for (var i = 0; i < this.paramCache_.length; i += 2) {\n    var key = this.paramCache_[i++],\n      value = this.paramCache_[i++];\n    if (!(key in paramMap)) {\n      paramMap[key] = [value];\n    } else {\n      paramMap[key].push(value);\n    }\n  }\n  return paramMap;\n};\n/**\n * returns the first value for a given cgi parameter or null if the given\n * parameter name does not appear in the query string.\n * If the given parameter name does appear, but has no '<tt>=</tt>' following\n * it, then the empty string will be returned.\n * @return {string|null}\n */\nURI.prototype.getParameterValue = function (paramNameUnescaped) {\n  this.checkParameterCache_();\n  for (var i = 0; i < this.paramCache_.length; i += 2) {\n    if (paramNameUnescaped === this.paramCache_[i]) {\n      return this.paramCache_[i + 1];\n    }\n  }\n  return null;\n};\n\nURI.prototype.getFragment = function () {\n  return this.fragment_ && decodeURIComponent(this.fragment_);\n};\nURI.prototype.getRawFragment = function () {\n  return this.fragment_;\n};\nURI.prototype.setFragment = function (newFragment) {\n  this.fragment_ = newFragment ? encodeURIComponent(newFragment) : null;\n  return this;\n};\nURI.prototype.setRawFragment = function (newFragment) {\n  this.fragment_ = newFragment ? newFragment : null;\n  return this;\n};\nURI.prototype.hasFragment = function () {\n  return null !== this.fragment_;\n};\n\nfunction nullIfAbsent(matchPart) {\n  return ('string' == typeof matchPart) && (matchPart.length > 0)\n         ? matchPart\n         : null;\n}\n\n\n\n\n/**\n * a regular expression for breaking a URI into its component parts.\n *\n * <p>http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234 says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * <p>The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * <p>The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * <p>msamuel: I have modified the regular expression slightly to expose the\n * credentials, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       credentials -\\\n *    $3 = www.ics.uci.edu   domain       | authority\n *    $4 = <undefined>       port        -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n */\nvar URI_RE_ = new RegExp(\n      \"^\" +\n      \"(?:\" +\n        \"([^:/?#]+)\" +         // scheme\n      \":)?\" +\n      \"(?://\" +\n        \"(?:([^/?#]*)@)?\" +    // credentials\n        \"([^/?#:@]*)\" +        // domain\n        \"(?::([0-9]+))?\" +     // port\n      \")?\" +\n      \"([^?#]+)?\" +            // path\n      \"(?:\\\\?([^#]*))?\" +      // query\n      \"(?:#(.*))?\" +           // fragment\n      \"$\"\n      );\n\nvar URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_ = /[#\\/\\?@]/g;\nvar URI_DISALLOWED_IN_PATH_ = /[\\#\\?]/g;\n\nURI.parse = parse;\nURI.create = create;\nURI.resolve = resolve;\nURI.collapse_dots = collapse_dots;  // Visible for testing.\n\n// lightweight string-based api for loadModuleMaker\nURI.utils = {\n  mimeTypeOf: function (uri) {\n    var uriObj = parse(uri);\n    if (/\\.html$/.test(uriObj.getPath())) {\n      return 'text/html';\n    } else {\n      return 'application/javascript';\n    }\n  },\n  resolve: function (base, uri) {\n    if (base) {\n      return resolve(parse(base), parse(uri)).toString();\n    } else {\n      return '' + uri;\n    }\n  }\n};\n\n\nreturn URI;\n})();\n\n// Copyright Google Inc.\n// Licensed under the Apache Licence Version 2.0\n// Autogenerated at Mon Feb 25 13:05:42 EST 2013\n// @overrides window\n// @provides html4\nvar html4 = {};\nhtml4.atype = {\n  'NONE': 0,\n  'URI': 1,\n  'URI_FRAGMENT': 11,\n  'SCRIPT': 2,\n  'STYLE': 3,\n  'HTML': 12,\n  'ID': 4,\n  'IDREF': 5,\n  'IDREFS': 6,\n  'GLOBAL_NAME': 7,\n  'LOCAL_NAME': 8,\n  'CLASSES': 9,\n  'FRAME_TARGET': 10,\n  'MEDIA_QUERY': 13\n};\nhtml4[ 'atype' ] = html4.atype;\nhtml4.ATTRIBS = {\n  '*::class': 9,\n  '*::dir': 0,\n  '*::draggable': 0,\n  '*::hidden': 0,\n  '*::id': 4,\n  '*::inert': 0,\n  '*::itemprop': 0,\n  '*::itemref': 6,\n  '*::itemscope': 0,\n  '*::lang': 0,\n  '*::onblur': 2,\n  '*::onchange': 2,\n  '*::onclick': 2,\n  '*::ondblclick': 2,\n  '*::onfocus': 2,\n  '*::onkeydown': 2,\n  '*::onkeypress': 2,\n  '*::onkeyup': 2,\n  '*::onload': 2,\n  '*::onmousedown': 2,\n  '*::onmousemove': 2,\n  '*::onmouseout': 2,\n  '*::onmouseover': 2,\n  '*::onmouseup': 2,\n  '*::onreset': 2,\n  '*::onscroll': 2,\n  '*::onselect': 2,\n  '*::onsubmit': 2,\n  '*::onunload': 2,\n  '*::spellcheck': 0,\n  '*::style': 3,\n  '*::title': 0,\n  '*::translate': 0,\n  'a::accesskey': 0,\n  'a::coords': 0,\n  'a::href': 1,\n  'a::hreflang': 0,\n  'a::name': 7,\n  'a::onblur': 2,\n  'a::onfocus': 2,\n  'a::shape': 0,\n  'a::tabindex': 0,\n  'a::target': 10,\n  'a::type': 0,\n  'area::accesskey': 0,\n  'area::alt': 0,\n  'area::coords': 0,\n  'area::href': 1,\n  'area::nohref': 0,\n  'area::onblur': 2,\n  'area::onfocus': 2,\n  'area::shape': 0,\n  'area::tabindex': 0,\n  'area::target': 10,\n  'audio::controls': 0,\n  'audio::loop': 0,\n  'audio::mediagroup': 5,\n  'audio::muted': 0,\n  'audio::preload': 0,\n  'bdo::dir': 0,\n  'blockquote::cite': 1,\n  'br::clear': 0,\n  'button::accesskey': 0,\n  'button::disabled': 0,\n  'button::name': 8,\n  'button::onblur': 2,\n  'button::onfocus': 2,\n  'button::tabindex': 0,\n  'button::type': 0,\n  'button::value': 0,\n  'canvas::height': 0,\n  'canvas::width': 0,\n  'caption::align': 0,\n  'col::align': 0,\n  'col::char': 0,\n  'col::charoff': 0,\n  'col::span': 0,\n  'col::valign': 0,\n  'col::width': 0,\n  'colgroup::align': 0,\n  'colgroup::char': 0,\n  'colgroup::charoff': 0,\n  'colgroup::span': 0,\n  'colgroup::valign': 0,\n  'colgroup::width': 0,\n  'command::checked': 0,\n  'command::command': 5,\n  'command::disabled': 0,\n  'command::icon': 1,\n  'command::label': 0,\n  'command::radiogroup': 0,\n  'command::type': 0,\n  'data::value': 0,\n  'del::cite': 1,\n  'del::datetime': 0,\n  'details::open': 0,\n  'dir::compact': 0,\n  'div::align': 0,\n  'dl::compact': 0,\n  'fieldset::disabled': 0,\n  'font::color': 0,\n  'font::face': 0,\n  'font::size': 0,\n  'form::accept': 0,\n  'form::action': 1,\n  'form::autocomplete': 0,\n  'form::enctype': 0,\n  'form::method': 0,\n  'form::name': 7,\n  'form::novalidate': 0,\n  'form::onreset': 2,\n  'form::onsubmit': 2,\n  'form::target': 10,\n  'h1::align': 0,\n  'h2::align': 0,\n  'h3::align': 0,\n  'h4::align': 0,\n  'h5::align': 0,\n  'h6::align': 0,\n  'hr::align': 0,\n  'hr::noshade': 0,\n  'hr::size': 0,\n  'hr::width': 0,\n  'iframe::align': 0,\n  'iframe::frameborder': 0,\n  'iframe::height': 0,\n  'iframe::marginheight': 0,\n  'iframe::marginwidth': 0,\n  'iframe::width': 0,\n  'img::align': 0,\n  'img::alt': 0,\n  'img::border': 0,\n  'img::height': 0,\n  'img::hspace': 0,\n  'img::ismap': 0,\n  'img::name': 7,\n  'img::src': 1,\n  'img::usemap': 11,\n  'img::vspace': 0,\n  'img::width': 0,\n  'input::accept': 0,\n  'input::accesskey': 0,\n  'input::align': 0,\n  'input::alt': 0,\n  'input::autocomplete': 0,\n  'input::checked': 0,\n  'input::disabled': 0,\n  'input::inputmode': 0,\n  'input::ismap': 0,\n  'input::list': 5,\n  'input::max': 0,\n  'input::maxlength': 0,\n  'input::min': 0,\n  'input::multiple': 0,\n  'input::name': 8,\n  'input::onblur': 2,\n  'input::onchange': 2,\n  'input::onfocus': 2,\n  'input::onselect': 2,\n  'input::placeholder': 0,\n  'input::readonly': 0,\n  'input::required': 0,\n  'input::size': 0,\n  'input::src': 1,\n  'input::step': 0,\n  'input::tabindex': 0,\n  'input::type': 0,\n  'input::usemap': 11,\n  'input::value': 0,\n  'ins::cite': 1,\n  'ins::datetime': 0,\n  'label::accesskey': 0,\n  'label::for': 5,\n  'label::onblur': 2,\n  'label::onfocus': 2,\n  'legend::accesskey': 0,\n  'legend::align': 0,\n  'li::type': 0,\n  'li::value': 0,\n  'map::name': 7,\n  'menu::compact': 0,\n  'menu::label': 0,\n  'menu::type': 0,\n  'meter::high': 0,\n  'meter::low': 0,\n  'meter::max': 0,\n  'meter::min': 0,\n  'meter::value': 0,\n  'ol::compact': 0,\n  'ol::reversed': 0,\n  'ol::start': 0,\n  'ol::type': 0,\n  'optgroup::disabled': 0,\n  'optgroup::label': 0,\n  'option::disabled': 0,\n  'option::label': 0,\n  'option::selected': 0,\n  'option::value': 0,\n  'output::for': 6,\n  'output::name': 8,\n  'p::align': 0,\n  'pre::width': 0,\n  'progress::max': 0,\n  'progress::min': 0,\n  'progress::value': 0,\n  'q::cite': 1,\n  'select::autocomplete': 0,\n  'select::disabled': 0,\n  'select::multiple': 0,\n  'select::name': 8,\n  'select::onblur': 2,\n  'select::onchange': 2,\n  'select::onfocus': 2,\n  'select::required': 0,\n  'select::size': 0,\n  'select::tabindex': 0,\n  'source::type': 0,\n  'table::align': 0,\n  'table::bgcolor': 0,\n  'table::border': 0,\n  'table::cellpadding': 0,\n  'table::cellspacing': 0,\n  'table::frame': 0,\n  'table::rules': 0,\n  'table::summary': 0,\n  'table::width': 0,\n  'tbody::align': 0,\n  'tbody::char': 0,\n  'tbody::charoff': 0,\n  'tbody::valign': 0,\n  'td::abbr': 0,\n  'td::align': 0,\n  'td::axis': 0,\n  'td::bgcolor': 0,\n  'td::char': 0,\n  'td::charoff': 0,\n  'td::colspan': 0,\n  'td::headers': 6,\n  'td::height': 0,\n  'td::nowrap': 0,\n  'td::rowspan': 0,\n  'td::scope': 0,\n  'td::valign': 0,\n  'td::width': 0,\n  'textarea::accesskey': 0,\n  'textarea::autocomplete': 0,\n  'textarea::cols': 0,\n  'textarea::disabled': 0,\n  'textarea::inputmode': 0,\n  'textarea::name': 8,\n  'textarea::onblur': 2,\n  'textarea::onchange': 2,\n  'textarea::onfocus': 2,\n  'textarea::onselect': 2,\n  'textarea::placeholder': 0,\n  'textarea::readonly': 0,\n  'textarea::required': 0,\n  'textarea::rows': 0,\n  'textarea::tabindex': 0,\n  'textarea::wrap': 0,\n  'tfoot::align': 0,\n  'tfoot::char': 0,\n  'tfoot::charoff': 0,\n  'tfoot::valign': 0,\n  'th::abbr': 0,\n  'th::align': 0,\n  'th::axis': 0,\n  'th::bgcolor': 0,\n  'th::char': 0,\n  'th::charoff': 0,\n  'th::colspan': 0,\n  'th::headers': 6,\n  'th::height': 0,\n  'th::nowrap': 0,\n  'th::rowspan': 0,\n  'th::scope': 0,\n  'th::valign': 0,\n  'th::width': 0,\n  'thead::align': 0,\n  'thead::char': 0,\n  'thead::charoff': 0,\n  'thead::valign': 0,\n  'tr::align': 0,\n  'tr::bgcolor': 0,\n  'tr::char': 0,\n  'tr::charoff': 0,\n  'tr::valign': 0,\n  'track::default': 0,\n  'track::kind': 0,\n  'track::label': 0,\n  'track::srclang': 0,\n  'ul::compact': 0,\n  'ul::type': 0,\n  'video::controls': 0,\n  'video::height': 0,\n  'video::loop': 0,\n  'video::mediagroup': 5,\n  'video::muted': 0,\n  'video::poster': 1,\n  'video::preload': 0,\n  'video::width': 0\n};\nhtml4[ 'ATTRIBS' ] = html4.ATTRIBS;\nhtml4.eflags = {\n  'OPTIONAL_ENDTAG': 1,\n  'EMPTY': 2,\n  'CDATA': 4,\n  'RCDATA': 8,\n  'UNSAFE': 16,\n  'FOLDABLE': 32,\n  'SCRIPT': 64,\n  'STYLE': 128,\n  'VIRTUALIZED': 256\n};\nhtml4[ 'eflags' ] = html4.eflags;\nhtml4.ELEMENTS = {\n  'a': 0,\n  'abbr': 0,\n  'acronym': 0,\n  'address': 0,\n  'applet': 272,\n  'area': 2,\n  'article': 0,\n  'aside': 0,\n  'audio': 0,\n  'b': 0,\n  'base': 274,\n  'basefont': 274,\n  'bdi': 0,\n  'bdo': 0,\n  'big': 0,\n  'blockquote': 0,\n  'body': 305,\n  'br': 2,\n  'button': 0,\n  'canvas': 0,\n  'caption': 0,\n  'center': 0,\n  'cite': 0,\n  'code': 0,\n  'col': 2,\n  'colgroup': 1,\n  'command': 2,\n  'data': 0,\n  'datalist': 0,\n  'dd': 1,\n  'del': 0,\n  'details': 0,\n  'dfn': 0,\n  'dialog': 272,\n  'dir': 0,\n  'div': 0,\n  'dl': 0,\n  'dt': 1,\n  'em': 0,\n  'fieldset': 0,\n  'figcaption': 0,\n  'figure': 0,\n  'font': 0,\n  'footer': 0,\n  'form': 0,\n  'frame': 274,\n  'frameset': 272,\n  'h1': 0,\n  'h2': 0,\n  'h3': 0,\n  'h4': 0,\n  'h5': 0,\n  'h6': 0,\n  'head': 305,\n  'header': 0,\n  'hgroup': 0,\n  'hr': 2,\n  'html': 305,\n  'i': 0,\n  'iframe': 4,\n  'img': 2,\n  'input': 2,\n  'ins': 0,\n  'isindex': 274,\n  'kbd': 0,\n  'keygen': 274,\n  'label': 0,\n  'legend': 0,\n  'li': 1,\n  'link': 274,\n  'map': 0,\n  'mark': 0,\n  'menu': 0,\n  'meta': 274,\n  'meter': 0,\n  'nav': 0,\n  'nobr': 0,\n  'noembed': 276,\n  'noframes': 276,\n  'noscript': 276,\n  'object': 272,\n  'ol': 0,\n  'optgroup': 0,\n  'option': 1,\n  'output': 0,\n  'p': 1,\n  'param': 274,\n  'pre': 0,\n  'progress': 0,\n  'q': 0,\n  's': 0,\n  'samp': 0,\n  'script': 84,\n  'section': 0,\n  'select': 0,\n  'small': 0,\n  'source': 2,\n  'span': 0,\n  'strike': 0,\n  'strong': 0,\n  'style': 148,\n  'sub': 0,\n  'summary': 0,\n  'sup': 0,\n  'table': 0,\n  'tbody': 1,\n  'td': 1,\n  'textarea': 8,\n  'tfoot': 1,\n  'th': 1,\n  'thead': 1,\n  'time': 0,\n  'title': 280,\n  'tr': 1,\n  'track': 2,\n  'tt': 0,\n  'u': 0,\n  'ul': 0,\n  'var': 0,\n  'video': 0,\n  'wbr': 2\n};\nhtml4[ 'ELEMENTS' ] = html4.ELEMENTS;\nhtml4.ELEMENT_DOM_INTERFACES = {\n  'a': 'HTMLAnchorElement',\n  'abbr': 'HTMLElement',\n  'acronym': 'HTMLElement',\n  'address': 'HTMLElement',\n  'applet': 'HTMLAppletElement',\n  'area': 'HTMLAreaElement',\n  'article': 'HTMLElement',\n  'aside': 'HTMLElement',\n  'audio': 'HTMLAudioElement',\n  'b': 'HTMLElement',\n  'base': 'HTMLBaseElement',\n  'basefont': 'HTMLBaseFontElement',\n  'bdi': 'HTMLElement',\n  'bdo': 'HTMLElement',\n  'big': 'HTMLElement',\n  'blockquote': 'HTMLQuoteElement',\n  'body': 'HTMLBodyElement',\n  'br': 'HTMLBRElement',\n  'button': 'HTMLButtonElement',\n  'canvas': 'HTMLCanvasElement',\n  'caption': 'HTMLTableCaptionElement',\n  'center': 'HTMLElement',\n  'cite': 'HTMLElement',\n  'code': 'HTMLElement',\n  'col': 'HTMLTableColElement',\n  'colgroup': 'HTMLTableColElement',\n  'command': 'HTMLCommandElement',\n  'data': 'HTMLElement',\n  'datalist': 'HTMLDataListElement',\n  'dd': 'HTMLElement',\n  'del': 'HTMLModElement',\n  'details': 'HTMLDetailsElement',\n  'dfn': 'HTMLElement',\n  'dialog': 'HTMLDialogElement',\n  'dir': 'HTMLDirectoryElement',\n  'div': 'HTMLDivElement',\n  'dl': 'HTMLDListElement',\n  'dt': 'HTMLElement',\n  'em': 'HTMLElement',\n  'fieldset': 'HTMLFieldSetElement',\n  'figcaption': 'HTMLElement',\n  'figure': 'HTMLElement',\n  'font': 'HTMLFontElement',\n  'footer': 'HTMLElement',\n  'form': 'HTMLFormElement',\n  'frame': 'HTMLFrameElement',\n  'frameset': 'HTMLFrameSetElement',\n  'h1': 'HTMLHeadingElement',\n  'h2': 'HTMLHeadingElement',\n  'h3': 'HTMLHeadingElement',\n  'h4': 'HTMLHeadingElement',\n  'h5': 'HTMLHeadingElement',\n  'h6': 'HTMLHeadingElement',\n  'head': 'HTMLHeadElement',\n  'header': 'HTMLElement',\n  'hgroup': 'HTMLElement',\n  'hr': 'HTMLHRElement',\n  'html': 'HTMLHtmlElement',\n  'i': 'HTMLElement',\n  'iframe': 'HTMLIFrameElement',\n  'img': 'HTMLImageElement',\n  'input': 'HTMLInputElement',\n  'ins': 'HTMLModElement',\n  'isindex': 'HTMLUnknownElement',\n  'kbd': 'HTMLElement',\n  'keygen': 'HTMLKeygenElement',\n  'label': 'HTMLLabelElement',\n  'legend': 'HTMLLegendElement',\n  'li': 'HTMLLIElement',\n  'link': 'HTMLLinkElement',\n  'map': 'HTMLMapElement',\n  'mark': 'HTMLElement',\n  'menu': 'HTMLMenuElement',\n  'meta': 'HTMLMetaElement',\n  'meter': 'HTMLMeterElement',\n  'nav': 'HTMLElement',\n  'nobr': 'HTMLElement',\n  'noembed': 'HTMLElement',\n  'noframes': 'HTMLElement',\n  'noscript': 'HTMLElement',\n  'object': 'HTMLObjectElement',\n  'ol': 'HTMLOListElement',\n  'optgroup': 'HTMLOptGroupElement',\n  'option': 'HTMLOptionElement',\n  'output': 'HTMLOutputElement',\n  'p': 'HTMLParagraphElement',\n  'param': 'HTMLParamElement',\n  'pre': 'HTMLPreElement',\n  'progress': 'HTMLProgressElement',\n  'q': 'HTMLQuoteElement',\n  's': 'HTMLElement',\n  'samp': 'HTMLElement',\n  'script': 'HTMLScriptElement',\n  'section': 'HTMLElement',\n  'select': 'HTMLSelectElement',\n  'small': 'HTMLElement',\n  'source': 'HTMLSourceElement',\n  'span': 'HTMLSpanElement',\n  'strike': 'HTMLElement',\n  'strong': 'HTMLElement',\n  'style': 'HTMLStyleElement',\n  'sub': 'HTMLElement',\n  'summary': 'HTMLElement',\n  'sup': 'HTMLElement',\n  'table': 'HTMLTableElement',\n  'tbody': 'HTMLTableSectionElement',\n  'td': 'HTMLTableDataCellElement',\n  'textarea': 'HTMLTextAreaElement',\n  'tfoot': 'HTMLTableSectionElement',\n  'th': 'HTMLTableHeaderCellElement',\n  'thead': 'HTMLTableSectionElement',\n  'time': 'HTMLTimeElement',\n  'title': 'HTMLTitleElement',\n  'tr': 'HTMLTableRowElement',\n  'track': 'HTMLTrackElement',\n  'tt': 'HTMLElement',\n  'u': 'HTMLElement',\n  'ul': 'HTMLUListElement',\n  'var': 'HTMLElement',\n  'video': 'HTMLVideoElement',\n  'wbr': 'HTMLElement'\n};\nhtml4[ 'ELEMENT_DOM_INTERFACES' ] = html4.ELEMENT_DOM_INTERFACES;\nhtml4.ueffects = {\n  'NOT_LOADED': 0,\n  'SAME_DOCUMENT': 1,\n  'NEW_DOCUMENT': 2\n};\nhtml4[ 'ueffects' ] = html4.ueffects;\nhtml4.URIEFFECTS = {\n  'a::href': 2,\n  'area::href': 2,\n  'blockquote::cite': 0,\n  'command::icon': 1,\n  'del::cite': 0,\n  'form::action': 2,\n  'img::src': 1,\n  'input::src': 1,\n  'ins::cite': 0,\n  'q::cite': 0,\n  'video::poster': 1\n};\nhtml4[ 'URIEFFECTS' ] = html4.URIEFFECTS;\nhtml4.ltypes = {\n  'UNSANDBOXED': 2,\n  'SANDBOXED': 1,\n  'DATA': 0\n};\nhtml4[ 'ltypes' ] = html4.ltypes;\nhtml4.LOADERTYPES = {\n  'a::href': 2,\n  'area::href': 2,\n  'blockquote::cite': 2,\n  'command::icon': 1,\n  'del::cite': 2,\n  'form::action': 2,\n  'img::src': 1,\n  'input::src': 1,\n  'ins::cite': 2,\n  'q::cite': 2,\n  'video::poster': 1\n};\nhtml4[ 'LOADERTYPES' ] = html4.LOADERTYPES;\n\n// Copyright (C) 2006 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview\n * An HTML sanitizer that can satisfy a variety of security policies.\n *\n * <p>\n * The HTML sanitizer is built around a SAX parser and HTML element and\n * attributes schemas.\n *\n * If the cssparser is loaded, inline styles are sanitized using the\n * css property and value schemas.  Else they are remove during\n * sanitization.\n *\n * If it exists, uses parseCssDeclarations, sanitizeCssProperty,  cssSchema\n *\n * @author mikesamuel@gmail.com\n * @author jasvir@gmail.com\n * \\@requires html4, URI\n * \\@overrides window\n * \\@provides html, html_sanitize\n */\n\n// The Turkish i seems to be a non-issue, but abort in case it is.\nif ('I'.toLowerCase() !== 'i') { throw 'I/i problem'; }\n\n/**\n * \\@namespace\n */\nvar html = (function(html4) {\n\n  // For closure compiler\n  var parseCssDeclarations, sanitizeCssProperty, cssSchema;\n  if ('undefined' !== typeof window) {\n    parseCssDeclarations = window['parseCssDeclarations'];\n    sanitizeCssProperty = window['sanitizeCssProperty'];\n    cssSchema = window['cssSchema'];\n  }\n\n  // The keys of this object must be 'quoted' or JSCompiler will mangle them!\n  // This is a partial list -- lookupEntity() uses the host browser's parser\n  // (when available) to implement full entity lookup.\n  // Note that entities are in general case-sensitive; the uppercase ones are\n  // explicitly defined by HTML5 (presumably as compatibility).\n  var ENTITIES = {\n    'lt': '<',\n    'LT': '<',\n    'gt': '>',\n    'GT': '>',\n    'amp': '&',\n    'AMP': '&',\n    'quot': '\"',\n    'apos': '\\'',\n    'nbsp': '\\240'\n  };\n\n  // Patterns for types of entity/character reference names.\n  var decimalEscapeRe = /^#(\\d+)$/;\n  var hexEscapeRe = /^#x([0-9A-Fa-f]+)$/;\n  // contains every entity per http://www.w3.org/TR/2011/WD-html5-20110113/named-character-references.html\n  var safeEntityNameRe = /^[A-Za-z][A-za-z0-9]+$/;\n  // Used as a hook to invoke the browser's entity parsing. <textarea> is used\n  // because its content is parsed for entities but not tags.\n  // TODO(kpreid): This retrieval is a kludge and leads to silent loss of\n  // functionality if the document isn't available.\n  var entityLookupElement =\n      ('undefined' !== typeof window && window['document'])\n          ? window['document'].createElement('textarea') : null;\n  /**\n   * Decodes an HTML entity.\n   *\n   * {\\@updoc\n   * $ lookupEntity('lt')\n   * # '<'\n   * $ lookupEntity('GT')\n   * # '>'\n   * $ lookupEntity('amp')\n   * # '&'\n   * $ lookupEntity('nbsp')\n   * # '\\xA0'\n   * $ lookupEntity('apos')\n   * # \"'\"\n   * $ lookupEntity('quot')\n   * # '\"'\n   * $ lookupEntity('#xa')\n   * # '\\n'\n   * $ lookupEntity('#10')\n   * # '\\n'\n   * $ lookupEntity('#x0a')\n   * # '\\n'\n   * $ lookupEntity('#010')\n   * # '\\n'\n   * $ lookupEntity('#x00A')\n   * # '\\n'\n   * $ lookupEntity('Pi')      // Known failure\n   * # '\\u03A0'\n   * $ lookupEntity('pi')      // Known failure\n   * # '\\u03C0'\n   * }\n   *\n   * @param {string} name the content between the '&' and the ';'.\n   * @return {string} a single unicode code-point as a string.\n   */\n  function lookupEntity(name) {\n    // TODO: entity lookup as specified by HTML5 actually depends on the\n    // presence of the \";\".\n    if (ENTITIES.hasOwnProperty(name)) { return ENTITIES[name]; }\n    var m = name.match(decimalEscapeRe);\n    if (m) {\n      return String.fromCharCode(parseInt(m[1], 10));\n    } else if (!!(m = name.match(hexEscapeRe))) {\n      return String.fromCharCode(parseInt(m[1], 16));\n    } else if (entityLookupElement && safeEntityNameRe.test(name)) {\n      entityLookupElement.innerHTML = '&' + name + ';';\n      var text = entityLookupElement.textContent;\n      ENTITIES[name] = text;\n      return text;\n    } else {\n      return '&' + name + ';';\n    }\n  }\n\n  function decodeOneEntity(_, name) {\n    return lookupEntity(name);\n  }\n\n  var nulRe = /\\0/g;\n  function stripNULs(s) {\n    return s.replace(nulRe, '');\n  }\n\n  var ENTITY_RE_1 = /&(#[0-9]+|#[xX][0-9A-Fa-f]+|\\w+);/g;\n  var ENTITY_RE_2 = /^(#[0-9]+|#[xX][0-9A-Fa-f]+|\\w+);/;\n  /**\n   * The plain text of a chunk of HTML CDATA which possibly containing.\n   *\n   * {\\@updoc\n   * $ unescapeEntities('')\n   * # ''\n   * $ unescapeEntities('hello World!')\n   * # 'hello World!'\n   * $ unescapeEntities('1 &lt; 2 &amp;&AMP; 4 &gt; 3&#10;')\n   * # '1 < 2 && 4 > 3\\n'\n   * $ unescapeEntities('&lt;&lt <- unfinished entity&gt;')\n   * # '<&lt <- unfinished entity>'\n   * $ unescapeEntities('/foo?bar=baz&copy=true')  // & often unescaped in URLS\n   * # '/foo?bar=baz&copy=true'\n   * $ unescapeEntities('pi=&pi;&#x3c0;, Pi=&Pi;\\u03A0') // FIXME: known failure\n   * # 'pi=\\u03C0\\u03c0, Pi=\\u03A0\\u03A0'\n   * }\n   *\n   * @param {string} s a chunk of HTML CDATA.  It must not start or end inside\n   *     an HTML entity.\n   */\n  function unescapeEntities(s) {\n    return s.replace(ENTITY_RE_1, decodeOneEntity);\n  }\n\n  var ampRe = /&/g;\n  var looseAmpRe = /&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;\n  var ltRe = /[<]/g;\n  var gtRe = />/g;\n  var quotRe = /\\\"/g;\n\n  /**\n   * Escapes HTML special characters in attribute values.\n   *\n   * {\\@updoc\n   * $ escapeAttrib('')\n   * # ''\n   * $ escapeAttrib('\"<<&==&>>\"')  // Do not just escape the first occurrence.\n   * # '&#34;&lt;&lt;&amp;&#61;&#61;&amp;&gt;&gt;&#34;'\n   * $ escapeAttrib('Hello <World>!')\n   * # 'Hello &lt;World&gt;!'\n   * }\n   */\n  function escapeAttrib(s) {\n    return ('' + s).replace(ampRe, '&amp;').replace(ltRe, '&lt;')\n        .replace(gtRe, '&gt;').replace(quotRe, '&#34;');\n  }\n\n  /**\n   * Escape entities in RCDATA that can be escaped without changing the meaning.\n   * {\\@updoc\n   * $ normalizeRCData('1 < 2 &&amp; 3 > 4 &amp;& 5 &lt; 7&8')\n   * # '1 &lt; 2 &amp;&amp; 3 &gt; 4 &amp;&amp; 5 &lt; 7&amp;8'\n   * }\n   */\n  function normalizeRCData(rcdata) {\n    return rcdata\n        .replace(looseAmpRe, '&amp;$1')\n        .replace(ltRe, '&lt;')\n        .replace(gtRe, '&gt;');\n  }\n\n  // TODO(felix8a): validate sanitizer regexs against the HTML5 grammar at\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html\n\n  // We initially split input so that potentially meaningful characters\n  // like '<' and '>' are separate tokens, using a fast dumb process that\n  // ignores quoting.  Then we walk that token stream, and when we see a\n  // '<' that's the start of a tag, we use ATTR_RE to extract tag\n  // attributes from the next token.  That token will never have a '>'\n  // character.  However, it might have an unbalanced quote character, and\n  // when we see that, we combine additional tokens to balance the quote.\n\n  var ATTR_RE = new RegExp(\n    '^\\\\s*' +\n    '([-.:\\\\w]+)' +             // 1 = Attribute name\n    '(?:' + (\n      '\\\\s*(=)\\\\s*' +           // 2 = Is there a value?\n      '(' + (                   // 3 = Attribute value\n        // TODO(felix8a): maybe use backref to match quotes\n        '(\\\")[^\\\"]*(\\\"|$)' +    // 4, 5 = Double-quoted string\n        '|' +\n        '(\\')[^\\']*(\\'|$)' +    // 6, 7 = Single-quoted string\n        '|' +\n        // Positive lookahead to prevent interpretation of\n        // <foo a= b=c> as <foo a='b=c'>\n        // TODO(felix8a): might be able to drop this case\n        '(?=[a-z][-\\\\w]*\\\\s*=)' +\n        '|' +\n        // Unquoted value that isn't an attribute name\n        // (since we didn't match the positive lookahead above)\n        '[^\\\"\\'\\\\s]*' ) +\n      ')' ) +\n    ')?',\n    'i');\n\n  // false on IE<=8, true on most other browsers\n  var splitWillCapture = ('a,b'.split(/(,)/).length === 3);\n\n  // bitmask for tags with special parsing, like <script> and <textarea>\n  var EFLAGS_TEXT = html4.eflags['CDATA'] | html4.eflags['RCDATA'];\n\n  /**\n   * Given a SAX-like event handler, produce a function that feeds those\n   * events and a parameter to the event handler.\n   *\n   * The event handler has the form:{@code\n   * {\n   *   // Name is an upper-case HTML tag name.  Attribs is an array of\n   *   // alternating upper-case attribute names, and attribute values.  The\n   *   // attribs array is reused by the parser.  Param is the value passed to\n   *   // the saxParser.\n   *   startTag: function (name, attribs, param) { ... },\n   *   endTag:   function (name, param) { ... },\n   *   pcdata:   function (text, param) { ... },\n   *   rcdata:   function (text, param) { ... },\n   *   cdata:    function (text, param) { ... },\n   *   startDoc: function (param) { ... },\n   *   endDoc:   function (param) { ... }\n   * }}\n   *\n   * @param {Object} handler a record containing event handlers.\n   * @return {function(string, Object)} A function that takes a chunk of HTML\n   *     and a parameter.  The parameter is passed on to the handler methods.\n   */\n  function makeSaxParser(handler) {\n    // Accept quoted or unquoted keys (Closure compat)\n    var hcopy = {\n      cdata: handler.cdata || handler['cdata'],\n      comment: handler.comment || handler['comment'],\n      endDoc: handler.endDoc || handler['endDoc'],\n      endTag: handler.endTag || handler['endTag'],\n      pcdata: handler.pcdata || handler['pcdata'],\n      rcdata: handler.rcdata || handler['rcdata'],\n      startDoc: handler.startDoc || handler['startDoc'],\n      startTag: handler.startTag || handler['startTag']\n    };\n    return function(htmlText, param) {\n      return parse(htmlText, hcopy, param);\n    };\n  }\n\n  // Parsing strategy is to split input into parts that might be lexically\n  // meaningful (every \">\" becomes a separate part), and then recombine\n  // parts if we discover they're in a different context.\n\n  // TODO(felix8a): Significant performance regressions from -legacy,\n  // tested on\n  //    Chrome 18.0\n  //    Firefox 11.0\n  //    IE 6, 7, 8, 9\n  //    Opera 11.61\n  //    Safari 5.1.3\n  // Many of these are unusual patterns that are linearly slower and still\n  // pretty fast (eg 1ms to 5ms), so not necessarily worth fixing.\n\n  // TODO(felix8a): \"<script> && && && ... <\\/script>\" is slower on all\n  // browsers.  The hotspot is htmlSplit.\n\n  // TODO(felix8a): \"<p title='>>>>...'><\\/p>\" is slower on all browsers.\n  // This is partly htmlSplit, but the hotspot is parseTagAndAttrs.\n\n  // TODO(felix8a): \"<a><\\/a><a><\\/a>...\" is slower on IE9.\n  // \"<a>1<\\/a><a>1<\\/a>...\" is faster, \"<a><\\/a>2<a><\\/a>2...\" is faster.\n\n  // TODO(felix8a): \"<p<p<p...\" is slower on IE[6-8]\n\n  var continuationMarker = {};\n  function parse(htmlText, handler, param) {\n    var m, p, tagName;\n    var parts = htmlSplit(htmlText);\n    var state = {\n      noMoreGT: false,\n      noMoreEndComments: false\n    };\n    parseCPS(handler, parts, 0, state, param);\n  }\n\n  function continuationMaker(h, parts, initial, state, param) {\n    return function () {\n      parseCPS(h, parts, initial, state, param);\n    };\n  }\n\n  function parseCPS(h, parts, initial, state, param) {\n    try {\n      if (h.startDoc && initial == 0) { h.startDoc(param); }\n      var m, p, tagName;\n      for (var pos = initial, end = parts.length; pos < end;) {\n        var current = parts[pos++];\n        var next = parts[pos];\n        switch (current) {\n        case '&':\n          if (ENTITY_RE_2.test(next)) {\n            if (h.pcdata) {\n              h.pcdata('&' + next, param, continuationMarker,\n                continuationMaker(h, parts, pos, state, param));\n            }\n            pos++;\n          } else {\n            if (h.pcdata) { h.pcdata(\"&amp;\", param, continuationMarker,\n                continuationMaker(h, parts, pos, state, param));\n            }\n          }\n          break;\n        case '<\\/':\n          if (m = /^([-\\w:]+)[^\\'\\\"]*/.exec(next)) {\n            if (m[0].length === next.length && parts[pos + 1] === '>') {\n              // fast case, no attribute parsing needed\n              pos += 2;\n              tagName = m[1].toLowerCase();\n              if (h.endTag) {\n                h.endTag(tagName, param, continuationMarker,\n                  continuationMaker(h, parts, pos, state, param));\n              }\n            } else {\n              // slow case, need to parse attributes\n              // TODO(felix8a): do we really care about misparsing this?\n              pos = parseEndTag(\n                parts, pos, h, param, continuationMarker, state);\n            }\n          } else {\n            if (h.pcdata) {\n              h.pcdata('&lt;/', param, continuationMarker,\n                continuationMaker(h, parts, pos, state, param));\n            }\n          }\n          break;\n        case '<':\n          if (m = /^([-\\w:]+)\\s*\\/?/.exec(next)) {\n            if (m[0].length === next.length && parts[pos + 1] === '>') {\n              // fast case, no attribute parsing needed\n              pos += 2;\n              tagName = m[1].toLowerCase();\n              if (h.startTag) {\n                h.startTag(tagName, [], param, continuationMarker,\n                  continuationMaker(h, parts, pos, state, param));\n              }\n              // tags like <script> and <textarea> have special parsing\n              var eflags = html4.ELEMENTS[tagName];\n              if (eflags & EFLAGS_TEXT) {\n                var tag = { name: tagName, next: pos, eflags: eflags };\n                pos = parseText(\n                  parts, tag, h, param, continuationMarker, state);\n              }\n            } else {\n              // slow case, need to parse attributes\n              pos = parseStartTag(\n                parts, pos, h, param, continuationMarker, state);\n            }\n          } else {\n            if (h.pcdata) {\n              h.pcdata('&lt;', param, continuationMarker,\n                continuationMaker(h, parts, pos, state, param));\n            }\n          }\n          break;\n        case '<\\!--':\n          // The pathological case is n copies of '<\\!--' without '-->', and\n          // repeated failure to find '-->' is quadratic.  We avoid that by\n          // remembering when search for '-->' fails.\n          if (!state.noMoreEndComments) {\n            // A comment <\\!--x--> is split into three tokens:\n            //   '<\\!--', 'x--', '>'\n            // We want to find the next '>' token that has a preceding '--'.\n            // pos is at the 'x--'.\n            for (p = pos + 1; p < end; p++) {\n              if (parts[p] === '>' && /--$/.test(parts[p - 1])) { break; }\n            }\n            if (p < end) {\n              if (h.comment) {\n                var comment = parts.slice(pos, p).join('');\n                h.comment(\n                  comment.substr(0, comment.length - 2), param,\n                  continuationMarker,\n                  continuationMaker(h, parts, p + 1, state, param));\n              }\n              pos = p + 1;\n            } else {\n              state.noMoreEndComments = true;\n            }\n          }\n          if (state.noMoreEndComments) {\n            if (h.pcdata) {\n              h.pcdata('&lt;!--', param, continuationMarker,\n                continuationMaker(h, parts, pos, state, param));\n            }\n          }\n          break;\n        case '<\\!':\n          if (!/^\\w/.test(next)) {\n            if (h.pcdata) {\n              h.pcdata('&lt;!', param, continuationMarker,\n                continuationMaker(h, parts, pos, state, param));\n            }\n          } else {\n            // similar to noMoreEndComment logic\n            if (!state.noMoreGT) {\n              for (p = pos + 1; p < end; p++) {\n                if (parts[p] === '>') { break; }\n              }\n              if (p < end) {\n                pos = p + 1;\n              } else {\n                state.noMoreGT = true;\n              }\n            }\n            if (state.noMoreGT) {\n              if (h.pcdata) {\n                h.pcdata('&lt;!', param, continuationMarker,\n                  continuationMaker(h, parts, pos, state, param));\n              }\n            }\n          }\n          break;\n        case '<?':\n          // similar to noMoreEndComment logic\n          if (!state.noMoreGT) {\n            for (p = pos + 1; p < end; p++) {\n              if (parts[p] === '>') { break; }\n            }\n            if (p < end) {\n              pos = p + 1;\n            } else {\n              state.noMoreGT = true;\n            }\n          }\n          if (state.noMoreGT) {\n            if (h.pcdata) {\n              h.pcdata('&lt;?', param, continuationMarker,\n                continuationMaker(h, parts, pos, state, param));\n            }\n          }\n          break;\n        case '>':\n          if (h.pcdata) {\n            h.pcdata(\"&gt;\", param, continuationMarker,\n              continuationMaker(h, parts, pos, state, param));\n          }\n          break;\n        case '':\n          break;\n        default:\n          if (h.pcdata) {\n            h.pcdata(current, param, continuationMarker,\n              continuationMaker(h, parts, pos, state, param));\n          }\n          break;\n        }\n      }\n      if (h.endDoc) { h.endDoc(param); }\n    } catch (e) {\n      if (e !== continuationMarker) { throw e; }\n    }\n  }\n\n  // Split str into parts for the html parser.\n  function htmlSplit(str) {\n    // can't hoist this out of the function because of the re.exec loop.\n    var re = /(<\\/|<\\!--|<[!?]|[&<>])/g;\n    str += '';\n    if (splitWillCapture) {\n      return str.split(re);\n    } else {\n      var parts = [];\n      var lastPos = 0;\n      var m;\n      while ((m = re.exec(str)) !== null) {\n        parts.push(str.substring(lastPos, m.index));\n        parts.push(m[0]);\n        lastPos = m.index + m[0].length;\n      }\n      parts.push(str.substring(lastPos));\n      return parts;\n    }\n  }\n\n  function parseEndTag(parts, pos, h, param, continuationMarker, state) {\n    var tag = parseTagAndAttrs(parts, pos);\n    // drop unclosed tags\n    if (!tag) { return parts.length; }\n    if (h.endTag) {\n      h.endTag(tag.name, param, continuationMarker,\n        continuationMaker(h, parts, pos, state, param));\n    }\n    return tag.next;\n  }\n\n  function parseStartTag(parts, pos, h, param, continuationMarker, state) {\n    var tag = parseTagAndAttrs(parts, pos);\n    // drop unclosed tags\n    if (!tag) { return parts.length; }\n    if (h.startTag) {\n      h.startTag(tag.name, tag.attrs, param, continuationMarker,\n        continuationMaker(h, parts, tag.next, state, param));\n    }\n    // tags like <script> and <textarea> have special parsing\n    if (tag.eflags & EFLAGS_TEXT) {\n      return parseText(parts, tag, h, param, continuationMarker, state);\n    } else {\n      return tag.next;\n    }\n  }\n\n  var endTagRe = {};\n\n  // Tags like <script> and <textarea> are flagged as CDATA or RCDATA,\n  // which means everything is text until we see the correct closing tag.\n  function parseText(parts, tag, h, param, continuationMarker, state) {\n    var end = parts.length;\n    if (!endTagRe.hasOwnProperty(tag.name)) {\n      endTagRe[tag.name] = new RegExp('^' + tag.name + '(?:[\\\\s\\\\/]|$)', 'i');\n    }\n    var re = endTagRe[tag.name];\n    var first = tag.next;\n    var p = tag.next + 1;\n    for (; p < end; p++) {\n      if (parts[p - 1] === '<\\/' && re.test(parts[p])) { break; }\n    }\n    if (p < end) { p -= 1; }\n    var buf = parts.slice(first, p).join('');\n    if (tag.eflags & html4.eflags['CDATA']) {\n      if (h.cdata) {\n        h.cdata(buf, param, continuationMarker,\n          continuationMaker(h, parts, p, state, param));\n      }\n    } else if (tag.eflags & html4.eflags['RCDATA']) {\n      if (h.rcdata) {\n        h.rcdata(normalizeRCData(buf), param, continuationMarker,\n          continuationMaker(h, parts, p, state, param));\n      }\n    } else {\n      throw new Error('bug');\n    }\n    return p;\n  }\n\n  // at this point, parts[pos-1] is either \"<\" or \"<\\/\".\n  function parseTagAndAttrs(parts, pos) {\n    var m = /^([-\\w:]+)/.exec(parts[pos]);\n    var tag = {};\n    tag.name = m[1].toLowerCase();\n    tag.eflags = html4.ELEMENTS[tag.name];\n    var buf = parts[pos].substr(m[0].length);\n    // Find the next '>'.  We optimistically assume this '>' is not in a\n    // quoted context, and further down we fix things up if it turns out to\n    // be quoted.\n    var p = pos + 1;\n    var end = parts.length;\n    for (; p < end; p++) {\n      if (parts[p] === '>') { break; }\n      buf += parts[p];\n    }\n    if (end <= p) { return void 0; }\n    var attrs = [];\n    while (buf !== '') {\n      m = ATTR_RE.exec(buf);\n      if (!m) {\n        // No attribute found: skip garbage\n        buf = buf.replace(/^[\\s\\S][^a-z\\s]*/, '');\n\n      } else if ((m[4] && !m[5]) || (m[6] && !m[7])) {\n        // Unterminated quote: slurp to the next unquoted '>'\n        var quote = m[4] || m[6];\n        var sawQuote = false;\n        var abuf = [buf, parts[p++]];\n        for (; p < end; p++) {\n          if (sawQuote) {\n            if (parts[p] === '>') { break; }\n          } else if (0 <= parts[p].indexOf(quote)) {\n            sawQuote = true;\n          }\n          abuf.push(parts[p]);\n        }\n        // Slurp failed: lose the garbage\n        if (end <= p) { break; }\n        // Otherwise retry attribute parsing\n        buf = abuf.join('');\n        continue;\n\n      } else {\n        // We have an attribute\n        var aName = m[1].toLowerCase();\n        var aValue = m[2] ? decodeValue(m[3]) : '';\n        attrs.push(aName, aValue);\n        buf = buf.substr(m[0].length);\n      }\n    }\n    tag.attrs = attrs;\n    tag.next = p + 1;\n    return tag;\n  }\n\n  function decodeValue(v) {\n    var q = v.charCodeAt(0);\n    if (q === 0x22 || q === 0x27) { // \" or '\n      v = v.substr(1, v.length - 2);\n    }\n    return unescapeEntities(stripNULs(v));\n  }\n\n  /**\n   * Returns a function that strips unsafe tags and attributes from html.\n   * @param {function(string, Array.<string>): ?Array.<string>} tagPolicy\n   *     A function that takes (tagName, attribs[]), where tagName is a key in\n   *     html4.ELEMENTS and attribs is an array of alternating attribute names\n   *     and values.  It should return a record (as follows), or null to delete\n   *     the element.  It's okay for tagPolicy to modify the attribs array,\n   *     but the same array is reused, so it should not be held between calls.\n   *     Record keys:\n   *        attribs: (required) Sanitized attributes array.\n   *        tagName: Replacement tag name.\n   * @return {function(string, Array)} A function that sanitizes a string of\n   *     HTML and appends result strings to the second argument, an array.\n   */\n  function makeHtmlSanitizer(tagPolicy) {\n    var stack;\n    var ignoring;\n    var emit = function (text, out) {\n      if (!ignoring) { out.push(text); }\n    };\n    return makeSaxParser({\n      'startDoc': function(_) {\n        stack = [];\n        ignoring = false;\n      },\n      'startTag': function(tagNameOrig, attribs, out) {\n        if (ignoring) { return; }\n        if (!html4.ELEMENTS.hasOwnProperty(tagNameOrig)) { return; }\n        var eflagsOrig = html4.ELEMENTS[tagNameOrig];\n        if (eflagsOrig & html4.eflags['FOLDABLE']) {\n          return;\n        }\n\n        var decision = tagPolicy(tagNameOrig, attribs);\n        if (!decision) {\n          ignoring = !(eflagsOrig & html4.eflags['EMPTY']);\n          return;\n        } else if (typeof decision !== 'object') {\n          throw new Error('tagPolicy did not return object (old API?)');\n        }\n        if ('attribs' in decision) {\n          attribs = decision['attribs'];\n        } else {\n          throw new Error('tagPolicy gave no attribs');\n        }\n        var eflagsRep;\n        var tagNameRep;\n        if ('tagName' in decision) {\n          tagNameRep = decision['tagName'];\n          eflagsRep = html4.ELEMENTS[tagNameRep];\n        } else {\n          tagNameRep = tagNameOrig;\n          eflagsRep = eflagsOrig;\n        }\n        // TODO(mikesamuel): relying on tagPolicy not to insert unsafe\n        // attribute names.\n\n        // If this is an optional-end-tag element and either this element or its\n        // previous like sibling was rewritten, then insert a close tag to\n        // preserve structure.\n        if (eflagsOrig & html4.eflags['OPTIONAL_ENDTAG']) {\n          var onStack = stack[stack.length - 1];\n          if (onStack && onStack.orig === tagNameOrig &&\n              (onStack.rep !== tagNameRep || tagNameOrig !== tagNameRep)) {\n                out.push('<\\/', onStack.rep, '>');\n          }\n        }\n\n        if (!(eflagsOrig & html4.eflags['EMPTY'])) {\n          stack.push({orig: tagNameOrig, rep: tagNameRep});\n        }\n\n        out.push('<', tagNameRep);\n        for (var i = 0, n = attribs.length; i < n; i += 2) {\n          var attribName = attribs[i],\n              value = attribs[i + 1];\n          if (value !== null && value !== void 0) {\n            out.push(' ', attribName, '=\"', escapeAttrib(value), '\"');\n          }\n        }\n        out.push('>');\n\n        if ((eflagsOrig & html4.eflags['EMPTY'])\n            && !(eflagsRep & html4.eflags['EMPTY'])) {\n          // replacement is non-empty, synthesize end tag\n          out.push('<\\/', tagNameRep, '>');\n        }\n      },\n      'endTag': function(tagName, out) {\n        if (ignoring) {\n          ignoring = false;\n          return;\n        }\n        if (!html4.ELEMENTS.hasOwnProperty(tagName)) { return; }\n        var eflags = html4.ELEMENTS[tagName];\n        if (!(eflags & (html4.eflags['EMPTY'] | html4.eflags['FOLDABLE']))) {\n          var index;\n          if (eflags & html4.eflags['OPTIONAL_ENDTAG']) {\n            for (index = stack.length; --index >= 0;) {\n              var stackElOrigTag = stack[index].orig;\n              if (stackElOrigTag === tagName) { break; }\n              if (!(html4.ELEMENTS[stackElOrigTag] &\n                    html4.eflags['OPTIONAL_ENDTAG'])) {\n                // Don't pop non optional end tags looking for a match.\n                return;\n              }\n            }\n          } else {\n            for (index = stack.length; --index >= 0;) {\n              if (stack[index].orig === tagName) { break; }\n            }\n          }\n          if (index < 0) { return; }  // Not opened.\n          for (var i = stack.length; --i > index;) {\n            var stackElRepTag = stack[i].rep;\n            if (!(html4.ELEMENTS[stackElRepTag] &\n                  html4.eflags['OPTIONAL_ENDTAG'])) {\n              out.push('<\\/', stackElRepTag, '>');\n            }\n          }\n          if (index < stack.length) {\n            tagName = stack[index].rep;\n          }\n          stack.length = index;\n          out.push('<\\/', tagName, '>');\n        }\n      },\n      'pcdata': emit,\n      'rcdata': emit,\n      'cdata': emit,\n      'endDoc': function(out) {\n        for (; stack.length; stack.length--) {\n          out.push('<\\/', stack[stack.length - 1].rep, '>');\n        }\n      }\n    });\n  }\n\n  var ALLOWED_URI_SCHEMES = /^(?:https?|mailto|data)$/i;\n\n  function safeUri(uri, effect, ltype, hints, naiveUriRewriter) {\n    if (!naiveUriRewriter) { return null; }\n    try {\n      var parsed = URI.parse('' + uri);\n      if (parsed) {\n        if (!parsed.hasScheme() ||\n            ALLOWED_URI_SCHEMES.test(parsed.getScheme())) {\n          var safe = naiveUriRewriter(parsed, effect, ltype, hints);\n          return safe ? safe.toString() : null;\n        }\n      }\n    } catch (e) {\n      return null;\n    }\n    return null;\n  }\n\n  function log(logger, tagName, attribName, oldValue, newValue) {\n    if (!attribName) {\n      logger(tagName + \" removed\", {\n        change: \"removed\",\n        tagName: tagName\n      });\n    }\n    if (oldValue !== newValue) {\n      var changed = \"changed\";\n      if (oldValue && !newValue) {\n        changed = \"removed\";\n      } else if (!oldValue && newValue)  {\n        changed = \"added\";\n      }\n      logger(tagName + \".\" + attribName + \" \" + changed, {\n        change: changed,\n        tagName: tagName,\n        attribName: attribName,\n        oldValue: oldValue,\n        newValue: newValue\n      });\n    }\n  }\n\n  function lookupAttribute(map, tagName, attribName) {\n    var attribKey;\n    attribKey = tagName + '::' + attribName;\n    if (map.hasOwnProperty(attribKey)) {\n      return map[attribKey];\n    }\n    attribKey = '*::' + attribName;\n    if (map.hasOwnProperty(attribKey)) {\n      return map[attribKey];\n    }\n    return void 0;\n  }\n  function getAttributeType(tagName, attribName) {\n    return lookupAttribute(html4.ATTRIBS, tagName, attribName);\n  }\n  function getLoaderType(tagName, attribName) {\n    return lookupAttribute(html4.LOADERTYPES, tagName, attribName);\n  }\n  function getUriEffect(tagName, attribName) {\n    return lookupAttribute(html4.URIEFFECTS, tagName, attribName);\n  }\n\n  /**\n   * Sanitizes attributes on an HTML tag.\n   * @param {string} tagName An HTML tag name in lowercase.\n   * @param {Array.<?string>} attribs An array of alternating names and values.\n   * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to\n   *     apply to URI attributes; it can return a new string value, or null to\n   *     delete the attribute.  If unspecified, URI attributes are deleted.\n   * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply\n   *     to attributes containing HTML names, element IDs, and space-separated\n   *     lists of classes; it can return a new string value, or null to delete\n   *     the attribute.  If unspecified, these attributes are kept unchanged.\n   * @return {Array.<?string>} The sanitized attributes as a list of alternating\n   *     names and values, where a null value means to omit the attribute.\n   */\n  function sanitizeAttribs(tagName, attribs,\n    opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {\n    // TODO(felix8a): it's obnoxious that domado duplicates much of this\n    // TODO(felix8a): maybe consistently enforce constraints like target=\n    for (var i = 0; i < attribs.length; i += 2) {\n      var attribName = attribs[i];\n      var value = attribs[i + 1];\n      var oldValue = value;\n      var atype = null, attribKey;\n      if ((attribKey = tagName + '::' + attribName,\n           html4.ATTRIBS.hasOwnProperty(attribKey)) ||\n          (attribKey = '*::' + attribName,\n           html4.ATTRIBS.hasOwnProperty(attribKey))) {\n        atype = html4.ATTRIBS[attribKey];\n      }\n      if (atype !== null) {\n        switch (atype) {\n          case html4.atype['NONE']: break;\n          case html4.atype['SCRIPT']:\n            value = null;\n            if (opt_logger) {\n              log(opt_logger, tagName, attribName, oldValue, value);\n            }\n            break;\n          case html4.atype['STYLE']:\n            if ('undefined' === typeof parseCssDeclarations) {\n              value = null;\n              if (opt_logger) {\n                log(opt_logger, tagName, attribName, oldValue, value);\n\t      }\n              break;\n            }\n            var sanitizedDeclarations = [];\n            parseCssDeclarations(\n                value,\n                {\n                  declaration: function (property, tokens) {\n                    var normProp = property.toLowerCase();\n                    var schema = cssSchema[normProp];\n                    if (!schema) {\n                      return;\n                    }\n                    sanitizeCssProperty(\n                        normProp, schema, tokens,\n                        opt_naiveUriRewriter\n                        ? function (url) {\n                            return safeUri(\n                                url, html4.ueffects.SAME_DOCUMENT,\n                                html4.ltypes.SANDBOXED,\n                                {\n                                  \"TYPE\": \"CSS\",\n                                  \"CSS_PROP\": normProp\n                                }, opt_naiveUriRewriter);\n                          }\n                        : null);\n                    sanitizedDeclarations.push(property + ': ' + tokens.join(' '));\n                  }\n                });\n            value = sanitizedDeclarations.length > 0 ?\n              sanitizedDeclarations.join(' ; ') : null;\n            if (opt_logger) {\n              log(opt_logger, tagName, attribName, oldValue, value);\n            }\n            break;\n          case html4.atype['ID']:\n          case html4.atype['IDREF']:\n          case html4.atype['IDREFS']:\n          case html4.atype['GLOBAL_NAME']:\n          case html4.atype['LOCAL_NAME']:\n          case html4.atype['CLASSES']:\n            value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;\n            if (opt_logger) {\n              log(opt_logger, tagName, attribName, oldValue, value);\n            }\n            break;\n          case html4.atype['URI']:\n            value = safeUri(value,\n              getUriEffect(tagName, attribName),\n              getLoaderType(tagName, attribName),\n              {\n                \"TYPE\": \"MARKUP\",\n                \"XML_ATTR\": attribName,\n                \"XML_TAG\": tagName\n              }, opt_naiveUriRewriter);\n              if (opt_logger) {\n              log(opt_logger, tagName, attribName, oldValue, value);\n            }\n            break;\n          case html4.atype['URI_FRAGMENT']:\n            if (value && '#' === value.charAt(0)) {\n              value = value.substring(1);  // remove the leading '#'\n              value = opt_nmTokenPolicy ? opt_nmTokenPolicy(value) : value;\n              if (value !== null && value !== void 0) {\n                value = '#' + value;  // restore the leading '#'\n              }\n            } else {\n              value = null;\n            }\n            if (opt_logger) {\n              log(opt_logger, tagName, attribName, oldValue, value);\n            }\n            break;\n          default:\n            value = null;\n            if (opt_logger) {\n              log(opt_logger, tagName, attribName, oldValue, value);\n            }\n            break;\n        }\n      } else {\n        value = null;\n        if (opt_logger) {\n          log(opt_logger, tagName, attribName, oldValue, value);\n        }\n      }\n      attribs[i + 1] = value;\n    }\n    return attribs;\n  }\n\n  /**\n   * Creates a tag policy that omits all tags marked UNSAFE in html4-defs.js\n   * and applies the default attribute sanitizer with the supplied policy for\n   * URI attributes and NMTOKEN attributes.\n   * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to\n   *     apply to URI attributes.  If not given, URI attributes are deleted.\n   * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply\n   *     to attributes containing HTML names, element IDs, and space-separated\n   *     lists of classes.  If not given, such attributes are left unchanged.\n   * @return {function(string, Array.<?string>)} A tagPolicy suitable for\n   *     passing to html.sanitize.\n   */\n  function makeTagPolicy(\n    opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {\n    return function(tagName, attribs) {\n      if (!(html4.ELEMENTS[tagName] & html4.eflags['UNSAFE'])) {\n        return {\n          'attribs': sanitizeAttribs(tagName, attribs,\n            opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger)\n        };\n      } else {\n        if (opt_logger) {\n          log(opt_logger, tagName, undefined, undefined, undefined);\n        }\n      }\n    };\n  }\n\n  /**\n   * Sanitizes HTML tags and attributes according to a given policy.\n   * @param {string} inputHtml The HTML to sanitize.\n   * @param {function(string, Array.<?string>)} tagPolicy A function that\n   *     decides which tags to accept and sanitizes their attributes (see\n   *     makeHtmlSanitizer above for details).\n   * @return {string} The sanitized HTML.\n   */\n  function sanitizeWithPolicy(inputHtml, tagPolicy) {\n    var outputArray = [];\n    makeHtmlSanitizer(tagPolicy)(inputHtml, outputArray);\n    return outputArray.join('');\n  }\n\n  /**\n   * Strips unsafe tags and attributes from HTML.\n   * @param {string} inputHtml The HTML to sanitize.\n   * @param {?function(?string): ?string} opt_naiveUriRewriter A transform to\n   *     apply to URI attributes.  If not given, URI attributes are deleted.\n   * @param {function(?string): ?string} opt_nmTokenPolicy A transform to apply\n   *     to attributes containing HTML names, element IDs, and space-separated\n   *     lists of classes.  If not given, such attributes are left unchanged.\n   */\n  function sanitize(inputHtml,\n    opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {\n    var tagPolicy = makeTagPolicy(\n      opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);\n    return sanitizeWithPolicy(inputHtml, tagPolicy);\n  }\n\n  // Export both quoted and unquoted names for Closure linkage.\n  var html = {};\n  html.escapeAttrib = html['escapeAttrib'] = escapeAttrib;\n  html.makeHtmlSanitizer = html['makeHtmlSanitizer'] = makeHtmlSanitizer;\n  html.makeSaxParser = html['makeSaxParser'] = makeSaxParser;\n  html.makeTagPolicy = html['makeTagPolicy'] = makeTagPolicy;\n  html.normalizeRCData = html['normalizeRCData'] = normalizeRCData;\n  html.sanitize = html['sanitize'] = sanitize;\n  html.sanitizeAttribs = html['sanitizeAttribs'] = sanitizeAttribs;\n  html.sanitizeWithPolicy = html['sanitizeWithPolicy'] = sanitizeWithPolicy;\n  html.unescapeEntities = html['unescapeEntities'] = unescapeEntities;\n  return html;\n})(html4);\n\nvar html_sanitize = html['sanitize'];\n\n// Loosen restrictions of Caja's\n// html-sanitizer to allow for styling\nhtml4.ATTRIBS['*::style'] = 0;\nhtml4.ELEMENTS['style'] = 0;\nhtml4.ATTRIBS['a::target'] = 0;\nhtml4.ELEMENTS['video'] = 0;\nhtml4.ATTRIBS['video::src'] = 0;\nhtml4.ATTRIBS['video::poster'] = 0;\nhtml4.ATTRIBS['video::controls'] = 0;\nhtml4.ELEMENTS['audio'] = 0;\nhtml4.ATTRIBS['audio::src'] = 0;\nhtml4.ATTRIBS['video::autoplay'] = 0;\nhtml4.ATTRIBS['video::controls'] = 0;\n\nif (typeof module !== 'undefined') {\n    module.exports = html_sanitize;\n}\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/package.json\":[function(require,module,exports){\nmodule.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={\n  \"author\": {\n    \"name\": \"Mapbox\"\n  },\n  \"name\": \"mapbox.js\",\n  \"description\": \"mapbox javascript api\",\n  \"version\": \"2.1.5\",\n  \"homepage\": \"http://mapbox.com/\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/mapbox/mapbox.js.git\"\n  },\n  \"main\": \"src/index.js\",\n  \"dependencies\": {\n    \"leaflet\": \"0.7.3\",\n    \"mustache\": \"0.7.3\",\n    \"corslite\": \"0.0.6\",\n    \"sanitize-caja\": \"0.1.2\"\n  },\n  \"scripts\": {\n    \"test\": \"jshint src/*.js && mocha-phantomjs test/index.html\"\n  },\n  \"devDependencies\": {\n    \"leaflet-hash\": \"0.2.1\",\n    \"leaflet-fullscreen\": \"0.0.4\",\n    \"uglify-js\": \"2.4.8\",\n    \"mocha\": \"1.17.1\",\n    \"expect.js\": \"0.3.1\",\n    \"sinon\": \"1.10.2\",\n    \"mocha-phantomjs\": \"3.1.6\",\n    \"happen\": \"0.1.3\",\n    \"browserify\": \"^6.3.2\",\n    \"jshint\": \"2.4.4\",\n    \"clean-css\": \"~2.0.7\",\n    \"minimist\": \"0.0.5\",\n    \"marked\": \"~0.3.0\"\n  },\n  \"optionalDependencies\": {},\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"gitHead\": \"3127a3218db85030914cdc25a23a73c768807b5b\",\n  \"bugs\": {\n    \"url\": \"https://github.com/mapbox/mapbox.js/issues\"\n  },\n  \"_id\": \"mapbox.js@2.1.5\",\n  \"_shasum\": \"065a7c4e5a7ff949a01842fa24d6dfb69b6c50c4\",\n  \"_from\": \"mapbox.js@>=2.1.5 <3.0.0\",\n  \"_npmVersion\": \"2.1.6\",\n  \"_nodeVersion\": \"0.10.33\",\n  \"_npmUser\": {\n    \"name\": \"camilleanne\",\n    \"email\": \"camille@mapbox.com\"\n  },\n  \"maintainers\": [\n    {\n      \"name\": \"tmcw\",\n      \"email\": \"macwright@gmail.com\"\n    },\n    {\n      \"name\": \"tristen\",\n      \"email\": \"tristen.brown@gmail.com\"\n    },\n    {\n      \"name\": \"ansis\",\n      \"email\": \"ansis.brammanis@gmail.com\"\n    },\n    {\n      \"name\": \"yhahn\",\n      \"email\": \"young@developmentseed.org\"\n    },\n    {\n      \"name\": \"willwhite\",\n      \"email\": \"will@mapbox.com\"\n    },\n    {\n      \"name\": \"jfirebaugh\",\n      \"email\": \"john.firebaugh@gmail.com\"\n    },\n    {\n      \"name\": \"heyitsgarrett\",\n      \"email\": \"heyitsgarrett@gmail.com\"\n    },\n    {\n      \"name\": \"mourner\",\n      \"email\": \"agafonkin@gmail.com\"\n    },\n    {\n      \"name\": \"mapbox\",\n      \"email\": \"accounts@mapbox.com\"\n    },\n    {\n      \"name\": \"edenh\",\n      \"email\": \"eden@mapbox.com\"\n    },\n    {\n      \"name\": \"sgillies\",\n      \"email\": \"sean@mapbox.com\"\n    },\n    {\n      \"name\": \"lbud\",\n      \"email\": \"lauren@mapbox.com\"\n    },\n    {\n      \"name\": \"bsudekum\",\n      \"email\": \"bobby@mapbox.com\"\n    },\n    {\n      \"name\": \"dnomadb\",\n      \"email\": \"damon@mapbox.com\"\n    },\n    {\n      \"name\": \"ian29\",\n      \"email\": \"ian.villeda@gmail.com\"\n    },\n    {\n      \"name\": \"dvncan\",\n      \"email\": \"duncan@mapbox.com\"\n    },\n    {\n      \"name\": \"nickidlugash\",\n      \"email\": \"nicki@mapbox.com\"\n    },\n    {\n      \"name\": \"samanbb\",\n      \"email\": \"saman@mapbox.com\"\n    },\n    {\n      \"name\": \"ajashton\",\n      \"email\": \"aj.ashton@gmail.com\"\n    },\n    {\n      \"name\": \"lxbarth\",\n      \"email\": \"alex@developmentseed.org\"\n    },\n    {\n      \"name\": \"mikemorris\",\n      \"email\": \"michael.patrick.morris@gmail.com\"\n    },\n    {\n      \"name\": \"ianshward\",\n      \"email\": \"ian@mapbox.com\"\n    },\n    {\n      \"name\": \"ingalls\",\n      \"email\": \"nicholas.ingalls@gmail.com\"\n    },\n    {\n      \"name\": \"miccolis\",\n      \"email\": \"jeff@miccolis.net\"\n    },\n    {\n      \"name\": \"gretacb\",\n      \"email\": \"carol@mapbox.com\"\n    },\n    {\n      \"name\": \"aaronlidman\",\n      \"email\": \"aaronlidman@gmail.com\"\n    },\n    {\n      \"name\": \"morganherlocker\",\n      \"email\": \"morgan.herlocker@gmail.com\"\n    },\n    {\n      \"name\": \"camilleanne\",\n      \"email\": \"camille@mapbox.com\"\n    },\n    {\n      \"name\": \"rclark\",\n      \"email\": \"ryan.clark.j@gmail.com\"\n    },\n    {\n      \"name\": \"springmeyer\",\n      \"email\": \"dane@mapbox.com\"\n    },\n    {\n      \"name\": \"kkaefer\",\n      \"email\": \"kkaefer@gmail.com\"\n    },\n    {\n      \"name\": \"dthompson\",\n      \"email\": \"dthompson@gmail.com\"\n    }\n  ],\n  \"dist\": {\n    \"shasum\": \"065a7c4e5a7ff949a01842fa24d6dfb69b6c50c4\",\n    \"tarball\": \"http://registry.npmjs.org/mapbox.js/-/mapbox.js-2.1.5.tgz\"\n  },\n  \"directories\": {},\n  \"_resolved\": \"https://registry.npmjs.org/mapbox.js/-/mapbox.js-2.1.5.tgz\",\n  \"readme\": \"ERROR: No README data found!\"\n}\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/config.js\":[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    HTTP_URL: 'http://a.tiles.mapbox.com/v4',\n    HTTPS_URL: 'https://a.tiles.mapbox.com/v4',\n    FORCE_HTTPS: false,\n    REQUIRE_ACCESS_TOKEN: true\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/feature_layer.js\":[function(require,module,exports){\n'use strict';\n\nvar util = require('./util'),\n    urlhelper = require('./url'),\n    request = require('./request'),\n    marker = require('./marker'),\n    simplestyle = require('./simplestyle');\n\n// # featureLayer\n//\n// A layer of features, loaded from Mapbox or else. Adds the ability\n// to reset features, filter them, and load them from a GeoJSON URL.\nvar FeatureLayer = L.FeatureGroup.extend({\n    options: {\n        filter: function() { return true; },\n        sanitizer: require('sanitize-caja'),\n        style: simplestyle.style,\n        popupOptions: { closeButton: false }\n    },\n\n    initialize: function(_, options) {\n        L.setOptions(this, options);\n\n        this._layers = {};\n\n        if (typeof _ === 'string') {\n            util.idUrl(_, this);\n        // javascript object of TileJSON data\n        } else if (_ && typeof _ === 'object') {\n            this.setGeoJSON(_);\n        }\n    },\n\n    setGeoJSON: function(_) {\n        this._geojson = _;\n        this.clearLayers();\n        this._initialize(_);\n        return this;\n    },\n\n    getGeoJSON: function() {\n        return this._geojson;\n    },\n\n    loadURL: function(url) {\n        if (this._request && 'abort' in this._request) this._request.abort();\n        this._request = request(url, L.bind(function(err, json) {\n            this._request = null;\n            if (err && err.type !== 'abort') {\n                util.log('could not load features at ' + url);\n                this.fire('error', {error: err});\n            } else if (json) {\n                this.setGeoJSON(json);\n                this.fire('ready');\n            }\n        }, this));\n        return this;\n    },\n\n    loadID: function(id) {\n        return this.loadURL(urlhelper('/' + id + '/features.json', this.options.accessToken));\n    },\n\n    setFilter: function(_) {\n        this.options.filter = _;\n        if (this._geojson) {\n            this.clearLayers();\n            this._initialize(this._geojson);\n        }\n        return this;\n    },\n\n    getFilter: function() {\n        return this.options.filter;\n    },\n\n    _initialize: function(json) {\n        var features = L.Util.isArray(json) ? json : json.features,\n            i, len;\n\n        if (features) {\n            for (i = 0, len = features.length; i < len; i++) {\n                // Only add this if geometry or geometries are set and not null\n                if (features[i].geometries || features[i].geometry || features[i].features) {\n                    this._initialize(features[i]);\n                }\n            }\n        } else if (this.options.filter(json)) {\n\n            var opts = {accessToken: this.options.accessToken},\n                layer = L.GeoJSON.geometryToLayer(json, function(feature, latlon) {\n                    return marker.style(feature, latlon, opts);\n                }),\n                popupHtml = marker.createPopup(json, this.options.sanitizer);\n\n            if ('setStyle' in layer) {\n                layer.setStyle(simplestyle.style(json));\n            }\n\n            layer.feature = json;\n\n            if (popupHtml) {\n                layer.bindPopup(popupHtml, this.options.popupOptions);\n            }\n\n            this.addLayer(layer);\n        }\n    }\n});\n\nmodule.exports.FeatureLayer = FeatureLayer;\n\nmodule.exports.featureLayer = function(_, options) {\n    return new FeatureLayer(_, options);\n};\n\n},{\"./marker\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/marker.js\",\"./request\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/request.js\",\"./simplestyle\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/simplestyle.js\",\"./url\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/url.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\",\"sanitize-caja\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/geocoder.js\":[function(require,module,exports){\n'use strict';\n\nvar util = require('./util'),\n    urlhelper = require('./url'),\n    request = require('./request');\n\n// Low-level geocoding interface - wraps specific API calls and their\n// return values.\nmodule.exports = function(url, options) {\n\n    var geocoder = {};\n\n    util.strict(url, 'string');\n\n    if (url.indexOf('/') === -1) {\n        url = urlhelper('/geocode/' + url + '/{query}.json', options && options.accessToken);\n    }\n\n    geocoder.getURL = function() {\n        return url;\n    };\n\n    geocoder.queryURL = function(_) {\n        if (typeof _ !== 'string') {\n            var parts = [];\n            for (var i = 0; i < _.length; i++) {\n                parts[i] = encodeURIComponent(_[i]);\n            }\n            return L.Util.template(geocoder.getURL(), {\n                query: parts.join(';')\n            });\n        } else {\n            return L.Util.template(geocoder.getURL(), {\n                query: encodeURIComponent(_)\n            });\n        }\n    };\n\n    geocoder.query = function(_, callback) {\n        util.strict(callback, 'function');\n        request(geocoder.queryURL(_), function(err, json) {\n            if (json && (json.length || json.features)) {\n                var res = {\n                    results: json\n                };\n                if (json.features && json.features.length) {\n                    res.latlng = [\n                        json.features[0].center[1],\n                        json.features[0].center[0]];\n\n                    if (json.features[0].bbox) {\n                        res.bounds = json.features[0].bbox;\n                        res.lbounds = util.lbounds(res.bounds);\n                    }\n                }\n                callback(null, res);\n            } else callback(err || true);\n        });\n\n        return geocoder;\n    };\n\n    // a reverse geocode:\n    //\n    //  geocoder.reverseQuery([80, 20])\n    geocoder.reverseQuery = function(_, callback) {\n        var q = '';\n\n        // sort through different ways people represent lat and lon pairs\n        function normalize(x) {\n            if (x.lat !== undefined && x.lng !== undefined) {\n                return x.lng + ',' + x.lat;\n            } else if (x.lat !== undefined && x.lon !== undefined) {\n                return x.lon + ',' + x.lat;\n            } else {\n                return x[0] + ',' + x[1];\n            }\n        }\n\n        if (_.length && _[0].length) {\n            for (var i = 0, pts = []; i < _.length; i++) {\n                pts.push(normalize(_[i]));\n            }\n            q = pts.join(';');\n        } else {\n            q = normalize(_);\n        }\n\n        request(geocoder.queryURL(q), function(err, json) {\n            callback(err, json);\n        });\n\n        return geocoder;\n    };\n\n    return geocoder;\n};\n\n},{\"./request\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/request.js\",\"./url\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/url.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/geocoder_control.js\":[function(require,module,exports){\n'use strict';\n\nvar geocoder = require('./geocoder'),\n    util = require('./util');\n\nvar GeocoderControl = L.Control.extend({\n    includes: L.Mixin.Events,\n\n    options: {\n        position: 'topleft',\n        pointZoom: 16,\n        keepOpen: false,\n        autocomplete: false\n    },\n\n    initialize: function(_, options) {\n        L.Util.setOptions(this, options);\n        this.setURL(_);\n        this._updateSubmit = L.bind(this._updateSubmit, this);\n        this._updateAutocomplete = L.bind(this._updateAutocomplete, this);\n        this._chooseResult = L.bind(this._chooseResult, this);\n    },\n\n    setURL: function(_) {\n        this.geocoder = geocoder(_, {accessToken: this.options.accessToken});\n        return this;\n    },\n\n    getURL: function() {\n        return this.geocoder.getURL();\n    },\n\n    setID: function(_) {\n        return this.setURL(_);\n    },\n\n    setTileJSON: function(_) {\n        return this.setURL(_.geocoder);\n    },\n\n    _toggle: function(e) {\n        if (e) L.DomEvent.stop(e);\n        if (L.DomUtil.hasClass(this._container, 'active')) {\n            L.DomUtil.removeClass(this._container, 'active');\n            this._results.innerHTML = '';\n            this._input.blur();\n        } else {\n            L.DomUtil.addClass(this._container, 'active');\n            this._input.focus();\n            this._input.select();\n        }\n    },\n\n    _closeIfOpen: function(e) {\n        if (L.DomUtil.hasClass(this._container, 'active') &&\n            !this.options.keepOpen) {\n            L.DomUtil.removeClass(this._container, 'active');\n            this._results.innerHTML = '';\n            this._input.blur();\n        }\n    },\n\n    onAdd: function(map) {\n\n        var container = L.DomUtil.create('div', 'leaflet-control-mapbox-geocoder leaflet-bar leaflet-control'),\n            link = L.DomUtil.create('a', 'leaflet-control-mapbox-geocoder-toggle mapbox-icon mapbox-icon-geocoder', container),\n            results = L.DomUtil.create('div', 'leaflet-control-mapbox-geocoder-results', container),\n            wrap = L.DomUtil.create('div', 'leaflet-control-mapbox-geocoder-wrap', container),\n            form = L.DomUtil.create('form', 'leaflet-control-mapbox-geocoder-form', wrap),\n            input  = L.DomUtil.create('input', '', form);\n\n        link.href = '#';\n        link.innerHTML = '&nbsp;';\n\n        input.type = 'text';\n        input.setAttribute('placeholder', 'Search');\n\n        L.DomEvent.addListener(form, 'submit', this._geocode, this);\n        L.DomEvent.addListener(input, 'keyup', this._autocomplete, this);\n        L.DomEvent.disableClickPropagation(container);\n\n        this._map = map;\n        this._results = results;\n        this._input = input;\n        this._form = form;\n\n        if (this.options.keepOpen) {\n            L.DomUtil.addClass(container, 'active');\n        } else {\n            this._map.on('click', this._closeIfOpen, this);\n            L.DomEvent.addListener(link, 'click', this._toggle, this);\n        }\n\n        return container;\n    },\n\n    _updateSubmit: function(err, resp) {\n        L.DomUtil.removeClass(this._container, 'searching');\n        this._results.innerHTML = '';\n        if (err || !resp) {\n            this.fire('error', {error: err});\n        } else {\n            var features = [];\n            if (resp.results && resp.results.features) {\n                features = resp.results.features;\n            }\n            if (features.length === 1) {\n                this.fire('autoselect', { feature: features[0] });\n                this.fire('found', {results: resp.results});\n                this._chooseResult(features[0]);\n                this._closeIfOpen();\n            } else if (features.length > 1) {\n                this.fire('found', {results: resp.results});\n                this._displayResults(features);\n            } else {\n                this._displayResults(features);\n            }\n        }\n    },\n\n    _updateAutocomplete: function(err, resp) {\n        this._results.innerHTML = '';\n        if (err || !resp) {\n            this.fire('error', {error: err});\n        } else {\n            var features = [];\n            if (resp.results && resp.results.features) {\n                features = resp.results.features;\n            }\n            if (features.length) {\n                this.fire('found', {results: resp.results});\n            }\n            this._displayResults(features);\n        }\n    },\n\n    _displayResults: function(features) {\n        for (var i = 0, l = Math.min(features.length, 5); i < l; i++) {\n            var feature = features[i];\n            var name = feature.place_name;\n            if (!name.length) continue;\n\n            var r = L.DomUtil.create('a', '', this._results);\n            var text = ('innerText' in r) ? 'innerText' : 'textContent';\n            r[text] = name;\n            r.href = '#';\n\n            (L.bind(function(feature) {\n                L.DomEvent.addListener(r, 'click', function(e) {\n                    this._chooseResult(feature);\n                    L.DomEvent.stop(e);\n                    this.fire('select', { feature: feature });\n                }, this);\n            }, this))(feature);\n        }\n        if (features.length > 5) {\n            var outof = L.DomUtil.create('span', '', this._results);\n            outof.innerHTML = 'Top 5 of ' + features.length + '  results';\n        }\n    },\n\n    _chooseResult: function(result) {\n        if (result.bbox) {\n            this._map.fitBounds(util.lbounds(result.bbox));\n        } else if (result.center) {\n            this._map.setView([result.center[1], result.center[0]], (this._map.getZoom() === undefined) ?\n                this.options.pointZoom :\n                Math.max(this._map.getZoom(), this.options.pointZoom));\n        }\n    },\n\n    _geocode: function(e) {\n        L.DomEvent.preventDefault(e);\n        if (this._input.value === '') return this._updateSubmit();\n        L.DomUtil.addClass(this._container, 'searching');\n        this.geocoder.query(this._input.value, this._updateSubmit);\n    },\n\n    _autocomplete: function(e) {\n        if (!this.options.autocomplete) return;\n        if (this._input.value === '') return this._updateAutocomplete();\n        this.geocoder.query(this._input.value, this._updateAutocomplete);\n    }\n});\n\nmodule.exports.GeocoderControl = GeocoderControl;\n\nmodule.exports.geocoderControl = function(_, options) {\n    return new GeocoderControl(_, options);\n};\n\n},{\"./geocoder\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/geocoder.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid.js\":[function(require,module,exports){\n'use strict';\n\nfunction utfDecode(c) {\n    if (c >= 93) c--;\n    if (c >= 35) c--;\n    return c - 32;\n}\n\nmodule.exports = function(data) {\n    return function(x, y) {\n        if (!data) return;\n        var idx = utfDecode(data.grid[y].charCodeAt(x)),\n            key = data.keys[idx];\n        return data.data[key];\n    };\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid_control.js\":[function(require,module,exports){\n'use strict';\n\nvar util = require('./util'),\n    Mustache = require('mustache');\n\nvar GridControl = L.Control.extend({\n\n    options: {\n        pinnable: true,\n        follow: false,\n        sanitizer: require('sanitize-caja'),\n        touchTeaser: true,\n        location: true\n    },\n\n    _currentContent: '',\n\n    // pinned means that this control is on a feature and the user has likely\n    // clicked. pinned will not become false unless the user clicks off\n    // of the feature onto another or clicks x\n    _pinned: false,\n\n    initialize: function(_, options) {\n        L.Util.setOptions(this, options);\n        util.strict_instance(_, L.Class, 'L.mapbox.gridLayer');\n        this._layer = _;\n    },\n\n    setTemplate: function(template) {\n        util.strict(template, 'string');\n        this.options.template = template;\n        return this;\n    },\n\n    _template: function(format, data) {\n        if (!data) return;\n        var template = this.options.template || this._layer.getTileJSON().template;\n        if (template) {\n            var d = {};\n            d['__' + format + '__'] = true;\n            return this.options.sanitizer(\n                Mustache.to_html(template, L.extend(d, data)));\n        }\n    },\n\n    // change the content of the tooltip HTML if it has changed, otherwise\n    // noop\n    _show: function(content, o) {\n        if (content === this._currentContent) return;\n\n        this._currentContent = content;\n\n        if (this.options.follow) {\n            this._popup.setContent(content)\n                .setLatLng(o.latLng);\n            if (this._map._popup !== this._popup) this._popup.openOn(this._map);\n        } else {\n            this._container.style.display = 'block';\n            this._contentWrapper.innerHTML = content;\n        }\n    },\n\n    hide: function() {\n        this._pinned = false;\n        this._currentContent = '';\n\n        this._map.closePopup();\n        this._container.style.display = 'none';\n        this._contentWrapper.innerHTML = '';\n\n        L.DomUtil.removeClass(this._container, 'closable');\n\n        return this;\n    },\n\n    _mouseover: function(o) {\n        if (o.data) {\n            L.DomUtil.addClass(this._map._container, 'map-clickable');\n        } else {\n            L.DomUtil.removeClass(this._map._container, 'map-clickable');\n        }\n\n        if (this._pinned) return;\n\n        var content = this._template('teaser', o.data);\n        if (content) {\n            this._show(content, o);\n        } else {\n            this.hide();\n        }\n    },\n\n    _mousemove: function(o) {\n        if (this._pinned) return;\n        if (!this.options.follow) return;\n\n        this._popup.setLatLng(o.latLng);\n    },\n\n    _navigateTo: function(url) {\n        window.top.location.href = url;\n    },\n\n    _click: function(o) {\n\n        var location_formatted = this._template('location', o.data);\n        if (this.options.location && location_formatted &&\n            location_formatted.search(/^https?:/) === 0) {\n            return this._navigateTo(this._template('location', o.data));\n        }\n\n        if (!this.options.pinnable) return;\n\n        var content = this._template('full', o.data);\n\n        if (!content && this.options.touchTeaser && L.Browser.touch) {\n            content = this._template('teaser', o.data);\n        }\n\n        if (content) {\n            L.DomUtil.addClass(this._container, 'closable');\n            this._pinned = true;\n            this._show(content, o);\n        } else if (this._pinned) {\n            L.DomUtil.removeClass(this._container, 'closable');\n            this._pinned = false;\n            this.hide();\n        }\n    },\n\n    _onPopupClose: function() {\n        this._currentContent = null;\n        this._pinned = false;\n    },\n\n    _createClosebutton: function(container, fn) {\n        var link = L.DomUtil.create('a', 'close', container);\n\n        link.innerHTML = 'close';\n        link.href = '#';\n        link.title = 'close';\n\n        L.DomEvent\n            .on(link, 'click', L.DomEvent.stopPropagation)\n            .on(link, 'mousedown', L.DomEvent.stopPropagation)\n            .on(link, 'dblclick', L.DomEvent.stopPropagation)\n            .on(link, 'click', L.DomEvent.preventDefault)\n            .on(link, 'click', fn, this);\n\n        return link;\n    },\n\n    onAdd: function(map) {\n        this._map = map;\n\n        var className = 'leaflet-control-grid map-tooltip',\n            container = L.DomUtil.create('div', className),\n            contentWrapper = L.DomUtil.create('div', 'map-tooltip-content');\n\n        // hide the container element initially\n        container.style.display = 'none';\n        this._createClosebutton(container, this.hide);\n        container.appendChild(contentWrapper);\n\n        this._contentWrapper = contentWrapper;\n        this._popup = new L.Popup({ autoPan: false, closeOnClick: false });\n\n        map.on('popupclose', this._onPopupClose, this);\n\n        L.DomEvent\n            .disableClickPropagation(container)\n            // allow people to scroll tooltips with mousewheel\n            .addListener(container, 'mousewheel', L.DomEvent.stopPropagation);\n\n        this._layer\n            .on('mouseover', this._mouseover, this)\n            .on('mousemove', this._mousemove, this)\n            .on('click', this._click, this);\n\n        return container;\n    },\n\n    onRemove: function (map) {\n\n        map.off('popupclose', this._onPopupClose, this);\n\n        this._layer\n            .off('mouseover', this._mouseover, this)\n            .off('mousemove', this._mousemove, this)\n            .off('click', this._click, this);\n    }\n});\n\nmodule.exports.GridControl = GridControl;\n\nmodule.exports.gridControl = function(_, options) {\n    return new GridControl(_, options);\n};\n\n},{\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\",\"mustache\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/mustache/mustache.js\",\"sanitize-caja\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid_layer.js\":[function(require,module,exports){\n'use strict';\n\nvar util = require('./util'),\n    request = require('./request'),\n    grid = require('./grid');\n\n// forked from danzel/L.UTFGrid\nvar GridLayer = L.Class.extend({\n    includes: [L.Mixin.Events, require('./load_tilejson')],\n\n    options: {\n        template: function() { return ''; }\n    },\n\n    _mouseOn: null,\n    _tilejson: {},\n    _cache: {},\n\n    initialize: function(_, options) {\n        L.Util.setOptions(this, options);\n        this._loadTileJSON(_);\n    },\n\n    _setTileJSON: function(json) {\n        util.strict(json, 'object');\n\n        L.extend(this.options, {\n            grids: json.grids,\n            minZoom: json.minzoom,\n            maxZoom: json.maxzoom,\n            bounds: json.bounds && util.lbounds(json.bounds)\n        });\n\n        this._tilejson = json;\n        this._cache = {};\n        this._update();\n\n        return this;\n    },\n\n    getTileJSON: function() {\n        return this._tilejson;\n    },\n\n    active: function() {\n        return !!(this._map && this.options.grids && this.options.grids.length);\n    },\n\n    addTo: function (map) {\n        map.addLayer(this);\n        return this;\n    },\n\n    onAdd: function(map) {\n        this._map = map;\n        this._update();\n\n        this._map\n            .on('click', this._click, this)\n            .on('mousemove', this._move, this)\n            .on('moveend', this._update, this);\n    },\n\n    onRemove: function() {\n        this._map\n            .off('click', this._click, this)\n            .off('mousemove', this._move, this)\n            .off('moveend', this._update, this);\n    },\n\n    getData: function(latlng, callback) {\n        if (!this.active()) return;\n\n        var map = this._map,\n            point = map.project(latlng.wrap()),\n            tileSize = 256,\n            resolution = 4,\n            x = Math.floor(point.x / tileSize),\n            y = Math.floor(point.y / tileSize),\n            max = map.options.crs.scale(map.getZoom()) / tileSize;\n\n        x = (x + max) % max;\n        y = (y + max) % max;\n\n        this._getTile(map.getZoom(), x, y, function(grid) {\n            var gridX = Math.floor((point.x - (x * tileSize)) / resolution),\n                gridY = Math.floor((point.y - (y * tileSize)) / resolution);\n\n            callback(grid(gridX, gridY));\n        });\n\n        return this;\n    },\n\n    _click: function(e) {\n        this.getData(e.latlng, L.bind(function(data) {\n            this.fire('click', {\n                latLng: e.latlng,\n                data: data\n            });\n        }, this));\n    },\n\n    _move: function(e) {\n        this.getData(e.latlng, L.bind(function(data) {\n            if (data !== this._mouseOn) {\n                if (this._mouseOn) {\n                    this.fire('mouseout', {\n                        latLng: e.latlng,\n                        data: this._mouseOn\n                    });\n                }\n\n                this.fire('mouseover', {\n                    latLng: e.latlng,\n                    data: data\n                });\n\n                this._mouseOn = data;\n            } else {\n                this.fire('mousemove', {\n                    latLng: e.latlng,\n                    data: data\n                });\n            }\n        }, this));\n    },\n\n    _getTileURL: function(tilePoint) {\n        var urls = this.options.grids,\n            index = (tilePoint.x + tilePoint.y) % urls.length,\n            url = urls[index];\n\n        return L.Util.template(url, tilePoint);\n    },\n\n    // Load up all required json grid files\n    _update: function() {\n        if (!this.active()) return;\n\n        var bounds = this._map.getPixelBounds(),\n            z = this._map.getZoom(),\n            tileSize = 256;\n\n        if (z > this.options.maxZoom || z < this.options.minZoom) return;\n\n        var tileBounds = L.bounds(\n                bounds.min.divideBy(tileSize)._floor(),\n                bounds.max.divideBy(tileSize)._floor()),\n            max = this._map.options.crs.scale(z) / tileSize;\n\n        for (var x = tileBounds.min.x; x <= tileBounds.max.x; x++) {\n            for (var y = tileBounds.min.y; y <= tileBounds.max.y; y++) {\n                // x wrapped\n                this._getTile(z, ((x % max) + max) % max, ((y % max) + max) % max);\n            }\n        }\n    },\n\n    _getTile: function(z, x, y, callback) {\n        var key = z + '_' + x + '_' + y,\n            tilePoint = L.point(x, y);\n\n        tilePoint.z = z;\n\n        if (!this._tileShouldBeLoaded(tilePoint)) {\n            return;\n        }\n\n        if (key in this._cache) {\n            if (!callback) return;\n\n            if (typeof this._cache[key] === 'function') {\n                callback(this._cache[key]); // Already loaded\n            } else {\n                this._cache[key].push(callback); // Pending\n            }\n\n            return;\n        }\n\n        this._cache[key] = [];\n\n        if (callback) {\n            this._cache[key].push(callback);\n        }\n\n        request(this._getTileURL(tilePoint), L.bind(function(err, json) {\n            var callbacks = this._cache[key];\n            this._cache[key] = grid(json);\n            for (var i = 0; i < callbacks.length; ++i) {\n                callbacks[i](this._cache[key]);\n            }\n        }, this));\n    },\n\n    _tileShouldBeLoaded: function(tilePoint) {\n        if (tilePoint.z > this.options.maxZoom || tilePoint.z < this.options.minZoom) {\n            return false;\n        }\n\n        if (this.options.bounds) {\n            var tileSize = 256,\n                nwPoint = tilePoint.multiplyBy(tileSize),\n                sePoint = nwPoint.add(new L.Point(tileSize, tileSize)),\n                nw = this._map.unproject(nwPoint),\n                se = this._map.unproject(sePoint),\n                bounds = new L.LatLngBounds([nw, se]);\n\n            if (!this.options.bounds.intersects(bounds)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n});\n\nmodule.exports.GridLayer = GridLayer;\n\nmodule.exports.gridLayer = function(_, options) {\n    return new GridLayer(_, options);\n};\n\n},{\"./grid\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid.js\",\"./load_tilejson\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/load_tilejson.js\",\"./request\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/request.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/index.js\":[function(require,module,exports){\nrequire('./leaflet');\nrequire('./mapbox');\n\n},{\"./leaflet\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/leaflet.js\",\"./mapbox\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/mapbox.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/info_control.js\":[function(require,module,exports){\n'use strict';\n\nvar InfoControl = L.Control.extend({\n    options: {\n        position: 'bottomright',\n        sanitizer: require('sanitize-caja')\n    },\n\n    initialize: function(options) {\n        L.setOptions(this, options);\n        this._info = {};\n    },\n\n    onAdd: function(map) {\n        this._container = L.DomUtil.create('div', 'mapbox-control-info mapbox-small');\n        this._content = L.DomUtil.create('div', 'map-info-container', this._container);\n\n        var link = L.DomUtil.create('a', 'mapbox-info-toggle mapbox-icon mapbox-icon-info', this._container);\n        link.href = '#';\n\n        L.DomEvent.addListener(link, 'click', this._showInfo, this);\n        L.DomEvent.disableClickPropagation(this._container);\n\n        for (var i in map._layers) {\n            if (map._layers[i].getAttribution) {\n                this.addInfo(map._layers[i].getAttribution());\n            }\n        }\n\n        map\n            .on('layeradd', this._onLayerAdd, this)\n            .on('layerremove', this._onLayerRemove, this);\n\n        this._update();\n        return this._container;\n    },\n\n    onRemove: function(map) {\n        map\n            .off('layeradd', this._onLayerAdd, this)\n            .off('layerremove', this._onLayerRemove, this);\n    },\n\n    addInfo: function(text) {\n        if (!text) return this;\n        if (!this._info[text]) this._info[text] = 0;\n        this._info[text] = true;\n        return this._update();\n    },\n\n    removeInfo: function (text) {\n        if (!text) return this;\n        if (this._info[text]) this._info[text] = false;\n        return this._update();\n    },\n\n    _showInfo: function(e) {\n        L.DomEvent.preventDefault(e);\n        if (this._active === true) return this._hidecontent();\n\n        L.DomUtil.addClass(this._container, 'active');\n        this._active = true;\n        this._update();\n    },\n\n    _hidecontent: function() {\n        this._content.innerHTML = '';\n        this._active = false;\n        L.DomUtil.removeClass(this._container, 'active');\n        return;\n    },\n\n    _update: function() {\n        if (!this._map) { return this; }\n        this._content.innerHTML = '';\n        var hide = 'none';\n        var info = [];\n\n        for (var i in this._info) {\n            if (this._info.hasOwnProperty(i) && this._info[i]) {\n                info.push(this.options.sanitizer(i));\n                hide = 'block';\n            }\n        }\n\n        this._content.innerHTML += info.join(' | ');\n\n        // If there are no results in _info then hide this.\n        this._container.style.display = hide;\n        return this;\n    },\n\n    _onLayerAdd: function(e) {\n        if (e.layer.getAttribution && e.layer.getAttribution()) {\n            this.addInfo(e.layer.getAttribution());\n        } else if ('on' in e.layer && e.layer.getAttribution) {\n            e.layer.on('ready', L.bind(function() {\n                this.addInfo(e.layer.getAttribution());\n            }, this));\n        }\n    },\n\n    _onLayerRemove: function (e) {\n        if (e.layer.getAttribution) {\n            this.removeInfo(e.layer.getAttribution());\n        }\n    }\n});\n\nmodule.exports.InfoControl = InfoControl;\n\nmodule.exports.infoControl = function(options) {\n    return new InfoControl(options);\n};\n\n},{\"sanitize-caja\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/leaflet.js\":[function(require,module,exports){\nwindow.L = require('leaflet/dist/leaflet-src');\n\n},{\"leaflet/dist/leaflet-src\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/leaflet/dist/leaflet-src.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/legend_control.js\":[function(require,module,exports){\n'use strict';\n\nvar LegendControl = L.Control.extend({\n\n    options: {\n        position: 'bottomright',\n        sanitizer: require('sanitize-caja')\n    },\n\n    initialize: function(options) {\n        L.setOptions(this, options);\n        this._legends = {};\n    },\n\n    onAdd: function(map) {\n        this._container = L.DomUtil.create('div', 'map-legends wax-legends');\n        L.DomEvent.disableClickPropagation(this._container);\n\n        this._update();\n\n        return this._container;\n    },\n\n    addLegend: function(text) {\n        if (!text) { return this; }\n\n        if (!this._legends[text]) {\n            this._legends[text] = 0;\n        }\n\n        this._legends[text]++;\n        return this._update();\n    },\n\n    removeLegend: function(text) {\n        if (!text) { return this; }\n        if (this._legends[text]) this._legends[text]--;\n        return this._update();\n    },\n\n    _update: function() {\n        if (!this._map) { return this; }\n\n        this._container.innerHTML = '';\n        var hide = 'none';\n\n        for (var i in this._legends) {\n            if (this._legends.hasOwnProperty(i) && this._legends[i]) {\n                var div = L.DomUtil.create('div', 'map-legend wax-legend', this._container);\n                div.innerHTML = this.options.sanitizer(i);\n                hide = 'block';\n            }\n        }\n\n        // hide the control entirely unless there is at least one legend;\n        // otherwise there will be a small grey blemish on the map.\n        this._container.style.display = hide;\n\n        return this;\n    }\n});\n\nmodule.exports.LegendControl = LegendControl;\n\nmodule.exports.legendControl = function(options) {\n    return new LegendControl(options);\n};\n\n},{\"sanitize-caja\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/load_tilejson.js\":[function(require,module,exports){\n'use strict';\n\nvar request = require('./request'),\n    url = require('./url'),\n    util = require('./util');\n\nmodule.exports = {\n    _loadTileJSON: function(_) {\n        if (typeof _ === 'string') {\n            _ = url.tileJSON(_, this.options && this.options.accessToken);\n            request(_, L.bind(function(err, json) {\n                if (err) {\n                    util.log('could not load TileJSON at ' + _);\n                    this.fire('error', {error: err});\n                } else if (json) {\n                    this._setTileJSON(json);\n                    this.fire('ready');\n                }\n            }, this));\n        } else if (_ && typeof _ === 'object') {\n            this._setTileJSON(_);\n        }\n    }\n};\n\n},{\"./request\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/request.js\",\"./url\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/url.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/map.js\":[function(require,module,exports){\n'use strict';\n\nvar util = require('./util'),\n    tileLayer = require('./tile_layer').tileLayer,\n    featureLayer = require('./feature_layer').featureLayer,\n    gridLayer = require('./grid_layer').gridLayer,\n    gridControl = require('./grid_control').gridControl,\n    infoControl = require('./info_control').infoControl,\n    shareControl = require('./share_control').shareControl,\n    legendControl = require('./legend_control').legendControl,\n    mapboxLogoControl = require('./mapbox_logo').mapboxLogoControl;\n\nfunction withAccessToken(options, accessToken) {\n    if (!accessToken || options.accessToken)\n        return options;\n    return L.extend({accessToken: accessToken}, options);\n}\n\nvar LMap = L.Map.extend({\n    includes: [require('./load_tilejson')],\n\n    options: {\n        tileLayer: {},\n        featureLayer: {},\n        gridLayer: {},\n        legendControl: {},\n        gridControl: {},\n        infoControl: false,\n        shareControl: false\n    },\n\n    _tilejson: {},\n\n    initialize: function(element, _, options) {\n\n        L.Map.prototype.initialize.call(this, element,\n            L.extend({}, L.Map.prototype.options, options));\n\n        // disable the default 'Leaflet' text\n        if (this.attributionControl) this.attributionControl.setPrefix('');\n\n        if (this.options.tileLayer) {\n            this.tileLayer = tileLayer(undefined,\n                withAccessToken(this.options.tileLayer, this.options.accessToken));\n            this.addLayer(this.tileLayer);\n        }\n\n        if (this.options.featureLayer) {\n            this.featureLayer = featureLayer(undefined,\n                withAccessToken(this.options.featureLayer, this.options.accessToken));\n            this.addLayer(this.featureLayer);\n        }\n\n        if (this.options.gridLayer) {\n            this.gridLayer = gridLayer(undefined,\n                withAccessToken(this.options.gridLayer, this.options.accessToken));\n            this.addLayer(this.gridLayer);\n        }\n\n        if (this.options.gridLayer && this.options.gridControl) {\n            this.gridControl = gridControl(this.gridLayer, this.options.gridControl);\n            this.addControl(this.gridControl);\n        }\n\n        if (this.options.infoControl) {\n            this.infoControl = infoControl(this.options.infoControl);\n            this.addControl(this.infoControl);\n        }\n\n        if (this.options.legendControl) {\n            this.legendControl = legendControl(this.options.legendControl);\n            this.addControl(this.legendControl);\n        }\n\n        if (this.options.shareControl) {\n            this.shareControl = shareControl(undefined,\n                withAccessToken(this.options.shareControl, this.options.accessToken));\n            this.addControl(this.shareControl);\n        }\n\n        this._mapboxLogoControl = mapboxLogoControl(this.options.mapboxLogoControl);\n        this.addControl(this._mapboxLogoControl);\n\n        this._loadTileJSON(_);\n    },\n\n    // Update certain properties on 'ready' event\n    addLayer: function(layer) {\n        if ('on' in layer) { layer.on('ready', L.bind(function() { this._updateLayer(layer); }, this)); }\n        return L.Map.prototype.addLayer.call(this, layer);\n    },\n\n    // use a javascript object of tilejson data to configure this layer\n    _setTileJSON: function(_) {\n        this._tilejson = _;\n        this._initialize(_);\n        return this;\n    },\n\n    getTileJSON: function() {\n        return this._tilejson;\n    },\n\n    _initialize: function(json) {\n        if (this.tileLayer) {\n            this.tileLayer._setTileJSON(json);\n            this._updateLayer(this.tileLayer);\n        }\n\n        if (this.featureLayer && !this.featureLayer.getGeoJSON() && json.data && json.data[0]) {\n            this.featureLayer.loadURL(json.data[0]);\n        }\n\n        if (this.gridLayer) {\n            this.gridLayer._setTileJSON(json);\n            this._updateLayer(this.gridLayer);\n        }\n\n        if (this.infoControl && json.attribution) {\n            this.infoControl.addInfo(json.attribution);\n        }\n\n        if (this.legendControl && json.legend) {\n            this.legendControl.addLegend(json.legend);\n        }\n\n        if (this.shareControl) {\n            this.shareControl._setTileJSON(json);\n        }\n\n        this._mapboxLogoControl._setTileJSON(json);\n\n        if (!this._loaded && json.center) {\n            var zoom = this.getZoom() !== undefined ? this.getZoom() : json.center[2],\n                center = L.latLng(json.center[1], json.center[0]);\n\n            this.setView(center, zoom);\n        }\n    },\n\n    _editLink: function() {\n        if (!this._controlContainer.getElementsByClassName) return;\n        var link = this._controlContainer.getElementsByClassName('mapbox-improve-map');\n        if (link.length && this._loaded) {\n            var center = this.getCenter().wrap();\n            var tilejson = this._tilejson || {};\n            var id = tilejson.id || '';\n\n            for (var i = 0; i < link.length; i++) {\n                link[i].href = link[i].href.split('#')[0] + '#' + id + '/' +\n                    center.lng.toFixed(3) + '/' +\n                    center.lat.toFixed(3) + '/' +\n                    this.getZoom();\n            }\n        }\n    },\n\n    _updateLayer: function(layer) {\n        if (!layer.options) return;\n\n        if (this.infoControl && this._loaded) {\n            this.infoControl.addInfo(layer.options.infoControl);\n        }\n\n        if (this.attributionControl && this._loaded && layer.getAttribution) {\n            this.attributionControl.addAttribution(layer.getAttribution());\n        }\n\n        this.on('moveend', this._editLink, this);\n\n        if (!(L.stamp(layer) in this._zoomBoundLayers) &&\n                (layer.options.maxZoom || layer.options.minZoom)) {\n            this._zoomBoundLayers[L.stamp(layer)] = layer;\n        }\n\n        this._editLink();\n        this._updateZoomLevels();\n    }\n});\n\nmodule.exports.Map = LMap;\n\nmodule.exports.map = function(element, _, options) {\n    return new LMap(element, _, options);\n};\n\n},{\"./feature_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/feature_layer.js\",\"./grid_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid_control.js\",\"./grid_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid_layer.js\",\"./info_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/info_control.js\",\"./legend_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/legend_control.js\",\"./load_tilejson\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/load_tilejson.js\",\"./mapbox_logo\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/mapbox_logo.js\",\"./share_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/share_control.js\",\"./tile_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/tile_layer.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/mapbox.js\":[function(require,module,exports){\n'use strict';\n\nvar geocoderControl = require('./geocoder_control'),\n    gridControl = require('./grid_control'),\n    featureLayer = require('./feature_layer'),\n    legendControl = require('./legend_control'),\n    shareControl = require('./share_control'),\n    tileLayer = require('./tile_layer'),\n    infoControl = require('./info_control'),\n    map = require('./map'),\n    gridLayer = require('./grid_layer');\n\nL.mapbox = module.exports = {\n    VERSION: require('../package.json').version,\n    geocoder: require('./geocoder'),\n    marker: require('./marker'),\n    simplestyle: require('./simplestyle'),\n    tileLayer: tileLayer.tileLayer,\n    TileLayer: tileLayer.TileLayer,\n    infoControl: infoControl.infoControl,\n    InfoControl: infoControl.InfoControl,\n    shareControl: shareControl.shareControl,\n    ShareControl: shareControl.ShareControl,\n    legendControl: legendControl.legendControl,\n    LegendControl: legendControl.LegendControl,\n    geocoderControl: geocoderControl.geocoderControl,\n    GeocoderControl: geocoderControl.GeocoderControl,\n    gridControl: gridControl.gridControl,\n    GridControl: gridControl.GridControl,\n    gridLayer: gridLayer.gridLayer,\n    GridLayer: gridLayer.GridLayer,\n    featureLayer: featureLayer.featureLayer,\n    FeatureLayer: featureLayer.FeatureLayer,\n    map: map.map,\n    Map: map.Map,\n    config: require('./config'),\n    sanitize: require('sanitize-caja'),\n    template: require('mustache').to_html\n};\n\n\n// Hardcode image path, because Leaflet's autodetection\n// fails, because mapbox.js is not named leaflet.js\nwindow.L.Icon.Default.imagePath =\n    // Detect bad-news protocols like file:// and hardcode\n    // to https if they're detected.\n    ((document.location.protocol == 'https:' ||\n    document.location.protocol == 'http:') ? '' : 'https:') +\n    '//api.tiles.mapbox.com/mapbox.js/' + 'v' +\n    require('../package.json').version + '/images';\n\n},{\"../package.json\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/package.json\",\"./config\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/config.js\",\"./feature_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/feature_layer.js\",\"./geocoder\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/geocoder.js\",\"./geocoder_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/geocoder_control.js\",\"./grid_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid_control.js\",\"./grid_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/grid_layer.js\",\"./info_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/info_control.js\",\"./legend_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/legend_control.js\",\"./map\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/map.js\",\"./marker\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/marker.js\",\"./share_control\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/share_control.js\",\"./simplestyle\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/simplestyle.js\",\"./tile_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/tile_layer.js\",\"mustache\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/mustache/mustache.js\",\"sanitize-caja\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/mapbox_logo.js\":[function(require,module,exports){\n'use strict';\n\nvar MapboxLogoControl = L.Control.extend({\n\n    options: {\n        position: 'bottomleft',\n    },\n\n    initialize: function(options) {\n        L.setOptions(this, options);\n    },\n\n    onAdd: function(map) {\n        this._container = L.DomUtil.create('div', 'mapbox-logo');\n        return this._container;\n    },\n\n    _setTileJSON: function(json) {\n        // Check if account referenced by the accessToken\n        // is asscociated with the Mapbox Logo\n        // as determined by mapbox-maps.\n        if (json.mapbox_logo) {\n            L.DomUtil.addClass(this._container, 'mapbox-logo-true');\n        }\n    }\n});\n\nmodule.exports.MapboxLogoControl = MapboxLogoControl;\n\nmodule.exports.mapboxLogoControl = function(options) {\n    return new MapboxLogoControl(options);\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/marker.js\":[function(require,module,exports){\n'use strict';\n\nvar url = require('./url'),\n    util = require('./util'),\n    sanitize = require('sanitize-caja');\n\n// mapbox-related markers functionality\n// provide an icon from mapbox's simple-style spec and hosted markers\n// service\nfunction icon(fp, options) {\n    fp = fp || {};\n\n    var sizes = {\n            small: [20, 50],\n            medium: [30, 70],\n            large: [35, 90]\n        },\n        size = fp['marker-size'] || 'medium',\n        symbol = ('marker-symbol' in fp && fp['marker-symbol'] !== '') ? '-' + fp['marker-symbol'] : '',\n        color = (fp['marker-color'] || '7e7e7e').replace('#', '');\n\n    return L.icon({\n        iconUrl: url('/marker/' +\n            'pin-' + size.charAt(0) + symbol + '+' + color +\n            // detect and use retina markers, which are x2 resolution\n            (L.Browser.retina ? '@2x' : '') + '.png', options && options.accessToken),\n        iconSize: sizes[size],\n        iconAnchor: [sizes[size][0] / 2, sizes[size][1] / 2],\n        popupAnchor: [0, -sizes[size][1] / 2]\n    });\n}\n\n// a factory that provides markers for Leaflet from Mapbox's\n// [simple-style specification](https://github.com/mapbox/simplestyle-spec)\n// and [Markers API](http://mapbox.com/developers/api/#markers).\nfunction style(f, latlon, options) {\n    return L.marker(latlon, {\n        icon: icon(f.properties, options),\n        title: util.strip_tags(\n            sanitize((f.properties && f.properties.title) || ''))\n    });\n}\n\n// Sanitize and format properties of a GeoJSON Feature object in order\n// to form the HTML string used as the argument for `L.createPopup`\nfunction createPopup(f, sanitizer) {\n    if (!f || !f.properties) return '';\n    var popup = '';\n\n    if (f.properties.title) {\n        popup += '<div class=\"marker-title\">' + f.properties.title + '</div>';\n    }\n\n    if (f.properties.description) {\n        popup += '<div class=\"marker-description\">' + f.properties.description + '</div>';\n    }\n\n    return (sanitizer || sanitize)(popup);\n}\n\nmodule.exports = {\n    icon: icon,\n    style: style,\n    createPopup: createPopup\n};\n\n},{\"./url\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/url.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\",\"sanitize-caja\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/sanitize-caja/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/request.js\":[function(require,module,exports){\n'use strict';\n\nvar corslite = require('corslite'),\n    strict = require('./util').strict,\n    config = require('./config'),\n    protocol = /^(https?:)?(?=\\/\\/(.|api)\\.tiles\\.mapbox\\.com\\/)/;\n\nmodule.exports = function(url, callback) {\n    strict(url, 'string');\n    strict(callback, 'function');\n\n    url = url.replace(protocol, function(match, protocol) {\n        if (!('withCredentials' in new window.XMLHttpRequest())) {\n            // XDomainRequest in use; doesn't support cross-protocol requests\n            return document.location.protocol;\n        } else if ('https:' === protocol || 'https:' === document.location.protocol || config.FORCE_HTTPS) {\n            return 'https:';\n        } else {\n            return 'http:';\n        }\n    });\n\n    return corslite(url, onload);\n    function onload(err, resp) {\n        if (!err && resp) {\n            resp = JSON.parse(resp.responseText);\n        }\n        callback(err, resp);\n    }\n};\n\n},{\"./config\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/config.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\",\"corslite\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/node_modules/corslite/corslite.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/share_control.js\":[function(require,module,exports){\n'use strict';\n\nvar urlhelper = require('./url');\n\nvar ShareControl = L.Control.extend({\n    includes: [require('./load_tilejson')],\n\n    options: {\n        position: 'topleft',\n        url: ''\n    },\n\n    initialize: function(_, options) {\n        L.setOptions(this, options);\n        this._loadTileJSON(_);\n    },\n\n    _setTileJSON: function(json) {\n        this._tilejson = json;\n    },\n\n    onAdd: function(map) {\n        this._map = map;\n\n        var container = L.DomUtil.create('div', 'leaflet-control-mapbox-share leaflet-bar');\n        var link = L.DomUtil.create('a', 'mapbox-share mapbox-icon mapbox-icon-share', container);\n        link.href = '#';\n\n        this._modal = L.DomUtil.create('div', 'mapbox-modal', this._map._container);\n        this._mask = L.DomUtil.create('div', 'mapbox-modal-mask', this._modal);\n        this._content = L.DomUtil.create('div', 'mapbox-modal-content', this._modal);\n\n        L.DomEvent.addListener(link, 'click', this._shareClick, this);\n        L.DomEvent.disableClickPropagation(container);\n\n        this._map.on('mousedown', this._clickOut, this);\n\n        return container;\n    },\n\n    _clickOut: function(e) {\n        if (this._sharing) {\n            L.DomEvent.preventDefault(e);\n            L.DomUtil.removeClass(this._modal, 'active');\n            this._content.innerHTML = '';\n            this._sharing = null;\n            return;\n        }\n    },\n\n    _shareClick: function(e) {\n        L.DomEvent.stop(e);\n        if (this._sharing) return this._clickOut(e);\n\n        var tilejson = this._tilejson || this._map._tilejson || {},\n            url = encodeURIComponent(this.options.url || tilejson.webpage || window.location),\n            name = encodeURIComponent(tilejson.name),\n            image = urlhelper('/' + tilejson.id + '/' + this._map.getCenter().lng + ',' + this._map.getCenter().lat + ',' + this._map.getZoom() + '/600x600.png', this.options.accessToken),\n            embed = urlhelper('/' + tilejson.id + '.html', this.options.accessToken),\n            twitter = '//twitter.com/intent/tweet?status=' + name + ' ' + url,\n            facebook = '//www.facebook.com/sharer.php?u=' + url + '&t=' + encodeURIComponent(tilejson.name),\n            pinterest = '//www.pinterest.com/pin/create/button/?url=' + url + '&media=' + image + '&description=' + tilejson.name,\n            share = (\"<h3>Share this map</h3>\" +\n                    \"<div class='mapbox-share-buttons'><a class='mapbox-button mapbox-button-icon mapbox-icon-facebook' target='_blank' href='{{facebook}}'>Facebook</a>\" +\n                    \"<a class='mapbox-button mapbox-button-icon mapbox-icon-twitter' target='_blank' href='{{twitter}}'>Twitter</a>\" +\n                    \"<a class='mapbox-button mapbox-button-icon mapbox-icon-pinterest' target='_blank' href='{{pinterest}}'>Pinterest</a></div>\")\n                    .replace('{{twitter}}', twitter)\n                    .replace('{{facebook}}', facebook)\n                    .replace('{{pinterest}}', pinterest),\n            embedValue = '<iframe width=\"100%\" height=\"500px\" frameBorder=\"0\" src=\"{{embed}}\"></iframe>'.replace('{{embed}}', embed),\n            embedLabel = 'Copy and paste this <strong>HTML code</strong> into documents to embed this map on web pages.';\n\n        L.DomUtil.addClass(this._modal, 'active');\n\n        this._sharing = L.DomUtil.create('div', 'mapbox-modal-body', this._content);\n        this._sharing.innerHTML = share;\n\n        var input = L.DomUtil.create('input', 'mapbox-embed', this._sharing);\n        input.type = 'text';\n        input.value = embedValue;\n\n        var label = L.DomUtil.create('label', 'mapbox-embed-description', this._sharing);\n        label.innerHTML = embedLabel;\n\n        var close = L.DomUtil.create('a', 'leaflet-popup-close-button', this._sharing);\n        close.href = '#';\n\n        L.DomEvent.disableClickPropagation(this._sharing);\n        L.DomEvent.addListener(close, 'click', this._clickOut, this);\n        L.DomEvent.addListener(input, 'click', function(e) {\n            e.target.focus();\n            e.target.select();\n        });\n    }\n});\n\nmodule.exports.ShareControl = ShareControl;\n\nmodule.exports.shareControl = function(_, options) {\n    return new ShareControl(_, options);\n};\n\n},{\"./load_tilejson\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/load_tilejson.js\",\"./url\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/url.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/simplestyle.js\":[function(require,module,exports){\n'use strict';\n\n// an implementation of the simplestyle spec for polygon and linestring features\n// https://github.com/mapbox/simplestyle-spec\nvar defaults = {\n    stroke: '#555555',\n    'stroke-width': 2,\n    'stroke-opacity': 1,\n    fill: '#555555',\n    'fill-opacity': 0.5\n};\n\nvar mapping = [\n    ['stroke', 'color'],\n    ['stroke-width', 'weight'],\n    ['stroke-opacity', 'opacity'],\n    ['fill', 'fillColor'],\n    ['fill-opacity', 'fillOpacity']\n];\n\nfunction fallback(a, b) {\n    var c = {};\n    for (var k in b) {\n        if (a[k] === undefined) c[k] = b[k];\n        else c[k] = a[k];\n    }\n    return c;\n}\n\nfunction remap(a) {\n    var d = {};\n    for (var i = 0; i < mapping.length; i++) {\n        d[mapping[i][1]] = a[mapping[i][0]];\n    }\n    return d;\n}\n\nfunction style(feature) {\n    return remap(fallback(feature.properties || {}, defaults));\n}\n\nmodule.exports = {\n    style: style,\n    defaults: defaults\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/tile_layer.js\":[function(require,module,exports){\n'use strict';\n\nvar util = require('./util');\n\nvar TileLayer = L.TileLayer.extend({\n    includes: [require('./load_tilejson')],\n\n    options: {\n        format: 'png'\n    },\n\n    // http://mapbox.com/developers/api/#image_quality\n    formats: [\n        'png',\n        // PNG\n        'png32', 'png64', 'png128', 'png256',\n        // JPG\n        'jpg70', 'jpg80', 'jpg90'],\n\n    scalePrefix: '@2x.',\n\n    initialize: function(_, options) {\n        L.TileLayer.prototype.initialize.call(this, undefined, options);\n\n        this._tilejson = {};\n\n        if (options && options.format) {\n            util.strict_oneof(options.format, this.formats);\n        }\n\n        this._loadTileJSON(_);\n    },\n\n    setFormat: function(_) {\n        util.strict(_, 'string');\n        this.options.format = _;\n        this.redraw();\n        return this;\n    },\n\n    // disable the setUrl function, which is not available on mapbox tilelayers\n    setUrl: null,\n\n    _setTileJSON: function(json) {\n        util.strict(json, 'object');\n\n        L.extend(this.options, {\n            tiles: json.tiles,\n            attribution: json.attribution,\n            minZoom: json.minzoom || 0,\n            maxZoom: json.maxzoom || 18,\n            tms: json.scheme === 'tms',\n            bounds: json.bounds && util.lbounds(json.bounds)\n        });\n\n        this._tilejson = json;\n        this.redraw();\n        return this;\n    },\n\n    getTileJSON: function() {\n        return this._tilejson;\n    },\n\n    // this is an exception to mapbox.js naming rules because it's called\n    // by `L.map`\n    getTileUrl: function(tilePoint) {\n        var tiles = this.options.tiles,\n            index = Math.floor(Math.abs(tilePoint.x + tilePoint.y) % tiles.length),\n            url = tiles[index];\n\n        var templated = L.Util.template(url, tilePoint);\n        if (!templated) {\n            return templated;\n        } else {\n            return templated.replace('.png',\n                (L.Browser.retina ? this.scalePrefix : '.') + this.options.format);\n        }\n    },\n\n    // TileJSON.TileLayers are added to the map immediately, so that they get\n    // the desired z-index, but do not update until the TileJSON has been loaded.\n    _update: function() {\n        if (this.options.tiles) {\n            L.TileLayer.prototype._update.call(this);\n        }\n    }\n});\n\nmodule.exports.TileLayer = TileLayer;\n\nmodule.exports.tileLayer = function(_, options) {\n    return new TileLayer(_, options);\n};\n\n},{\"./load_tilejson\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/load_tilejson.js\",\"./util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/url.js\":[function(require,module,exports){\n'use strict';\n\nvar config = require('./config'),\n    version = require('../package.json').version;\n\nmodule.exports = function(path, accessToken) {\n    accessToken = accessToken || L.mapbox.accessToken;\n\n    if (!accessToken && config.REQUIRE_ACCESS_TOKEN) {\n        throw new Error('An API access token is required to use Mapbox.js. ' +\n            'See https://www.mapbox.com/mapbox.js/api/v' + version + '/api-access-tokens/');\n    }\n\n    var url = ('https:' === document.location.protocol || config.FORCE_HTTPS) ? config.HTTPS_URL : config.HTTP_URL;\n    url += path;\n    url += url.indexOf('?') !== -1 ? '&access_token=' : '?access_token=';\n\n    if (config.REQUIRE_ACCESS_TOKEN) {\n        if (accessToken[0] === 's') {\n            throw new Error('Use a public access token (pk.*) with Mapbox.js, not a secret access token (sk.*). ' +\n                'See https://www.mapbox.com/mapbox.js/api/v' + version + '/api-access-tokens/');\n        }\n\n        url += accessToken;\n    }\n\n    return url;\n};\n\nmodule.exports.tileJSON = function(urlOrMapID, accessToken) {\n    if (urlOrMapID.indexOf('/') !== -1)\n        return urlOrMapID;\n\n    var url = module.exports('/' + urlOrMapID + '.json', accessToken);\n\n    // TileJSON requests need a secure flag appended to their URLs so\n    // that the server knows to send SSL-ified resource references.\n    if (url.indexOf('https') === 0)\n        url += '&secure';\n\n    return url;\n};\n\n},{\"../package.json\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/package.json\",\"./config\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/config.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/mapbox.js/src/util.js\":[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n    idUrl: function(_, t) {\n        if (_.indexOf('/') == -1) t.loadID(_);\n        else t.loadURL(_);\n    },\n    log: function(_) {\n        if (typeof console === 'object' &&\n            typeof console.error === 'function') {\n            console.error(_);\n        }\n    },\n    strict: function(_, type) {\n        if (typeof _ !== type) {\n            throw new Error('Invalid argument: ' + type + ' expected');\n        }\n    },\n    strict_instance: function(_, klass, name) {\n        if (!(_ instanceof klass)) {\n            throw new Error('Invalid argument: ' + name + ' expected');\n        }\n    },\n    strict_oneof: function(_, values) {\n        if (!contains(_, values)) {\n            throw new Error('Invalid argument: ' + _ + ' given, valid values are ' +\n                values.join(', '));\n        }\n    },\n    strip_tags: function(_) {\n        return _.replace(/<[^<]+>/g, '');\n    },\n    lbounds: function(_) {\n        // leaflet-compatible bounds, since leaflet does not do geojson\n        return new L.LatLngBounds([[_[1], _[0]], [_[3], _[2]]]);\n    }\n};\n\nfunction contains(item, list) {\n    if (!list || !list.length) return false;\n    for (var i = 0; i < list.length; i++) {\n        if (list[i] == item) return true;\n    }\n    return false;\n}\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/animator.js\":[function(require,module,exports){\n(function (global){\nvar torque = require('./');\n\nvar requestAnimationFrame = global.requestAnimationFrame\n    || global.mozRequestAnimationFrame\n    || global.webkitRequestAnimationFrame\n    || global.msRequestAnimationFrame\n    || function(callback) { return global.setTimeout(callback, 1000 / 60); };\n\nvar cancelAnimationFrame = global.cancelAnimationFrame\n    || global.mozCancelAnimationFrame\n    || global.webkitCancelAnimationFrame\n    || global.msCancelAnimationFrame\n    || function(id) { clearTimeout(id); };\n\n  /**\n   * options:\n   *    animationDuration in seconds\n   *    animationDelay in seconds\n   */\n  function Animator(callback, options) {\n    if(!options.steps) {\n      throw new Error(\"steps option missing\")\n    }\n    this.options = options;\n    this.running = false;\n    this._tick = this._tick.bind(this);\n    this._t0 = +new Date();\n    this.callback = callback;\n    this._time = 0.0;\n    this.itemsReady = false;\n\n    this.options = torque.extend({\n        animationDelay: 0,\n        maxDelta: 0.2,\n        loop: options.loop === undefined ? true : options.loop\n    }, this.options);\n\n    this.rescale();\n\n  }\n\n\n  Animator.prototype = {\n\n    start: function() {\n        this.running = true;\n        requestAnimationFrame(this._tick);\n        this.options.onStart && this.options.onStart();\n        if(this.options.steps === 1){\n          this.running = false;\n        }\n    },\n\n    isRunning: function() {\n      return this.running;\n    },\n\n    stop: function() {\n      this.pause();\n      this.time(0);\n      this.options.onStop && this.options.onStop();\n    },\n\n    // real animation time\n    time: function(_) {\n      if (!arguments.length) return this._time;\n      this._time = _;\n      var t = this.range(this.domain(this._time));\n      this.callback(t);\n    },\n\n    toggle: function() {\n      if (this.running) {\n        this.pause()\n      } else {\n        this.start()\n      }\n    },\n\n    rescale: function() {\n      this.domainInv = torque.math.linear(this.options.animationDelay, this.options.animationDelay + this.options.animationDuration);\n      this.domain = this.domainInv.invert();\n      this.range = torque.math.linear(0, this.options.steps);\n      this.rangeInv = this.range.invert();\n      this.time(this._time);\n      this.start();\n      return this;\n    },\n\n    duration: function(_) {\n      if (!arguments.length)  return this.options.animationDuration;\n      this.options.animationDuration = _;\n      if (this.time() > _) {\n        this.time(0);\n      }\n      this.rescale();\n      return this;\n    },\n\n    steps: function(_) {\n      this.options.steps = _;\n      return this.rescale();\n    },\n\n    step: function(s) {\n      if(arguments.length === 0) return this.range(this.domain(this._time));\n      this._time = this.domainInv(this.rangeInv(s));\n    },\n\n    pause: function() {\n      this.running = false;\n      cancelAnimationFrame(this._tick);\n      this.options.onPause && this.options.onPause();\n    },\n\n    _tick: function() {\n      var t1 = +new Date();\n      var delta = (t1 - this._t0)*0.001;\n      // if delta is really big means the tab lost the focus\n      // at some point, so limit delta change\n      delta = Math.min(this.options.maxDelta, delta);\n      this._t0 = t1;\n      this._time += delta;\n      if(this.step() >= this.options.steps) {\n        if(!this.options.loop){\n          // set time to max time\n          this.time(this.options.animationDuration);\n          this.pause();\n        } else {\n          this._time = 0;\n        }\n      }\n      if(this.running) {\n        this.time(this._time);\n        requestAnimationFrame(this._tick);\n      }\n    }\n\n  };\n\nmodule.exports = Animator;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/cartocss_reference.js\":[function(require,module,exports){\nvar _torque_reference_latest = {\n    \"version\": \"1.0.0\",\n    \"style\": {\n        \"comp-op\": {\n            \"css\": \"comp-op\",\n            \"default-value\": \"src-over\",\n            \"default-meaning\": \"add the current layer on top of other layers\",\n            \"doc\": \"Composite operation. This defines how this layer should behave relative to layers atop or below it.\",\n            \"type\": [\n                \"src\", //\n                \"src-over\", //\n                \"dst-over\", //\n                \"src-in\", //\n                \"dst-in\", //\n                \"src-out\", //\n                \"dst-out\", //\n                \"src-atop\", //\n                \"dst-atop\", //\n                \"xor\", //\n                \"darken\", //\n                \"lighten\" //\n            ]\n        }\n    },\n    \"layer\" : {\n        \"buffer-size\": {\n            \"default-value\": \"0\",\n            \"type\":\"float\",\n            \"default-meaning\": \"No buffer will be used\",\n            \"doc\": \"Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering\"\n        },\n        \"-torque-clear-color\": {\n            \"css\": \"-torque-clear-color\",\n            \"type\": \"color\",\n            \"default-value\": \"rgba(255, 255, 255, 0)\",\n            \"default-meaning\": \"full clear\",\n            \"doc\": \"color used to clear canvas on each frame\"\n        },\n        \"-torque-frame-count\": {\n            \"css\": \"-torque-frame-count\",\n            \"default-value\": \"128\",\n            \"type\":\"number\",\n            \"default-meaning\": \"the data is broken into 128 time frames\",\n            \"doc\": \"Number of animation steps/frames used in the animation. If the data contains a fewere number of total frames, the lesser value will be used.\"\n        },\n        \"-torque-resolution\": {\n            \"css\": \"-torque-resolution\",\n            \"default-value\": \"2\",\n            \"type\":\"number\",\n            \"default-meaning\": \"\",\n            \"doc\": \"Spatial resolution in pixels. A resolution of 1 means no spatial aggregation of the data. Any other resolution of N results in spatial aggregation into cells of NxN pixels. The value N must be power of 2\"\n        },\n        \"-torque-animation-duration\": {\n            \"css\": \"-torque-animation-duration\",\n            \"default-value\": \"30\",\n            \"type\":\"number\",\n            \"default-meaning\": \"the animation lasts 30 seconds\",\n            \"doc\": \"Animation duration in seconds\"\n        },\n        \"-torque-aggregation-function\": {\n            \"css\": \"-torque-aggregation-function\",\n            \"default-value\": \"count(cartodb_id)\",\n            \"type\": \"string\",\n            \"default-meaning\": \"the value for each cell is the count of points in that cell\",\n            \"doc\": \"A function used to calculate a value from the aggregate data for each cell. See -torque-resolution\"\n        },\n        \"-torque-time-attribute\": {\n            \"css\": \"-torque-time-attribute\",\n            \"default-value\": \"time\",\n            \"type\": \"string\",\n            \"default-meaning\": \"the data column in your table that is of a time based type\",\n            \"doc\": \"The table column that contains the time information used create the animation\"\n        },\n        \"-torque-data-aggregation\": {\n            \"css\": \"-torque-data-aggregation\",\n            \"default-value\": \"linear\",\n            \"type\": [\n              \"cumulative\"\n            ],\n            \"default-meaning\": \"previous values are discarded\",\n            \"doc\": \"A linear animation will discard previous values while a cumulative animation will accumulate them until it restarts\"\n        }\n    },\n    \"symbolizers\" : {\n        \"*\": {\n            \"comp-op\": {\n                \"css\": \"comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current layer on top of other layers\",\n                \"doc\": \"Composite operation. This defines how this layer should behave relative to layers atop or below it.\",\n                \"type\": [\n                  \"src\", //\n                  \"src-over\", //\n                  \"dst-over\", //\n                  \"src-in\", //\n                  \"dst-in\", //\n                  \"src-out\", //\n                  \"dst-out\", //\n                  \"src-atop\", //\n                  \"dst-atop\", //\n                  \"xor\", //\n                  \"darken\", //\n                  \"lighten\" //\n                ]\n            },\n            \"opacity\": {\n                \"css\": \"opacity\",\n                \"type\": \"float\",\n                \"doc\": \"An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)\",\n                \"default-value\": 1,\n                \"default-meaning\": \"no separate buffer will be used and no alpha will be applied to the style after rendering\"\n            }\n        },\n        \"trail\": {\n          \"steps\": {\n            \"css\": \"trail-steps\",\n            \"type\": \"float\",\n            \"default-value\": 1,\n            \"default-meaning\": \"no trail steps\",\n            \"doc\": \"How many steps of trails are going to be rendered\"\n          }\n        },\n        \"polygon\": {\n            \"fill\": {\n                \"css\": \"polygon-fill\",\n                \"type\": \"color\",\n                \"default-value\": \"rgba(128,128,128,1)\",\n                \"default-meaning\": \"gray and fully opaque (alpha = 1), same as rgb(128,128,128)\",\n                \"doc\": \"Fill color to assign to a polygon\"\n            },\n            \"fill-opacity\": {\n                \"css\": \"polygon-opacity\",\n                \"type\": \"float\",\n                \"doc\": \"The opacity of the polygon\",\n                \"default-value\": 1,\n                \"default-meaning\": \"opaque\"\n            }\n        },\n        \"line\": {\n            \"stroke\": {\n                \"css\": \"line-color\",\n                \"default-value\": \"rgba(0,0,0,1)\",\n                \"type\": \"color\",\n                \"default-meaning\": \"black and fully opaque (alpha = 1), same as rgb(0,0,0)\",\n                \"doc\": \"The color of a drawn line\"\n            },\n            \"stroke-width\": {\n                \"css\": \"line-width\",\n                \"default-value\": 1,\n                \"type\": \"float\",\n                \"doc\": \"The width of a line in pixels\"\n            },\n            \"stroke-opacity\": {\n                \"css\": \"line-opacity\",\n                \"default-value\": 1,\n                \"type\": \"float\",\n                \"default-meaning\": \"opaque\",\n                \"doc\": \"The opacity of a line\"\n            },\n            \"stroke-linejoin\": {\n                \"css\": \"line-join\",\n                \"default-value\": \"miter\",\n                \"type\": [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ],\n                \"doc\": \"The behavior of lines when joining\"\n            },\n            \"stroke-linecap\": {\n                \"css\": \"line-cap\",\n                \"default-value\": \"butt\",\n                \"type\": [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ],\n                \"doc\": \"The display of line endings\"\n            }\n        },\n        \"markers\": {\n            \"file\": {\n                \"css\": \"marker-file\",\n                \"doc\": \"An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.\",\n                \"default-value\": \"\",\n                \"default-meaning\": \"An ellipse or circle, if width equals height\",\n                \"type\": \"uri\"\n            },\n            \"opacity\": {\n                \"css\": \"marker-opacity\",\n                \"doc\": \"The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke\",\n                \"default-value\": 1,\n                \"default-meaning\": \"The stroke-opacity and fill-opacity will be used\",\n                \"type\": \"float\"\n            },\n            \"fill-opacity\": {\n                \"css\": \"marker-fill-opacity\",\n                \"doc\": \"The fill opacity of the marker\",\n                \"default-value\": 1,\n                \"default-meaning\": \"opaque\",\n                \"type\": \"float\"\n            },\n            \"stroke\": {\n                \"css\": \"marker-line-color\",\n                \"doc\": \"The color of the stroke around a marker shape.\",\n                \"default-value\": \"black\",\n                \"type\": \"color\"\n            },\n            \"stroke-width\": {\n                \"css\": \"marker-line-width\",\n                \"doc\": \"The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.\",\n                \"type\": \"float\"\n            },\n            \"stroke-opacity\": {\n                \"css\": \"marker-line-opacity\",\n                \"default-value\": 1,\n                \"default-meaning\": \"opaque\",\n                \"doc\": \"The opacity of a line\",\n                \"type\": \"float\"\n            },\n            \"fill\": {\n                \"css\": \"marker-fill\",\n                \"default-value\": \"blue\",\n                \"doc\": \"The color of the area of the marker.\",\n                \"type\": \"color\"\n            },\n            \"marker-type\": {\n                \"css\": \"marker-type\",\n                \"type\": [\n                    \"rectangle\",\n                    \"ellipse\"\n                ],\n                \"default-value\": \"ellipse\",\n                \"doc\": \"The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an rectangle or an ellipse (a circle if height is equal to width)\"\n            },\n             \"width\": {\n                \"css\": \"marker-width\",\n                \"default-value\": 10,\n                \"doc\": \"The width of the marker, if using one of the default types.\",\n                \"type\": \"float\"\n            }\n        },\n        \"point\": {\n            \"file\": {\n                \"css\": \"point-file\",\n                \"type\": \"uri\",\n                \"required\": false,\n                \"default-value\": \"none\",\n                \"doc\": \"Image file to represent a point\"\n            },\n            \"opacity\": {\n                \"css\": \"point-opacity\",\n                \"type\": \"float\",\n                \"default-value\": 1.0,\n                \"default-meaning\": \"Fully opaque\",\n                \"doc\": \"A value from 0 to 1 to control the opacity of the point\"\n            }\n        }\n    },\n    \"colors\": {\n        \"aliceblue\":  [240, 248, 255],\n        \"antiquewhite\":  [250, 235, 215],\n        \"aqua\":  [0, 255, 255],\n        \"aquamarine\":  [127, 255, 212],\n        \"azure\":  [240, 255, 255],\n        \"beige\":  [245, 245, 220],\n        \"bisque\":  [255, 228, 196],\n        \"black\":  [0, 0, 0],\n        \"blanchedalmond\":  [255,235,205],\n        \"blue\":  [0, 0, 255],\n        \"blueviolet\":  [138, 43, 226],\n        \"brown\":  [165, 42, 42],\n        \"burlywood\":  [222, 184, 135],\n        \"cadetblue\":  [95, 158, 160],\n        \"chartreuse\":  [127, 255, 0],\n        \"chocolate\":  [210, 105, 30],\n        \"coral\":  [255, 127, 80],\n        \"cornflowerblue\":  [100, 149, 237],\n        \"cornsilk\":  [255, 248, 220],\n        \"crimson\":  [220, 20, 60],\n        \"cyan\":  [0, 255, 255],\n        \"darkblue\":  [0, 0, 139],\n        \"darkcyan\":  [0, 139, 139],\n        \"darkgoldenrod\":  [184, 134, 11],\n        \"darkgray\":  [169, 169, 169],\n        \"darkgreen\":  [0, 100, 0],\n        \"darkgrey\":  [169, 169, 169],\n        \"darkkhaki\":  [189, 183, 107],\n        \"darkmagenta\":  [139, 0, 139],\n        \"darkolivegreen\":  [85, 107, 47],\n        \"darkorange\":  [255, 140, 0],\n        \"darkorchid\":  [153, 50, 204],\n        \"darkred\":  [139, 0, 0],\n        \"darksalmon\":  [233, 150, 122],\n        \"darkseagreen\":  [143, 188, 143],\n        \"darkslateblue\":  [72, 61, 139],\n        \"darkslategrey\":  [47, 79, 79],\n        \"darkturquoise\":  [0, 206, 209],\n        \"darkviolet\":  [148, 0, 211],\n        \"deeppink\":  [255, 20, 147],\n        \"deepskyblue\":  [0, 191, 255],\n        \"dimgray\":  [105, 105, 105],\n        \"dimgrey\":  [105, 105, 105],\n        \"dodgerblue\":  [30, 144, 255],\n        \"firebrick\":  [178, 34, 34],\n        \"floralwhite\":  [255, 250, 240],\n        \"forestgreen\":  [34, 139, 34],\n        \"fuchsia\":  [255, 0, 255],\n        \"gainsboro\":  [220, 220, 220],\n        \"ghostwhite\":  [248, 248, 255],\n        \"gold\":  [255, 215, 0],\n        \"goldenrod\":  [218, 165, 32],\n        \"gray\":  [128, 128, 128],\n        \"grey\":  [128, 128, 128],\n        \"green\":  [0, 128, 0],\n        \"greenyellow\":  [173, 255, 47],\n        \"honeydew\":  [240, 255, 240],\n        \"hotpink\":  [255, 105, 180],\n        \"indianred\":  [205, 92, 92],\n        \"indigo\":  [75, 0, 130],\n        \"ivory\":  [255, 255, 240],\n        \"khaki\":  [240, 230, 140],\n        \"lavender\":  [230, 230, 250],\n        \"lavenderblush\":  [255, 240, 245],\n        \"lawngreen\":  [124, 252, 0],\n        \"lemonchiffon\":  [255, 250, 205],\n        \"lightblue\":  [173, 216, 230],\n        \"lightcoral\":  [240, 128, 128],\n        \"lightcyan\":  [224, 255, 255],\n        \"lightgoldenrodyellow\":  [250, 250, 210],\n        \"lightgray\":  [211, 211, 211],\n        \"lightgreen\":  [144, 238, 144],\n        \"lightgrey\":  [211, 211, 211],\n        \"lightpink\":  [255, 182, 193],\n        \"lightsalmon\":  [255, 160, 122],\n        \"lightseagreen\":  [32, 178, 170],\n        \"lightskyblue\":  [135, 206, 250],\n        \"lightslategray\":  [119, 136, 153],\n        \"lightslategrey\":  [119, 136, 153],\n        \"lightsteelblue\":  [176, 196, 222],\n        \"lightyellow\":  [255, 255, 224],\n        \"lime\":  [0, 255, 0],\n        \"limegreen\":  [50, 205, 50],\n        \"linen\":  [250, 240, 230],\n        \"magenta\":  [255, 0, 255],\n        \"maroon\":  [128, 0, 0],\n        \"mediumaquamarine\":  [102, 205, 170],\n        \"mediumblue\":  [0, 0, 205],\n        \"mediumorchid\":  [186, 85, 211],\n        \"mediumpurple\":  [147, 112, 219],\n        \"mediumseagreen\":  [60, 179, 113],\n        \"mediumslateblue\":  [123, 104, 238],\n        \"mediumspringgreen\":  [0, 250, 154],\n        \"mediumturquoise\":  [72, 209, 204],\n        \"mediumvioletred\":  [199, 21, 133],\n        \"midnightblue\":  [25, 25, 112],\n        \"mintcream\":  [245, 255, 250],\n        \"mistyrose\":  [255, 228, 225],\n        \"moccasin\":  [255, 228, 181],\n        \"navajowhite\":  [255, 222, 173],\n        \"navy\":  [0, 0, 128],\n        \"oldlace\":  [253, 245, 230],\n        \"olive\":  [128, 128, 0],\n        \"olivedrab\":  [107, 142, 35],\n        \"orange\":  [255, 165, 0],\n        \"orangered\":  [255, 69, 0],\n        \"orchid\":  [218, 112, 214],\n        \"palegoldenrod\":  [238, 232, 170],\n        \"palegreen\":  [152, 251, 152],\n        \"paleturquoise\":  [175, 238, 238],\n        \"palevioletred\":  [219, 112, 147],\n        \"papayawhip\":  [255, 239, 213],\n        \"peachpuff\":  [255, 218, 185],\n        \"peru\":  [205, 133, 63],\n        \"pink\":  [255, 192, 203],\n        \"plum\":  [221, 160, 221],\n        \"powderblue\":  [176, 224, 230],\n        \"purple\":  [128, 0, 128],\n        \"red\":  [255, 0, 0],\n        \"rosybrown\":  [188, 143, 143],\n        \"royalblue\":  [65, 105, 225],\n        \"saddlebrown\":  [139, 69, 19],\n        \"salmon\":  [250, 128, 114],\n        \"sandybrown\":  [244, 164, 96],\n        \"seagreen\":  [46, 139, 87],\n        \"seashell\":  [255, 245, 238],\n        \"sienna\":  [160, 82, 45],\n        \"silver\":  [192, 192, 192],\n        \"skyblue\":  [135, 206, 235],\n        \"slateblue\":  [106, 90, 205],\n        \"slategray\":  [112, 128, 144],\n        \"slategrey\":  [112, 128, 144],\n        \"snow\":  [255, 250, 250],\n        \"springgreen\":  [0, 255, 127],\n        \"steelblue\":  [70, 130, 180],\n        \"tan\":  [210, 180, 140],\n        \"teal\":  [0, 128, 128],\n        \"thistle\":  [216, 191, 216],\n        \"tomato\":  [255, 99, 71],\n        \"turquoise\":  [64, 224, 208],\n        \"violet\":  [238, 130, 238],\n        \"wheat\":  [245, 222, 179],\n        \"white\":  [255, 255, 255],\n        \"whitesmoke\":  [245, 245, 245],\n        \"yellow\":  [255, 255, 0],\n        \"yellowgreen\":  [154, 205, 50],\n        \"transparent\":  [0, 0, 0, 0]\n    }\n};\n\nmodule.exports = {\n  version: {\n    latest: _torque_reference_latest,\n    '1.0.0': _torque_reference_latest\n  }\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/common.js\":[function(require,module,exports){\n(function (global){\n//\n// common functionallity for torque layers\n//\nvar carto = global.carto || require('carto');\n\nfunction TorqueLayer() {}\n\nTorqueLayer.prototype = {\n};\n\nTorqueLayer.optionsFromLayer = function(mapConfig) {\n  var opts = {};\n  if (!mapConfig) return opts;\n  var attrs = {\n    'buffer-size': 'buffer-size',\n    '-torque-frame-count': 'steps',\n    '-torque-resolution': 'resolution',\n    '-torque-animation-duration': 'animationDuration',\n    '-torque-aggregation-function': 'countby',\n    '-torque-time-attribute': 'column',\n    '-torque-data-aggregation': 'data_aggregation'\n  };\n  for (var i in attrs) {\n    var v = mapConfig.eval(i);\n    if (v !== undefined) {\n      var a = attrs[i];\n      opts[a] = v;\n    }\n  }\n  return opts;\n};\n\nTorqueLayer.optionsFromCartoCSS = function(cartocss) {\n  var shader = new carto.RendererJS().render(cartocss);\n  var mapConfig = shader.findLayer({ name: 'Map' });\n  return TorqueLayer.optionsFromLayer(mapConfig);\n};\n\nmodule.exports.TorqueLayer = TorqueLayer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"carto\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/core.js\":[function(require,module,exports){\n(function (global){\n  var Event = {};\n  Event.on = function(evt, callback) {\n      var cb = this._evt_callbacks = this._evt_callbacks || {};\n      var l = cb[evt] || (cb[evt] = []);\n      l.push(callback);\n      return this;\n  };\n\n  Event.trigger = function(evt) {\n      var c = this._evt_callbacks && this._evt_callbacks[evt];\n      for(var i = 0; c && i < c.length; ++i) {\n          c[i].apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n      return this;\n  };\n\n  Event.fire = Event.trigger;\n\n  Event.off = function (evt, callback) {\n      var c = this._evt_callbacks && this._evt_callbacks[evt];\n      if (c && !callback) {\n        delete this._evt_callbacks[evt];\n        return this;\n     }\n     var remove = [];\n     for(var i = 0; c && i < c.length; ++i) {\n       if(c[i] === callback) remove.push(i);\n     }\n     while((i = remove.pop()) !== undefined) c.splice(i, 1);\n    return this;\n  };\n\n  Event.callbacks = function(evt) {\n    return (this._evt_callbacks && this._evt_callbacks[evt]) || [];\n  };\n\n  function extend() {\n      var objs = arguments;\n      var a = objs[0];\n      for (var i = 1; i < objs.length; ++i) {\n          var b = objs[i];\n          for (var k in b) {\n              a[k] = b[k];\n          }\n      }\n      return a;\n  }\n\n  function clone(a) {\n    return extend({}, a);\n  }\n\n  function isFunction(f) {\n    return typeof f == 'function' || false;\n  }\n\n  function isArray(value) {\n      return value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object Array]';\n  }\n\n  // types\n  var types = {\n    Uint8Array: typeof(global['Uint8Array']) !== 'undefined' ? global.Uint8Array : Array,\n    Uint32Array: typeof(global['Uint32Array']) !== 'undefined' ? global.Uint32Array : Array,\n    Int16Array: typeof(global['Int16Array']) !== 'undefined' ? global.Int16Array : Array,\n    Int32Array: typeof(global['Int32Array']) !== 'undefined' ? global.Int32Array: Array\n  };\n\n  function isBrowserSupported() {\n    return !!document.createElement('canvas');\n  }\n\n  function userAgent() {\n      return typeof navigator !== 'undefined' ? navigator.userAgent : '';\n  }\n\n  var flags = {\n    sprites_to_images: userAgent().indexOf('Safari') === -1\n  };\n\nmodule.exports = {\n    Event: Event,\n    extend: extend,\n    clone: clone,\n    isFunction: isFunction,\n    isArray: isArray,\n    types: types,\n    isBrowserSupported: isBrowserSupported,\n    flags: flags\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/CanvasLayer.js\":[function(require,module,exports){\n/**\n * @license\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Extends OverlayView to provide a canvas \"Layer\".\n * @author Brendan Kenny\n */\n\n/**\n * A map layer that provides a canvas over the slippy map and a callback\n * system for efficient animation. Requires canvas and CSS 2D transform\n * support.\n * @constructor\n * @extends google.maps.OverlayView\n * @param {CanvasLayerOptions=} opt_options Options to set in this CanvasLayer.\n */\n\nfunction CanvasLayer(opt_options) {\n  /**\n   * If true, canvas is in a map pane and the OverlayView is fully functional.\n   * See google.maps.OverlayView.onAdd for more information.\n   * @type {boolean}\n   * @private\n   */\n  this.isAdded_ = false;\n\n  /**\n   * If true, each update will immediately schedule the next.\n   * @type {boolean}\n   * @private\n   */\n  this.isAnimated_ = false;\n\n  /**\n   * The name of the MapPane in which this layer will be displayed.\n   * @type {string}\n   * @private\n   */\n  this.paneName_ = CanvasLayer.DEFAULT_PANE_NAME_;\n\n  /**\n   * A user-supplied function called whenever an update is required. Null or\n   * undefined if a callback is not provided.\n   * @type {?function=}\n   * @private\n   */\n  this.updateHandler_ = null;\n\n  /**\n   * A user-supplied function called whenever an update is required and the\n   * map has been resized since the last update. Null or undefined if a\n   * callback is not provided.\n   * @type {?function}\n   * @private\n   */\n  this.resizeHandler_ = null;\n\n  /**\n   * The LatLng coordinate of the top left of the current view of the map. Will\n   * be null when this.isAdded_ is false.\n   * @type {google.maps.LatLng}\n   * @private\n   */\n  this.topLeft_ = null;\n\n  /**\n   * The map-pan event listener. Will be null when this.isAdded_ is false. Will\n   * be null when this.isAdded_ is false.\n   * @type {?function}\n   * @private\n   */\n  this.centerListener_ = null;\n\n  /**\n   * The map-resize event listener. Will be null when this.isAdded_ is false.\n   * @type {?function}\n   * @private\n   */\n  this.resizeListener_ = null;\n\n  /**\n   * If true, the map size has changed and this.resizeHandler_ must be called\n   * on the next update.\n   * @type {boolean}\n   * @private\n   */\n  this.needsResize_ = true;\n\n  /**\n   * A browser-defined id for the currently requested callback. Null when no\n   * callback is queued.\n   * @type {?number}\n   * @private\n   */\n  this.requestAnimationFrameId_ = null;\n\n  var canvas = document.createElement('canvas');\n  canvas.style.position = 'absolute';\n  canvas.style.top = 0;\n  canvas.style.left = 0;\n  canvas.style.pointerEvents = 'none';\n\n  /**\n   * The canvas element.\n   * @type {!HTMLCanvasElement}\n   */\n  this.canvas = canvas;\n\n  /**\n   * Simple bind for functions with no args for bind-less browsers (Safari).\n   * @param {Object} thisArg The this value used for the target function.\n   * @param {function} func The function to be bound.\n   */\n  function simpleBindShim(thisArg, func) {\n    return function() { func.apply(thisArg); };\n  }\n\n  /**\n   * A reference to this.repositionCanvas_ with this bound as its this value.\n   * @type {function}\n   * @private\n   */\n  this.repositionFunction_ = simpleBindShim(this, this.repositionCanvas_);\n\n  /**\n   * A reference to this.resize_ with this bound as its this value.\n   * @type {function}\n   * @private\n   */\n  this.resizeFunction_ = simpleBindShim(this, this.resize_);\n\n  /**\n   * A reference to this.update_ with this bound as its this value.\n   * @type {function}\n   * @private\n   */\n  this.requestUpdateFunction_ = simpleBindShim(this, this.update_);\n\n  // set provided options, if any\n  if (opt_options) {\n    this.setOptions(opt_options);\n  }\n}\n\nCanvasLayer.prototype = new google.maps.OverlayView();\n\n/**\n * The default MapPane to contain the canvas.\n * @type {string}\n * @const\n * @private\n */\nCanvasLayer.DEFAULT_PANE_NAME_ = 'overlayLayer';\n\n/**\n * Transform CSS property name, with vendor prefix if required. If browser\n * does not support transforms, property will be ignored.\n * @type {string}\n * @const\n * @private\n */\nCanvasLayer.CSS_TRANSFORM_ = (function() {\n  var div = document.createElement('div');\n  var transformProps = [\n    'transform',\n    'WebkitTransform',\n    'MozTransform',\n    'OTransform',\n    'msTransform'\n  ];\n  for (var i = 0; i < transformProps.length; i++) {\n    var prop = transformProps[i];\n    if (div.style[prop] !== undefined) {\n      return prop;\n    }\n  }\n\n  // return unprefixed version by default\n  return transformProps[0];\n})();\n\n/**\n * The requestAnimationFrame function, with vendor-prefixed or setTimeout-based\n * fallbacks. MUST be called with window as thisArg.\n * @type {function}\n * @param {function} callback The function to add to the frame request queue.\n * @return {number} The browser-defined id for the requested callback.\n * @private\n */\nCanvasLayer.prototype.requestAnimFrame_ =\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    function(callback) {\n      return window.setTimeout(callback, 1000 / 60);\n    };\n\n/**\n * The cancelAnimationFrame function, with vendor-prefixed fallback. Does not\n * fall back to clearTimeout as some platforms implement requestAnimationFrame\n * but not cancelAnimationFrame, and the cost is an extra frame on onRemove.\n * MUST be called with window as thisArg.\n * @type {function}\n * @param {number=} requestId The id of the frame request to cancel.\n * @private\n */\nCanvasLayer.prototype.cancelAnimFrame_ =\n    window.cancelAnimationFrame ||\n    window.webkitCancelAnimationFrame ||\n    window.mozCancelAnimationFrame ||\n    window.oCancelAnimationFrame ||\n    window.msCancelAnimationFrame ||\n    function(requestId) {};\n\n/**\n * Sets any options provided. See CanvasLayerOptions for more information.\n * @param {CanvasLayerOptions} options The options to set.\n */\nCanvasLayer.prototype.setOptions = function(options) {\n  if (options.animate !== undefined) {\n    this.setAnimate(options.animate);\n  }\n\n  if (options.paneName !== undefined) {\n    this.setPane(options.paneName);\n  }\n\n  if (options.updateHandler !== undefined) {\n    this.setUpdateHandler(options.updateHandler);\n  }\n\n  if (options.resizeHandler !== undefined) {\n    this.setResizeHandler(options.resizeHandler);\n  }\n\n  if(options.readyHandler) {\n    this.readyHandler = options.readyHandler;\n  }\n\n};\n\n/**\n * Set the animated state of the layer. If true, updateHandler will be called\n * repeatedly, once per frame. If false, updateHandler will only be called when\n * a map property changes that could require the canvas content to be redrawn.\n * @param {boolean} animate Whether the canvas is animated.\n */\nCanvasLayer.prototype.setAnimate = function(animate) {\n  this.isAnimated_ = !!animate;\n\n  if (this.isAnimated_) {\n    this.scheduleUpdate();\n  }\n};\n\n/**\n * @return {boolean} Whether the canvas is animated.\n */\nCanvasLayer.prototype.isAnimated = function() {\n  return this.isAnimated_;\n};\n\n/**\n * Set the MapPane in which this layer will be displayed, by name. See\n * {@code google.maps.MapPanes} for the panes available.\n * @param {string} paneName The name of the desired MapPane.\n */\nCanvasLayer.prototype.setPaneName = function(paneName) {\n  this.paneName_ = paneName;\n\n  this.setPane_();\n};\n\n/**\n * @return {string} The name of the current container pane.\n */\nCanvasLayer.prototype.getPaneName = function() {\n  return this.paneName_;\n};\n\n/**\n * Adds the canvas to the specified container pane. Since this is guaranteed to\n * execute only after onAdd is called, this is when paneName's existence is\n * checked (and an error is thrown if it doesn't exist).\n * @private\n */\nCanvasLayer.prototype.setPane_ = function() {\n  if (!this.isAdded_) {\n    return;\n  }\n\n  // onAdd has been called, so panes can be used\n  var panes = this.getPanes();\n  if (!panes[this.paneName_]) {\n    throw new Error('\"' + this.paneName_ + '\" is not a valid MapPane name.');\n  }\n\n  panes[this.paneName_].appendChild(this.canvas);\n};\n\n/**\n * Set a function that will be called whenever the parent map and the overlay's\n * canvas have been resized. If opt_resizeHandler is null or unspecified, any\n * existing callback is removed.\n * @param {?function=} opt_resizeHandler The resize callback function.\n */\nCanvasLayer.prototype.setResizeHandler = function(opt_resizeHandler) {\n  this.resizeHandler_ = opt_resizeHandler;\n};\n\n/**\n * Set a function that will be called when a repaint of the canvas is required.\n * If opt_updateHandler is null or unspecified, any existing callback is\n * removed.\n * @param {?function=} opt_updateHandler The update callback function.\n */\nCanvasLayer.prototype.setUpdateHandler = function(opt_updateHandler) {\n  this.updateHandler_ = opt_updateHandler;\n};\n\n/**\n * @inheritDoc\n */\nCanvasLayer.prototype.onAdd = function() {\n  if (this.isAdded_) {\n    return;\n  }\n\n  this.isAdded_ = true;\n  this.setPane_();\n\n  this.resizeListener_ = google.maps.event.addListener(this.getMap(),\n      'resize', this.resizeFunction_);\n  this.centerListener_ = google.maps.event.addListener(this.getMap(),\n      'center_changed', this.repositionFunction_);\n\n  this.resize_();\n  this.repositionCanvas_();\n  this.readyHandler && this.readyHandler();\n};\n\n/**\n * @inheritDoc\n */\nCanvasLayer.prototype.onRemove = function() {\n  if (!this.isAdded_) {\n    return;\n  }\n\n  this.isAdded_ = false;\n  this.topLeft_ = null;\n\n  // remove canvas and listeners for pan and resize from map\n  this.canvas.parentElement.removeChild(this.canvas);\n  if (this.centerListener_) {\n    google.maps.event.removeListener(this.centerListener_);\n    this.centerListener_ = null;\n  }\n  if (this.resizeListener_) {\n    google.maps.event.removeListener(this.resizeListener_);\n    this.resizeListener_ = null;\n  }\n\n  // cease canvas update callbacks\n  if (this.requestAnimationFrameId_) {\n    this.cancelAnimFrame_.call(window, this.requestAnimationFrameId_);\n    this.requestAnimationFrameId_ = null;\n  }\n};\n\n/**\n * The internal callback for resize events that resizes the canvas to keep the\n * map properly covered.\n * @private\n */\nCanvasLayer.prototype.resize_ = function() {\n  // TODO(bckenny): it's common to use a smaller canvas but use CSS to scale\n  // what is drawn by the browser to save on fill rate. Add an option to do\n  // this.\n\n  if (!this.isAdded_) {\n    return;\n  }\n\n  var map = this.getMap();\n  var width = map.getDiv().offsetWidth;\n  var height = map.getDiv().offsetHeight;\n  var oldWidth = this.canvas.width;\n  var oldHeight = this.canvas.height;\n\n  // resizing may allocate a new back buffer, so do so conservatively\n  if (oldWidth !== width || oldHeight !== height) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.canvas.style.width = width + 'px';\n    this.canvas.style.height = height + 'px';\n\n    this.needsResize_ = true;\n    this.scheduleUpdate();\n  }\n};\n\n/**\n * @inheritDoc\n */\nCanvasLayer.prototype.draw = function() {\n  this.repositionCanvas_();\n};\n\n/**\n * Internal callback for map view changes. Since the Maps API moves the overlay\n * along with the map, this function calculates the opposite translation to\n * keep the canvas in place.\n * @private\n */\nCanvasLayer.prototype.repositionCanvas_ = function() {\n  // TODO(bckenny): *should* only be executed on RAF, but in current browsers\n  //     this causes noticeable hitches in map and overlay relative\n  //     positioning.\n\n  var bounds = this.getMap().getBounds();\n  this.topLeft_ = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getSouthWest().lng());\n\n  // canvas position relative to draggable map's conatainer depends on\n  // overlayView's projection, not the map's\n  var projection = this.getProjection();\n  var divTopLeft = projection.fromLatLngToDivPixel(this.topLeft_);\n\n  // when the zoom level is low, more than one map can be shown in the screen\n  // so the canvas should be attach to the map with more are in the screen\n  var mapSize = (1 << this.getMap().getZoom())*256;\n  if (Math.abs(divTopLeft.x) > mapSize) {\n    divTopLeft.x -= mapSize;\n  }\n  this.canvas.style[CanvasLayer.CSS_TRANSFORM_] = 'translate(' +\n      Math.round(divTopLeft.x) + 'px,' + Math.round(divTopLeft.y) + 'px)';\n\n  this.scheduleUpdate();\n};\n\n/**\n * Internal callback that serves as main animation scheduler via\n * requestAnimationFrame. Calls resize and update callbacks if set, and\n * schedules the next frame if overlay is animated.\n * @private\n */\nCanvasLayer.prototype.update_ = function() {\n  this.requestAnimationFrameId_ = null;\n\n  if (!this.isAdded_) {\n    return;\n  }\n\n  if (this.isAnimated_) {\n    this.scheduleUpdate();\n  }\n\n  if (this.needsResize_ && this.resizeHandler_) {\n    this.needsResize_ = false;\n    this.resizeHandler_();\n  }\n\n  if (this.updateHandler_) {\n    this.updateHandler_();\n  }\n};\n\n/**\n * A convenience method to get the current LatLng coordinate of the top left of\n * the current view of the map.\n * @return {google.maps.LatLng} The top left coordinate.\n */\nCanvasLayer.prototype.getTopLeft = function() {\n  return this.topLeft_;\n};\n\n/**\n * Schedule a requestAnimationFrame callback to updateHandler. If one is\n * already scheduled, there is no effect.\n */\nCanvasLayer.prototype.scheduleUpdate = function() {\n  if (this.isAdded_ && !this.requestAnimationFrameId_) {\n    this.requestAnimationFrameId_ =\n        this.requestAnimFrame_.call(window, this.requestUpdateFunction_);\n  }\n};\n\nmodule.exports = CanvasLayer;\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/canvas_tile_layer.js\":[function(require,module,exports){\n/*\n ====================\n canvas setup for drawing tiles\n ====================\n */\n\nfunction CanvasTileLayer(canvas_setup, render) {\n  this.tileSize = new google.maps.Size(256, 256);\n  this.maxZoom = 19;\n  this.name = \"Tile #s\";\n  this.alt = \"Canvas tile layer\";\n  this.tiles = {};\n  this.canvas_setup = canvas_setup;\n  this.render = render;\n  if (!render) {\n      this.render = canvas_setup;\n  }\n}\n\n\n// create a tile with a canvas element\nCanvasTileLayer.prototype.create_tile_canvas = function (coord, zoom, ownerDocument) {\n\n  // create canvas and reset style\n  var canvas = ownerDocument.createElement('canvas');\n  var hit_canvas = ownerDocument.createElement('canvas');\n  canvas.style.border = hit_canvas.style.border = \"none\";\n  canvas.style.margin = hit_canvas.style.margin = \"0\";\n  canvas.style.padding = hit_canvas.style.padding = \"0\";\n\n  // prepare canvas and context sizes\n  var ctx = canvas.getContext('2d');\n  ctx.width = canvas.width = this.tileSize.width;\n  ctx.height = canvas.height = this.tileSize.height;\n\n  var hit_ctx = hit_canvas.getContext('2d');\n  hit_canvas.width = hit_ctx.width = this.tileSize.width;\n  hit_canvas.height = hit_ctx.height = this.tileSize.height;\n\n  //set unique id\n  var tile_id = coord.x + '_' + coord.y + '_' + zoom;\n\n  canvas.setAttribute('id', tile_id);\n  hit_canvas.setAttribute('id', tile_id);\n\n  if (tile_id in this.tiles)\n      delete this.tiles[tile_id];\n\n  this.tiles[tile_id] = {canvas:canvas, ctx:ctx, hit_canvas:hit_canvas, hit_ctx:hit_ctx, coord:coord, zoom:zoom, primitives:null};\n\n  // custom setup\n  //if (tile_id == '19295_24654_16'){\n  if (this.canvas_setup)\n      this.canvas_setup(this.tiles[tile_id], coord, zoom);\n  //}\n  return canvas;\n\n}\n\n\nCanvasTileLayer.prototype.each = function (callback) {\n  for (var t in this.tiles) {\n      var tile = this.tiles[t];\n      callback(tile);\n  }\n}\n\nCanvasTileLayer.prototype.recreate = function () {\n  for (var t in this.tiles) {\n      var tile = this.tiles[t];\n      this.canvas_setup(tile, tile.coord, tile.zoom);\n  }\n};\n\nCanvasTileLayer.prototype.redraw_tile = function (tile) {\n  this.render(tile, tile.coord, tile.zoom);\n};\n\nCanvasTileLayer.prototype.redraw = function () {\n  for (var t in this.tiles) {\n      var tile = this.tiles[t];\n      this.render(tile, tile.coord, tile.zoom);\n  }\n};\n\n// could be called directly...\nCanvasTileLayer.prototype.getTile = function (coord, zoom, ownerDocument) {\n  return this.create_tile_canvas(coord, zoom, ownerDocument);\n};\n\nCanvasTileLayer.prototype.releaseTile = function (tile) {\n  var id = tile.getAttribute('id');\n  delete this.tiles[id];\n};\n\nmodule.exports = CanvasTileLayer;\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/gmaps_tileloader_mixin.js\":[function(require,module,exports){\nfunction GMapsTileLoader() {\n}\n\n\nGMapsTileLoader.prototype = {\n\n  _initTileLoader: function(map, projection) {\n    this._map = map;\n    this._projection = projection;\n    this._tiles = {};\n    this._tilesLoading = {};\n    this._tilesToLoad = 0;\n    this._updateTiles = this._updateTiles.bind(this);\n    this._listeners = [];\n    this._listeners.push(\n      google.maps.event.addListener(this._map, 'dragend', this._updateTiles),\n      google.maps.event.addListener(this._map, 'zoom_changed', this._updateTiles)\n    );\n    this.tileSize = 256;\n    this._updateTiles();\n  },\n\n  _removeTileLoader: function() {\n    for(var i in this._listeners) {\n      google.maps.event.removeListener(this._listeners[i]);\n    }\n    this._removeTiles();\n  },\n\n  _removeTiles: function () {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n  },\n\n  _reloadTiles: function() {\n    this._removeTiles();\n    this._updateTiles();\n  },\n\n  _updateTiles: function () {\n\n      if (!this._map) { return; }\n\n      var bounds = this._map.getBounds();\n      var zoom = this._map.getZoom();\n      var tileSize = this.tileSize;\n      var mzoom = (1 << zoom);\n\n      var topLeft = new google.maps.LatLng(\n        bounds.getNorthEast().lat(),\n        bounds.getSouthWest().lng()\n      );\n\n      var bottomRigth = new google.maps.LatLng(\n        bounds.getSouthWest().lat(),\n        bounds.getNorthEast().lng()\n      );\n\n\n      this._projection = this._map.getProjection();\n      var divTopLeft = this._projection.fromLatLngToPoint(topLeft);\n      var divBottomRight = this._projection.fromLatLngToPoint(bottomRigth);\n\n\n      var nwTilePoint = new google.maps.Point(\n              Math.floor(divTopLeft.x*mzoom / tileSize),\n              Math.floor(divTopLeft.y*mzoom / tileSize)),\n          seTilePoint = new google.maps.Point(\n              Math.floor(divBottomRight.x*mzoom / tileSize),\n              Math.floor(divBottomRight.y*mzoom / tileSize));\n\n\n      this._addTilesFromCenterOut(nwTilePoint, seTilePoint);\n      this._removeOtherTiles(nwTilePoint, seTilePoint);\n  },\n\n  _removeOtherTiles: function (nwTilePoint, seTilePoint) {\n      var kArr, x, y, key;\n\n      var zoom = this._map.getZoom();\n      for (key in this._tiles) {\n          if (this._tiles.hasOwnProperty(key)) {\n              kArr = key.split(':');\n              x = parseInt(kArr[0], 10);\n              y = parseInt(kArr[1], 10);\n              z = parseInt(kArr[2], 10);\n\n              // remove tile if it's out of bounds\n              if (z !== zoom || x < nwTilePoint.x || x > seTilePoint.x || y < nwTilePoint.y || y > seTilePoint.y) {\n                  this._removeTile(key);\n              }\n          }\n      }\n  },\n\n  _removeTile: function (key) {\n      this.onTileRemoved && this.onTileRemoved(this._tiles[key]); \n      delete this._tiles[key];\n      delete this._tilesLoading[key];\n  },\n\n  _tileKey: function(tilePoint) {\n    return tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom;\n  },\n\n  _tileShouldBeLoaded: function (tilePoint) {\n      var k = this._tileKey(tilePoint);\n      return !(k in this._tiles) && !(k in this._tilesLoading);\n  },\n\n  _tileLoaded: function(tilePoint, tileData) {\n    this._tilesToLoad--;\n    var k = tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom\n    this._tiles[k] = tileData;\n    delete this._tilesLoading[k];\n    if(this._tilesToLoad === 0) {\n      this.onTilesLoaded && this.onTilesLoaded();\n    }\n  },\n\n  getTilePos: function (tilePoint) {\n    var limit = (1 << this._map.getZoom());\n    // wrap tile\n    tilePoint = {\n      x: ((tilePoint.x % limit) + limit) % limit,\n      y: tilePoint.y\n    };\n\n    tilePoint = new google.maps.Point(\n      tilePoint.x * this.tileSize, \n      tilePoint.y * this.tileSize\n    );\n\n    var bounds = this._map.getBounds();\n    var topLeft = new google.maps.LatLng(\n      bounds.getNorthEast().lat(),\n      bounds.getSouthWest().lng()\n    );\n\n    var divTopLeft = this._map.getProjection().fromLatLngToPoint(topLeft);\n    zoom = (1 << this._map.getZoom());\n    divTopLeft.x = divTopLeft.x * zoom;\n    divTopLeft.y = divTopLeft.y * zoom;\n\n    return new google.maps.Point(\n      tilePoint.x - divTopLeft.x,\n      tilePoint.y - divTopLeft.y\n    );\n  },\n\n  _addTilesFromCenterOut: function (nwTilePoint, seTilePoint) {\n      var queue = [],\n          center = new google.maps.Point(\n            (nwTilePoint.x + seTilePoint.x) * 0.5,\n            (nwTilePoint.y + seTilePoint.y) * 0.5\n          ),\n          zoom = this._map.getZoom();\n\n      var j, i, point;\n\n      for (j = nwTilePoint.y; j <= seTilePoint.y; j++) {\n          for (i = nwTilePoint.x; i <= seTilePoint.x; i++) {\n              point = new google.maps.Point (i, j);\n              point.zoom = zoom;\n\n              if (this._tileShouldBeLoaded(point)) {\n                  queue.push(point);\n              }\n          }\n      }\n\n      var tilesToLoad = queue.length;\n\n      if (tilesToLoad === 0) { return; }\n\n      function distanceToCenterSq(point) {\n        var dx = point.x - center.x;\n        var dy = point.y - center.y;\n        return dx * dx + dy * dy;\n      }\n\n      // load tiles in order of their distance to center\n      queue.sort(function (a, b) {\n          return distanceToCenterSq(a) - distanceToCenterSq(b);\n      });\n\n      this._tilesToLoad += tilesToLoad;\n\n        for (i = 0; i < tilesToLoad; i++) {\n          var t = queue[i];\n          var k = this._tileKey(t);\n          this._tilesLoading[k] = t;\n          // events\n          if (this.onTileAdded) {\n            this.onTileAdded(t);\n          }\n        }\n\n      this.onTilesLoading && this.onTilesLoading();\n  }\n\n}\n\nmodule.exports = GMapsTileLoader;\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/index.js\":[function(require,module,exports){\nvar gmaps = {};\nif (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {\n    gmaps = require('./torque');\n    gmaps.GMapsTileLoader = require('./gmaps_tileloader_mixin');\n}\nmodule.exports = gmaps;\n\n},{\"./gmaps_tileloader_mixin\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/gmaps_tileloader_mixin.js\",\"./torque\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/torque.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/torque.js\":[function(require,module,exports){\n(function (global){\nvar carto = global.carto || require('carto');\nvar torque = require('../');\nvar CanvasLayer = require('./CanvasLayer');\nvar CanvasTileLayer = require('./canvas_tile_layer');\nvar GMapsTileLoader = require('./gmaps_tileloader_mixin');\n\nfunction GMapsTorqueLayer(options) {\n  var self = this;\n  if (!torque.isBrowserSupported()) {\n    throw new Error(\"browser is not supported by torque\");\n  }\n  this.key = 0;\n  this.shader = null;\n  this.ready = false;\n  this.options = torque.extend({}, options);\n  this.options = torque.extend({\n    provider: 'windshaft',\n    renderer: 'point',\n    resolution: 2,\n    steps: 100,\n    visible: true\n  }, this.options);\n  if (options.cartocss) {\n    torque.extend(this.options,\n        torque.common.TorqueLayer.optionsFromCartoCSS(options.cartocss));\n  }\n\n  this.hidden = !this.options.visible;\n\n  this.animator = new torque.Animator(function(time) {\n    var k = time | 0;\n    if(self.key !== k) {\n      self.setKey(k);\n    }\n  }, torque.clone(this.options));\n\n  this.play = this.animator.start.bind(this.animator);\n  this.stop = this.animator.stop.bind(this.animator);\n  this.pause = this.animator.pause.bind(this.animator);\n  this.toggle = this.animator.toggle.bind(this.animator);\n  this.setDuration = this.animator.duration.bind(this.animator);\n  this.isRunning = this.animator.isRunning.bind(this.animator);\n\n\n  CanvasLayer.call(this, {\n    map: this.options.map,\n    //resizeHandler: this.redraw,\n    animate: false,\n    updateHandler: this.render,\n    readyHandler: this.initialize\n  });\n\n}\n\n/**\n * torque layer\n */\nGMapsTorqueLayer.prototype = torque.extend({},\n  CanvasLayer.prototype,\n  GMapsTileLoader.prototype,\n  torque.Event,\n  {\n\n  providers: {\n    'sql_api': torque.providers.json,\n    'url_template': torque.providers.jsonarray,\n    'windshaft': torque.providers.windshaft\n  },\n\n  renderers: {\n    'point': torque.renderer.Point,\n    'pixel': torque.renderer.Rectangle\n  },\n\n  initialize: function() {\n    var self = this;\n\n    this.onTileAdded = this.onTileAdded.bind(this);\n\n    this.options.ready = function() {\n      self.fire(\"change:bounds\", {\n        bounds: self.provider.getBounds()\n      });\n      self.animator.steps(self.provider.getSteps());\n      self.animator.rescale();\n      self.fire('change:steps', {\n        steps: self.provider.getSteps()\n      });\n      self.setKey(self.key);\n    };\n\n    this.provider = new this.providers[this.options.provider](this.options);\n    this.renderer = new this.renderers[this.options.renderer](this.getCanvas(), this.options);\n\n    // this listener should be before tile loader\n    this._cacheListener = google.maps.event.addListener(this.options.map, 'zoom_changed', function() {\n      self.renderer && self.renderer.clearSpriteCache();\n    });\n\n    this._initTileLoader(this.options.map, this.getProjection());\n\n    if (this.shader) {\n      this.renderer.setShader(this.shader);\n    }\n\n  },\n\n  hide: function() {\n    if(this.hidden) return this;\n    this.pause();\n    this.clear();\n    this.hidden = true;\n    return this;\n  },\n\n  show: function() {\n    if(!this.hidden) return this;\n    this.hidden = false;\n    this.play();\n    return this;\n  },\n\n  setSQL: function(sql) {\n    if (!this.provider || !this.provider.setSQL) {\n      throw new Error(\"this provider does not support SQL\");\n    }\n    this.provider.setSQL(sql);\n    this._reloadTiles();\n    return this;\n  },\n\n  setBlendMode: function(_) {\n    this.renderer && this.renderer.setBlendMode(_);\n    this.redraw();\n  },\n\n  setSteps: function(steps) {\n    this.provider && this.provider.setSteps(steps);\n    this.animator && this.animator.steps(steps);\n    this._reloadTiles();\n  },\n\n  setColumn: function(column, isTime) {\n    this.provider && this.provider.setColumn(column, isTime);\n    this._reloadTiles();\n  },\n\n  getTimeBounds: function() {\n    return this.provider && this.provider.getKeySpan();\n  },\n\n  getCanvas: function() {\n    return this.canvas;\n  },\n\n    // for each tile shown on the map request the data\n  onTileAdded: function(t) {\n    var self = this;\n    this.provider.getTileData(t, t.zoom, function(tileData) {\n      // don't load tiles that are not being shown\n      if (t.zoom !== self.options.map.getZoom()) return;\n      self._tileLoaded(t, tileData);\n      if (tileData) {\n        self.redraw();\n      }\n    });\n  },\n\n  clear: function() {\n    var canvas = this.canvas;\n    canvas.width = canvas.width;\n  },\n\n  /**\n   * render the selectef key\n   * don't call this function directly, it's called by\n   * requestAnimationFrame. Use redraw to refresh it\n   */\n  render: function() {\n    if(this.hidden) return;\n    var t, tile, pos;\n    var canvas = this.canvas;\n    this.renderer.clearCanvas();\n    var ctx = canvas.getContext('2d');\n\n    // renders only a \"frame\"\n    for(t in this._tiles) {\n      tile = this._tiles[t];\n      if (tile) {\n        pos = this.getTilePos(tile.coord);\n        ctx.setTransform(1, 0, 0, 1, pos.x, pos.y);\n        this.renderer.renderTile(tile, this.key);\n      }\n    }\n  },\n\n  getActivePointsBBox: function(step) {\n    var positions = [];\n    var tileMax = this.options.resolution * (256/this.options.resolution - 1);\n    for(var t in this._tiles) {\n      var tile = this._tiles[t];\n      positions = positions.concat(this.renderer.getActivePointsBBox(tile, step));\n    }\n    return positions;\n  },\n\n  /**\n   * set key to be shown. If it's a single value\n   * it renders directly, if it's an array it renders\n   * accumulated\n   */\n  setKey: function(key) {\n    this.key = key;\n    this.animator.step(key);\n    this.redraw();\n    this.fire('change:time', { time: this.getTime(), step: this.key });\n  },\n\n  /**\n   * helper function, does the same than ``setKey`` but only \n   * accepts scalars.\n   */\n  setStep: function(time) {\n    if(time === undefined || time.length !== undefined) {\n      throw new Error(\"setTime only accept scalars\");\n    }\n    this.setKey(time);\n  },\n\n  /**\n   * transform from animation step to Date object \n   * that contains the animation time\n   *\n   * ``step`` should be between 0 and ``steps - 1`` \n   */\n  stepToTime: function(step) {\n    if (!this.provider) return 0;\n    var times = this.provider.getKeySpan();\n    var time = times.start + (times.end - times.start)*(step/this.provider.getSteps());\n    return new Date(time);\n  },\n\n  timeToStep: function(timestamp) {\n    if (typeof timestamp === \"Date\") timestamp = timestamp.getTime();\n    if (!this.provider) return 0;\n    var times = this.provider.getKeySpan();\n    var step = (this.provider.getSteps() * (timestamp - times.start)) / (times.end - times.start);\n    return step;\n  },\n\n  getStep: function() {\n    return this.key;\n  },\n\n  /**\n   * returns the animation time defined by the data\n   * in the defined column. Date object\n   */\n  getTime: function() {\n    return this.stepToTime(this.key);\n  },\n\n  /**\n   * set the cartocss for the current renderer\n   */\n  setCartoCSS: function(cartocss) {\n    var shader = new carto.RendererJS().render(cartocss);\n    this.shader = shader;\n    if (this.renderer) {\n      this.renderer.setShader(shader);\n    }\n\n    // provider options\n    var options = torque.common.TorqueLayer.optionsFromLayer(shader.findLayer({ name: 'Map' }));\n    this.provider && this.provider.setCartoCSS && this.provider.setCartoCSS(cartocss);\n    if(this.provider && this.provider.setOptions(options)) {\n      this._reloadTiles();\n    }\n    torque.extend(this.options, options);\n\n    // animator options\n    if (options.animationDuration) {\n      this.animator.duration(options.animationDuration);\n    }\n\n    this.redraw();\n    return this;\n  },\n\n  redraw: function() {\n    this.scheduleUpdate();\n  },\n\n  onRemove: function() {\n    CanvasLayer.prototype.onRemove.call(this);\n    this.animator.stop();\n    this._removeTileLoader();\n    google.maps.event.removeListener(this._cacheListener);\n  }\n\n});\n\n\n\nfunction GMapsTiledTorqueLayer(options) {\n  this.options = torque.extend({}, options);\n  CanvasTileLayer.call(this, this._loadTile.bind(this), this.drawTile.bind(this));\n  this.initialize(options);\n}\n\nGMapsTiledTorqueLayer.prototype = torque.extend({}, CanvasTileLayer.prototype, {\n\n  providers: {\n    'sql_api': torque.providers.json,\n    'url_template': torque.providers.JsonArray\n  },\n\n  renderers: {\n    'point': torque.renderer.Point,\n    'pixel': torque.renderer.Rectangle\n  },\n\n  initialize: function(options) {\n    var self = this;\n    this.key = 0;\n\n    this.options.renderer = this.options.renderer || 'pixel';\n    this.options.provider = this.options.provider || 'sql_api';\n\n    this.provider = new this.providers[this.options.provider](options);\n    this.renderer = new this.renderers[this.options.renderer](null, options);\n\n  },\n\n  _tileLoaded: function(tile, tileData) {\n    tile.data = tileData;\n    this.drawTile(tile);\n  },\n\n  _loadTile: function(tile, coord, zoom) {\n    var self = this;\n    var limit = 1 << zoom;\n    // wrap tile\n    var wrappedCoord = {\n      x: ((coord.x % limit) + limit) % limit,\n      y: coord.y\n    };\n\n    this.provider.getTileData(wrappedCoord, zoom, function(tileData) {\n      self._tileLoaded(tile, tileData);\n    });\n  },\n\n  drawTile: function (tile) {\n    var canvas = tile.canvas;\n    if(!tile.data) return;\n    canvas.width = canvas.width;\n\n    this.renderer.setCanvas(canvas);\n\n    var accum = this.renderer.accumulate(tile.data, this.key);\n    this.renderer.renderTileAccum(accum, 0, 0);\n  },\n\n  setKey: function(key) {\n    this.key = key;\n    this.redraw();\n  },\n\n  /**\n   * set the cartocss for the current renderer\n   */\n  setCartoCSS: function(cartocss) {\n    if (!this.renderer) throw new Error('renderer is not valid');\n    return this.renderer.setCartoCSS(cartocss);\n  }\n\n});\n\nmodule.exports = {\n    GMapsTiledTorqueLayer: GMapsTiledTorqueLayer,\n    GMapsTorqueLayer: GMapsTorqueLayer\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\",\"./CanvasLayer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/CanvasLayer.js\",\"./canvas_tile_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/canvas_tile_layer.js\",\"./gmaps_tileloader_mixin\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/gmaps_tileloader_mixin.js\",\"carto\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\":[function(require,module,exports){\nmodule.exports = require('./core');\n\nmodule.exports.Animator = require('./animator');\nmodule.exports.cartocss_reference = require('./cartocss_reference');\nmodule.exports.common = require('./common');\nmodule.exports.math = require('./math');\nmodule.exports.Mercator = require('./mercator');\nmodule.exports.net = require('./request');\nmodule.exports.renderer = require('./renderer');\nmodule.exports.providers = require('./provider');\n\nrequire('./leaflet');\n\nvar gmaps = require('./gmaps');\nmodule.exports.GMapsTileLoader = gmaps.GMapsTileLoader;\nmodule.exports.GMapsTorqueLayer = gmaps.GMapsTorqueLayer;\nmodule.exports.GMapsTiledTorqueLayer = gmaps.GMapsTiledTorqueLayer;\n\n},{\"./animator\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/animator.js\",\"./cartocss_reference\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/cartocss_reference.js\",\"./common\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/common.js\",\"./core\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/core.js\",\"./gmaps\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/gmaps/index.js\",\"./leaflet\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/index.js\",\"./math\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/math.js\",\"./mercator\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/mercator.js\",\"./provider\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/index.js\",\"./renderer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/index.js\",\"./request\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/request.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/canvas_layer.js\":[function(require,module,exports){\nrequire('./leaflet_tileloader_mixin');\n\n/**\n * full canvas layer implementation for Leaflet\n */\n\nL.CanvasLayer = L.Class.extend({\n\n  includes: [L.Mixin.Events, L.Mixin.TileLoader],\n\n  options: {\n      minZoom: 0,\n      maxZoom: 28,\n      tileSize: 256,\n      subdomains: 'abc',\n      errorTileUrl: '',\n      attribution: '',\n      zoomOffset: 0,\n      opacity: 1,\n      unloadInvisibleTiles: L.Browser.mobile,\n      updateWhenIdle: L.Browser.mobile,\n      tileLoader: false, // installs tile loading events\n      zoomAnimation: true\n  },\n\n  initialize: function (options) {\n    var self = this;\n    options = options || {};\n    //this.project = this._project.bind(this);\n    this.render = this.render.bind(this);\n    L.Util.setOptions(this, options);\n    this._canvas = this._createCanvas();\n    // backCanvas for zoom animation\n    if (this.options.zoomAnimation) {\n      this._backCanvas = this._createCanvas();\n    }\n    this._ctx = this._canvas.getContext('2d');\n    this.currentAnimationFrame = -1;\n    this.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||\n                                window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {\n                                    return window.setTimeout(callback, 1000 / 60);\n                                };\n    this.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame ||\n                                window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function(id) { clearTimeout(id); };\n  },\n\n  _createCanvas: function() {\n    var canvas;\n    canvas = document.createElement('canvas');\n    canvas.style.position = 'absolute';\n    canvas.style.top = 0;\n    canvas.style.left = 0;\n    canvas.style.pointerEvents = \"none\";\n    canvas.style.zIndex = this.options.zIndex || 0;\n    var className = 'leaflet-tile-container';\n    if (this.options.zoomAnimation) {\n      className += ' leaflet-zoom-animated';\n    }\n    canvas.setAttribute('class', className);\n    return canvas;\n  },\n\n  onAdd: function (map) {\n    this._map = map;\n\n    // add container with the canvas to the tile pane\n    // the container is moved in the oposite direction of the \n    // map pane to keep the canvas always in (0, 0)\n    var tilePane = this._map._panes.tilePane;\n    var _container = L.DomUtil.create('div', 'leaflet-layer');\n    _container.appendChild(this._canvas);\n    if (this.options.zoomAnimation) {\n      _container.appendChild(this._backCanvas);\n      this._backCanvas.style.display = 'none';\n    }\n    tilePane.appendChild(_container);\n\n    this._container = _container;\n\n    // hack: listen to predrag event launched by dragging to\n    // set container in position (0, 0) in screen coordinates\n    map.dragging._draggable.on('predrag', function() {\n      var d = map.dragging._draggable;\n      L.DomUtil.setPosition(this._canvas, { x: -d._newPos.x, y: -d._newPos.y });\n    }, this);\n\n    map.on({ 'viewreset': this._reset }, this);\n    map.on('move', this.render, this);\n    map.on('resize', this._reset, this);\n\n    if (this.options.zoomAnimation) {\n      map.on({\n        'zoomanim': this._animateZoom,\n        'zoomend': this._endZoomAnim,\n        'moveend': this._reset\n      }, this);\n    }\n\n    if(this.options.tileLoader) {\n      this._initTileLoader();\n    }\n\n    this._reset();\n  },\n\n  _animateZoom: function (e) {\n    if (!this._animating) {\n        this._animating = true;\n    }\n    var back = this._backCanvas;\n\n    back.width = this._canvas.width;\n    back.height = this._canvas.height;\n\n    // paint current canvas in back canvas with trasnformation\n    var pos = this._canvas._leaflet_pos || { x: 0, y: 0 };\n    back.getContext('2d').drawImage(this._canvas, 0, 0);\n\n    L.DomUtil.setPosition(back, L.DomUtil.getPosition(this._canvas));\n\n    // hide original\n    this._canvas.style.display = 'none';\n    back.style.display = 'block';\n    var map = this._map;\n    var scale = map.getZoomScale(e.zoom);\n    var newCenter = map._latLngToNewLayerPoint(map.getCenter(), e.zoom, e.center);\n    var oldCenter = map._latLngToNewLayerPoint(e.center, e.zoom, e.center);\n\n    var origin = {\n      x:  newCenter.x - oldCenter.x + pos.x,\n      y:  newCenter.y - oldCenter.y + pos.y,\n    };\n\n    var bg = back;\n    var transform = L.DomUtil.TRANSFORM;\n    setTimeout(function() {\n      bg.style[transform] = L.DomUtil.getTranslateString(origin) + ' scale(' + e.scale + ') ';\n    }, 0)\n  },\n\n  _endZoomAnim: function () {\n    this._animating = false;\n    this._canvas.style.display = 'block';\n    this._backCanvas.style.display = 'none';\n    this._backCanvas.style[L.DomUtil.TRANSFORM] = '';\n  },\n\n  getCanvas: function() {\n    return this._canvas;\n  },\n\n  getAttribution: function() {\n    return this.options.attribution;\n  },\n\n  draw: function() {\n    return this._reset();\n  },\n\n  onRemove: function (map) {\n    this._container.parentNode.removeChild(this._container);\n    map.off({\n      'viewreset': this._reset,\n      'move': this._render,\n      'moveend': this._reset,\n      'resize': this._reset,\n      'zoomanim': this._animateZoom,\n      'zoomend': this._endZoomAnim\n    }, this);\n  },\n\n  addTo: function (map) {\n    map.addLayer(this);\n    return this;\n  },\n\n  setOpacity: function (opacity) {\n    this.options.opacity = opacity;\n    this._updateOpacity();\n    return this;\n  },\n\n  setZIndex: function(zIndex) {\n    this._canvas.style.zIndex = zIndex;\n    if (this.options.zoomAnimation) {\n      this._backCanvas.style.zIndex = zIndex;\n    }\n  },\n\n  bringToFront: function () {\n    return this;\n  },\n\n  bringToBack: function () {\n    return this;\n  },\n\n  _reset: function () {\n    var size = this._map.getSize();\n    this._canvas.width = size.x;\n    this._canvas.height = size.y;\n\n    // fix position\n    var pos = L.DomUtil.getPosition(this._map.getPanes().mapPane);\n    if (pos) {\n      L.DomUtil.setPosition(this._canvas, { x: -pos.x, y: -pos.y });\n    }\n    this.onResize();\n    this._render();\n  },\n\n  /*\n  _project: function(x) {\n    var point = this._map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));\n    return [point.x, point.y];\n  },\n  */\n\n  _updateOpacity: function () { },\n\n  _render: function() {\n    if (this.currentAnimationFrame >= 0) {\n      this.cancelAnimationFrame.call(window, this.currentAnimationFrame);\n    }\n    this.currentAnimationFrame = this.requestAnimationFrame.call(window, this.render);\n  },\n\n  // use direct: true if you are inside an animation frame call\n  redraw: function(direct) {\n    if (direct) {\n      this.render();\n    } else {\n      this._render();\n    }\n  },\n\n  onResize: function() {\n  },\n\n  render: function() {\n    throw new Error('render function should be implemented');\n  }\n\n});\n\n},{\"./leaflet_tileloader_mixin\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/leaflet_tileloader_mixin.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/index.js\":[function(require,module,exports){\nif (typeof L !== 'undefined') {\n    require('./torque');\n}\n\n},{\"./torque\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/torque.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/leaflet_tileloader_mixin.js\":[function(require,module,exports){\nL.Mixin.TileLoader = {\n\n  _initTileLoader: function() {\n    this._tiles = {}\n    this._tilesLoading = {};\n    this._tilesToLoad = 0;\n    this._map.on({\n        'moveend': this._updateTiles\n    }, this);\n    this._updateTiles();\n  },\n\n  _removeTileLoader: function() {\n    this._map.off({\n        'moveend': this._updateTiles\n    }, this);\n    this._removeTiles();\n  },\n\n  _updateTiles: function () {\n\n      if (!this._map) { return; }\n\n      var bounds = this._map.getPixelBounds(),\n          zoom = this._map.getZoom(),\n          tileSize = this.options.tileSize;\n\n      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {\n          return;\n      }\n\n      var nwTilePoint = new L.Point(\n              Math.floor(bounds.min.x / tileSize),\n              Math.floor(bounds.min.y / tileSize)),\n\n          seTilePoint = new L.Point(\n              Math.floor(bounds.max.x / tileSize),\n              Math.floor(bounds.max.y / tileSize)),\n\n          tileBounds = new L.Bounds(nwTilePoint, seTilePoint);\n\n      this._addTilesFromCenterOut(tileBounds);\n      this._removeOtherTiles(tileBounds);\n  },\n\n  _removeTiles: function (bounds) {\n      for (var key in this._tiles) {\n        this._removeTile(key);\n      }\n  },\n\n  _reloadTiles: function() {\n    this._removeTiles();\n    this._updateTiles();\n  },\n\n  _removeOtherTiles: function (bounds) {\n      var kArr, x, y, z, key;\n      var zoom = this._map.getZoom();\n\n      for (key in this._tiles) {\n          if (this._tiles.hasOwnProperty(key)) {\n              kArr = key.split(':');\n              x = parseInt(kArr[0], 10);\n              y = parseInt(kArr[1], 10);\n              z = parseInt(kArr[2], 10);\n\n              // remove tile if it's out of bounds\n              if (zoom !== z || x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {\n                  this._removeTile(key);\n              }\n          }\n      }\n  },\n\n  _removeTile: function (key) {\n      this.fire('tileRemoved', this._tiles[key]);\n      delete this._tiles[key];\n      delete this._tilesLoading[key];\n  },\n\n  _tileKey: function(tilePoint) {\n    return tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom;\n  },\n\n  _tileShouldBeLoaded: function (tilePoint) {\n      var k = this._tileKey(tilePoint);\n      return !(k in this._tiles) && !(k in this._tilesLoading);\n  },\n\n  _tileLoaded: function(tilePoint, tileData) {\n    this._tilesToLoad--;\n    var k = tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.zoom\n    this._tiles[k] = tileData;\n    delete this._tilesLoading[k];\n    if(this._tilesToLoad === 0) {\n      this.fire(\"tilesLoaded\");\n    }\n  },\n\n  getTilePos: function (tilePoint) {\n    tilePoint = new L.Point(tilePoint.x, tilePoint.y);\n    var origin = this._map._getNewTopLeftPoint(this._map.getCenter()),\n        tileSize = this.options.tileSize;\n\n    return tilePoint.multiplyBy(tileSize).subtract(origin);\n  },\n\n  _addTilesFromCenterOut: function (bounds) {\n      var queue = [],\n          center = bounds.getCenter(),\n          zoom = this._map.getZoom();\n\n      var j, i, point;\n\n      for (j = bounds.min.y; j <= bounds.max.y; j++) {\n          for (i = bounds.min.x; i <= bounds.max.x; i++) {\n              point = new L.Point(i, j);\n              point.zoom =  zoom;\n\n              if (this._tileShouldBeLoaded(point)) {\n                  queue.push(point);\n              }\n          }\n      }\n\n      var tilesToLoad = queue.length;\n\n      if (tilesToLoad === 0) { return; }\n\n      // load tiles in order of their distance to center\n      queue.sort(function (a, b) {\n          return a.distanceTo(center) - b.distanceTo(center);\n      });\n\n      this._tilesToLoad += tilesToLoad;\n\n      for (i = 0; i < tilesToLoad; i++) {\n        var t = queue[i];\n        var k = this._tileKey(t);\n        this._tilesLoading[k] = t;\n        this.fire('tileAdded', t);\n      }\n      this.fire(\"tilesLoading\");\n\n  }\n\n}\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/torque.js\":[function(require,module,exports){\n(function (global){\nvar carto = global.carto || require('carto');\nvar torque = require('../');\n\nrequire('./canvas_layer');\n\n/**\n * torque layer\n */\nL.TorqueLayer = L.CanvasLayer.extend({\n\n  providers: {\n    'sql_api': torque.providers.json,\n    'url_template': torque.providers.jsonarray,\n    'windshaft': torque.providers.windshaft\n  },\n\n  renderers: {\n    'point': torque.renderer.Point,\n    'pixel': torque.renderer.Rectangle\n  },\n\n  initialize: function(options) {\n    var self = this;\n    if (!torque.isBrowserSupported()) {\n      throw new Error(\"browser is not supported by torque\");\n    }\n    options.tileLoader = true;\n    this.key = 0;\n    this.prevRenderedKey = 0;\n    if (options.cartocss) {\n      torque.extend(options, torque.common.TorqueLayer.optionsFromCartoCSS(options.cartocss));\n    }\n\n    options.resolution = options.resolution || 2;\n    options.steps = options.steps || 100;\n    options.visible = options.visible === undefined ? true: options.visible;\n    this.hidden = !options.visible;\n\n    this.animator = new torque.Animator(function(time) {\n      var k = time | 0;\n      if(self.key !== k) {\n        self.setKey(k, { direct: true });\n      }\n    }, torque.extend(torque.clone(options), {\n      onPause: function() {\n        self.fire('pause');\n      },\n      onStop: function() {\n        self.fire('stop');\n      },\n      onStart: function() {\n        self.fire('play');\n      }\n    }));\n\n    this.play = this.animator.start.bind(this.animator);\n    this.stop = this.animator.stop.bind(this.animator);\n    this.pause = this.animator.pause.bind(this.animator);\n    this.toggle = this.animator.toggle.bind(this.animator);\n    this.setDuration = this.animator.duration.bind(this.animator);\n    this.isRunning = this.animator.isRunning.bind(this.animator);\n\n\n    L.CanvasLayer.prototype.initialize.call(this, options);\n\n    this.options.renderer = this.options.renderer || 'point';\n    this.options.provider = this.options.provider || 'windshaft';\n\n    options.ready = function() {\n      self.fire(\"change:bounds\", {\n        bounds: self.provider.getBounds()\n      });\n      self.animator.steps(self.provider.getSteps());\n      self.animator.rescale();\n      self.fire('change:steps', {\n        steps: self.provider.getSteps()\n      });\n      self.setKey(self.key);\n    };\n\n    this.provider = new this.providers[this.options.provider](options);\n    this.renderer = new this.renderers[this.options.renderer](this.getCanvas(), options);\n\n    this.renderer.on(\"allIconsLoaded\", this.render.bind(this));\n\n\n    // for each tile shown on the map request the data\n    this.on('tileAdded', function(t) {\n      var tileData = this.provider.getTileData(t, t.zoom, function(tileData) {\n        // don't load tiles that are not being shown\n        if (t.zoom !== self._map.getZoom()) return;\n        self._tileLoaded(t, tileData);\n        self._clearTileCaches();\n        if (tileData) {\n          self.redraw();\n        }\n      });\n    }, this);\n\n  },\n\n  _clearTileCaches: function() {\n    var t, tile;\n    for(t in this._tiles) {\n      tile = this._tiles[t];\n      if (tile && tile._tileCache) {\n        tile._tileCache = null;\n      }\n    }\n  },\n\n  _clearCaches: function() {\n    this.renderer && this.renderer.clearSpriteCache();\n    this._clearTileCaches();\n  },\n\n  onAdd: function (map) {\n    map.on({\n      'zoomend': this._clearCaches,\n      'zoomstart': this._pauseOnZoom,\n    }, this);\n\n    map.on({\n      'zoomend': this._resumeOnZoom\n    }, this);\n    L.CanvasLayer.prototype.onAdd.call(this, map);\n  },\n\n  onRemove: function(map) {\n    this._removeTileLoader();\n    map.off({\n      'zoomend': this._clearCaches,\n      'zoomstart': this._pauseOnZoom,\n    }, this);\n    map.off({\n      'zoomend': this._resumeOnZoom\n    }, this);\n    L.CanvasLayer.prototype.onRemove.call(this, map);\n  },\n\n  _pauseOnZoom: function() {\n    this.wasRunning = this.isRunning();\n    if (this.wasRunning) {\n      this.pause();\n    }\n  },\n\n  _resumeOnZoom: function() {\n    if (this.wasRunning) {\n      this.play();\n    }\n  },\n\n  hide: function() {\n    if(this.hidden) return this;\n    this.pause();\n    this.clear();\n    this.hidden = true;\n    return this;\n  },\n\n  show: function() {\n    if(!this.hidden) return this;\n    this.hidden = false;\n    this.play();\n    return this;\n  },\n\n  setSQL: function(sql) {\n    if (!this.provider || !this.provider.setSQL) {\n      throw new Error(\"this provider does not support SQL\");\n    }\n    this.provider.setSQL(sql);\n    this._reloadTiles();\n    return this;\n  },\n\n  setBlendMode: function(_) {\n    this.renderer.setBlendMode(_);\n    this.redraw();\n  },\n\n  setSteps: function(steps) {\n    this.provider.setSteps(steps);\n    this._reloadTiles();\n  },\n\n  setColumn: function(column, isTime) {\n    this.provider.setColumn(column, isTime);\n    this._reloadTiles();\n  },\n\n  getTimeBounds: function() {\n    return this.provider && this.provider.getKeySpan();\n  },\n\n  clear: function() {\n    var canvas = this.getCanvas();\n    canvas.width = canvas.width;\n  },\n\n  /**\n   * render the selectef key\n   * don't call this function directly, it's called by\n   * requestAnimationFrame. Use redraw to refresh it\n   */\n  render: function() {\n    if(this.hidden) return;\n    var t, tile, pos;\n    var canvas = this.getCanvas();\n    this.renderer.clearCanvas();\n    var ctx = canvas.getContext('2d');\n\n    for(t in this._tiles) {\n      tile = this._tiles[t];\n      if (tile) {\n        // clear cache\n        if (this.animator.isRunning()) {\n          tile._tileCache = null;\n        }\n\n        pos = this.getTilePos(tile.coord);\n        ctx.setTransform(1, 0, 0, 1, pos.x, pos.y);\n\n        if (tile._tileCache) {\n          // when the tile has a cached image just render it and avoid to render\n          // all the points\n          this.renderer._ctx.drawImage(tile._tileCache, 0, 0);\n        } else {\n          this.renderer.renderTile(tile, this.key);\n        }\n      }\n    }\n    this.renderer.applyFilters();\n\n    // prepare caches if the animation is not running\n    // don't cache if the key has just changed, this avoids to cache\n    // when the user is dragging, it only cache when the map is still\n    if (!this.animator.isRunning() && this.key === this.prevRenderedKey) {\n      var tile_size = this.renderer.TILE_SIZE;\n      for(t in this._tiles) {\n        tile = this._tiles[t];\n        if (tile && !tile._tileCache) {\n          var c = tile._tileCache = document.createElement('canvas');\n          c.width = c.height = tile_size;\n          pos = this.getTilePos(tile.coord);\n          // clip bounds, firefox raise an exception when try to get data from outside canvas\n          var x = Math.max(0, pos.x)\n          var y = Math.max(0, pos.y)\n          var w = Math.min(tile_size, this.getCanvas().width - x);\n          var h = Math.min(tile_size, this.getCanvas().height - y);\n          if (w > 0 && h > 0) {\n            c.getContext('2d').drawImage(this.getCanvas(), x, y, w, h, x - pos.x, y - pos.y, w, h);\n          }\n        }\n      }\n    }\n\n    this.prevRenderedKey = this.key;\n\n  },\n\n  /**\n   * set key to be shown. If it's a single value\n   * it renders directly, if it's an array it renders\n   * accumulated\n   */\n  setKey: function(key, options) {\n    this.key = key;\n    this.animator.step(key);\n    this._clearTileCaches();\n    this.redraw(options && options.direct);\n    this.fire('change:time', { time: this.getTime(), step: this.key });\n  },\n\n  /**\n   * helper function, does the same than ``setKey`` but only \n   * accepts scalars.\n   */\n  setStep: function(time) {\n    if(time === undefined || time.length !== undefined) {\n      throw new Error(\"setTime only accept scalars\");\n    }\n    this.setKey(time);\n  },\n\n  /**\n   * transform from animation step to Date object \n   * that contains the animation time\n   *\n   * ``step`` should be between 0 and ``steps - 1`` \n   */\n  stepToTime: function(step) {\n    var times = this.provider.getKeySpan();\n    var time = times.start + (times.end - times.start)*(step/this.provider.getSteps());\n    return new Date(time);\n  },\n  \n  timeToStep: function(timestamp) {\n    if (typeof timestamp === \"Date\") timestamp = timestamp.getTime();\n    if (!this.provider) return 0;\n    var times = this.provider.getKeySpan();\n    var step = (this.provider.getSteps() * (timestamp - times.start)) / (times.end - times.start);\n    return step;\n  },\n\n  getStep: function() {\n    return this.key;\n  },\n\n  /**\n   * returns the animation time defined by the data\n   * in the defined column. Date object\n   */\n  getTime: function() {\n    return this.stepToTime(this.key);\n  },\n\n  /**\n   * returns an object with the start and end times\n   */\n  getTimeSpan: function() {\n    return this.provider.getKeySpan();\n  },\n\n  /**\n   * set the cartocss for the current renderer\n   */\n  setCartoCSS: function(cartocss) {\n    if (!this.renderer) throw new Error('renderer is not valid');\n    var shader = new carto.RendererJS().render(cartocss);\n    this.renderer.setShader(shader);\n\n    // provider options\n    var options = torque.common.TorqueLayer.optionsFromLayer(shader.findLayer({ name: 'Map' }));\n    this.provider.setCartoCSS && this.provider.setCartoCSS(cartocss);\n    if(this.provider.setOptions(options)) {\n      this._reloadTiles();\n    }\n\n    torque.extend(this.options, options);\n\n    // animator options\n    if (options.animationDuration) {\n      this.animator.duration(options.animationDuration);\n    }\n    this._clearCaches();\n    this.redraw();\n    return this;\n  },\n\n  /**\n   * get active points for a step in active zoom\n   * returns a list of bounding boxes [[] , [], []]\n   * empty list if there is no active pixels\n   */\n  getActivePointsBBox: function(step) {\n    var positions = [];\n    for(var t in this._tiles) {\n      var tile = this._tiles[t];\n      positions = positions.concat(this.renderer.getActivePointsBBox(tile, step));\n    }\n    return positions;\n  },\n\n  /**\n   * return the value for position relative to map coordinates. null for no value\n   */\n  getValueForPos: function(x, y, step) {\n    step = step === undefined ? this.key: step;\n    var t, tile, pos, value = null, xx, yy;\n    for(t in this._tiles) {\n      tile = this._tiles[t];\n      pos = this.getTilePos(tile.coord);\n      xx = x - pos.x;\n      yy = y - pos.y;\n      if (xx >= 0 && yy >= 0 && xx < this.renderer.TILE_SIZE && yy <= this.renderer.TILE_SIZE) {\n        value = this.renderer.getValueFor(tile, step, xx, yy);\n      }\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  },\n\n  invalidate: function() {\n    this.provider.reload();\n  }\n});\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\",\"./canvas_layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/leaflet/canvas_layer.js\",\"carto\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/math.js\":[function(require,module,exports){\n  function clamp(a, b) {\n    return function(t) {\n      return Math.max(Math.min(t, b), a);\n    };\n  }\n\n  function invLinear(a, b) {\n    var c = clamp(0, 1.0);\n    return function(t) {\n      return c((t - a)/(b - a));\n    };\n  }\n\n  function linear(a, b) {\n    var c = clamp(a, b);\n    function _linear(t) {\n      return c(a*(1.0 - t) + t*b);\n    }\n\n    _linear.invert = function() {\n      return invLinear(a, b);\n    };\n\n    return _linear;\n  }\n\nmodule.exports = {\n    clamp: clamp,\n    linear: linear,\n    invLinear: invLinear\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/mercator.js\":[function(require,module,exports){\nvar Point = function(x, y) {\n  this.x = x || 0;\n  this.y = y || 0;\n};\n\nfunction clamp(value, optMin, optMax) {\n  if (optMin !== null) value = Math.max(value, optMin);\n  if (optMax !== null) value = Math.min(value, optMax);\n  return value;\n}\n\nfunction degreesToRadians(deg) {\n  return deg * (Math.PI / 180);\n}\n\nfunction radiansToDegrees(rad) {\n  return rad / (Math.PI / 180);\n}\n\n\nvar MercatorProjection = function() {\n//  this._tileSize = L.Browser.retina ? 512 : 256;\n  this._tileSize = 256;\n  this._pixelOrigin = new Point(this._tileSize / 2, this._tileSize / 2);\n  this._pixelsPerLonDegree = this._tileSize / 360;\n  this._pixelsPerLonRadian = this._tileSize / (2 * Math.PI);\n};\n\nMercatorProjection.prototype._fromLatLonToPoint = function(lat, lon) {\n  var point = new Point(0, 0);\n  var origin = this._pixelOrigin;\n\n  point.x = origin.x + lon * this._pixelsPerLonDegree;\n\n  // NOTE(appleton): Truncating to 0.9999 effectively limits latitude to\n  // 89.189.  This is about a third of a tile past the edge of the world\n  // tile.\n  var siny = clamp(Math.sin(degreesToRadians(lat)), -0.9999, 0.9999);\n  point.y = origin.y + 0.5 * Math.log((1 + siny) / (1 - siny)) * -this._pixelsPerLonRadian;\n  return point;\n};\n\nMercatorProjection.prototype._fromPointToLatLon = function(point) {\n  var me = this;\n  var origin = me._pixelOrigin;\n  var lon = (point.x - origin.x) / me._pixelsPerLonDegree;\n  var latRadians = (point.y - origin.y) / -me._pixelsPerLonRadian;\n  var lat = radiansToDegrees(2 * Math.atan(Math.exp(latRadians)) - Math.PI / 2);\n  return { lat:lat, lon:lon };\n};\n\nMercatorProjection.prototype._tilePixelPos = function(tileX, tileY) {\n  return {\n    x: tileX*this._tileSize,\n    y: tileY*this._tileSize\n  };\n};\n\nMercatorProjection.prototype.tilePixelBBox = function(x, y, zoom, px, py, res) {\n  res = res || 1.0;\n  var numTiles = 1 <<zoom;\n  var inc = res/numTiles;\n  px = (x*this._tileSize + px)/numTiles;\n  py = (y*this._tileSize + py)/numTiles;\n  return [\n    this._fromPointToLatLon(new Point(px, py + inc)),\n    this._fromPointToLatLon(new Point(px + inc, py))\n  ];\n};\n\nMercatorProjection.prototype.tileBBox = function(x, y, zoom, bufferSize) {\n  var numTiles = 1 <<zoom;\n  bufferSize = bufferSize || 0;\n  var inc =  (this._tileSize + bufferSize*2)/numTiles;\n  var px = (x*this._tileSize - bufferSize  )/numTiles;\n  var py = (y*this._tileSize - bufferSize  )/numTiles;\n  return [\n    this._fromPointToLatLon(new Point(px, py + inc)),\n    this._fromPointToLatLon(new Point(px + inc, py))\n  ];\n};\n\nMercatorProjection.prototype.latLonToTilePoint = function(lat, lon, tileX, tileY, zoom) {\n  var numTiles = 1 <<zoom;\n  var worldCoordinate = this._fromLatLonToPoint(lat, lon);\n  var pixelCoordinate = new Point(worldCoordinate.x*numTiles, worldCoordinate.y*numTiles);\n  var tilePixelPos    = this._tilePixelPos(tileX, tileY);\n  return new Point(Math.round(pixelCoordinate.x-tilePixelPos.x), Math.round(pixelCoordinate.y-tilePixelPos.y));\n};\n\nmodule.exports = MercatorProjection;\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/profiler.js\":[function(require,module,exports){\n/*\n# metrics profiler\n\n## timing\n\n```\n var timer = Profiler.metric('resource:load')\n time.start();\n ...\n time.end();\n```\n\n## counters\n\n```\n var counter = Profiler.metric('requests')\n counter.inc();   // 1\n counter.inc(10); // 11\n counter.dec()    // 10\n counter.dec(10)  // 0\n```\n\n## Calls per second\n```\n  var fps = Profiler.metric('fps')\n  function render() {\n    fps.mark();\n  }\n```\n*/\nvar MAX_HISTORY = 1024;\nfunction Profiler() {}\nProfiler.metrics = {};\n\nProfiler.get = function(name) {\n  return Profiler.metrics[name] || {\n    max: 0,\n    min: Number.MAX_VALUE,\n    avg: 0,\n    total: 0,\n    count: 0,\n    history: typeof(Float32Array) !== 'undefined' ? new Float32Array(MAX_HISTORY) : []\n  };\n};\n\nProfiler.new_value = function (name, value) {\n  var t = Profiler.metrics[name] = Profiler.get(name);\n\n  t.max = Math.max(t.max, value);\n  t.min = Math.min(t.min, value);\n  t.total += value;\n  ++t.count;\n  t.avg = t.total / t.count;\n  t.history[t.count%MAX_HISTORY] = value;\n};\n\nProfiler.print_stats = function () {\n  for (k in Profiler.metrics) {\n    var t = Profiler.metrics[k];\n    console.log(\" === \" + k + \" === \");\n    console.log(\" max: \" + t.max);\n    console.log(\" min: \" + t.min);\n    console.log(\" avg: \" + t.avg);\n    console.log(\" count: \" + t.count);\n    console.log(\" total: \" + t.total);\n  }\n};\n\nfunction Metric(name) {\n  this.t0 = null;\n  this.name = name;\n  this.count = 0;\n}\n\nMetric.prototype = {\n\n  //\n  // start a time measurement\n  //\n  start: function() {\n    this.t0 = +new Date();\n    return this;\n  },\n\n  // elapsed time since start was called\n  _elapsed: function() {\n    return +new Date() - this.t0;\n  },\n\n  //\n  // finish a time measurement and register it\n  // ``start`` should be called first, if not this \n  // function does not take effect\n  //\n  end: function() {\n    if (this.t0 !== null) {\n      Profiler.new_value(this.name, this._elapsed());\n      this.t0 = null;\n    }\n  },\n\n  //\n  // increments the value \n  // qty: how many, default = 1\n  //\n  inc: function(qty) {\n    qty = qty === undefined ? 1: qty;\n    Profiler.new_value(this.name, Profiler.get(this.name).count + (qty ? qty: 0));\n  },\n\n  //\n  // decrements the value \n  // qty: how many, default = 1\n  //\n  dec: function(qty) {\n    qty = qty === undefined ? 1: qty;\n    this.inc(-qty);\n  },\n\n  //\n  // measures how many times per second this function is called\n  //\n  mark: function() {\n    ++this.count;\n    if(this.t0 === null) {\n      this.start();\n      return;\n    }\n    var elapsed = this._elapsed();\n    if(elapsed > 1) {\n      Profiler.new_value(this.name, this.count);\n      this.count = 0;\n      this.start();\n    }\n  }\n};\n\nProfiler.metric = function(name) {\n  return new Metric(name);\n};\n\nmodule.exports = Profiler;\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/index.js\":[function(require,module,exports){\nmodule.exports = {\n    json: require('./json'),\n    JsonArray: require('./jsonarray'),\n    windshaft: require('./windshaft')\n};\n\n},{\"./json\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/json.js\",\"./jsonarray\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/jsonarray.js\",\"./windshaft\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/windshaft.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/json.js\":[function(require,module,exports){\nvar torque = require('../');\nvar Profiler = require('../profiler');\n\n  var Uint8Array = torque.types.Uint8Array;\n  var Int32Array = torque.types.Int32Array;\n  var Uint32Array = torque.types.Uint32Array;\n\n  // format('hello, {0}', 'rambo') -> \"hello, rambo\"\n  function format(str) {\n    for(var i = 1; i < arguments.length; ++i) {\n      var attrs = arguments[i];\n      for(var attr in attrs) {\n        str = str.replace(RegExp('\\\\{' + attr + '\\\\}', 'g'), attrs[attr]);\n      }\n    }\n    return str;\n  }\n\n  var json = function (options) {\n    this._ready = false;\n    this._tileQueue = [];\n    this.options = options;\n\n    this.options.is_time = this.options.is_time === undefined ? true: this.options.is_time;\n    this.options.tiler_protocol = options.tiler_protocol || 'http';\n    this.options.tiler_domain = options.tiler_domain || 'cartodb.com';\n    this.options.tiler_port = options.tiler_port || 80;\n\n    if (this.options.data_aggregation) {\n      this.options.cumulative = this.options.data_aggregation === 'cumulative';\n    }\n\n    // check options\n    if (options.resolution === undefined ) throw new Error(\"resolution should be provided\");\n    if (options.steps === undefined ) throw new Error(\"steps should be provided\");\n    if(options.start === undefined) {\n      this._fetchKeySpan();\n    } else {\n      this._setReady(true);\n    }\n  };\n\n  json.prototype = {\n\n    /**\n     * return the torque tile encoded in an efficient javascript\n     * structure:\n     * {\n     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255\n     *   y:Uint8Array y coordinates in tile reference system\n     *   Index: Array index to the properties\n     * }\n     */\n    proccessTile: function(rows, coord, zoom) {\n      var r;\n      var x = new Uint8Array(rows.length);\n      var y = new Uint8Array(rows.length);\n\n      var prof_mem = Profiler.metric('ProviderJSON:mem');\n      var prof_point_count = Profiler.metric('ProviderJSON:point_count');\n      var prof_process_time = Profiler.metric('ProviderJSON:process_time').start()\n\n      // count number of dates\n      var dates = 0;\n      var maxDateSlots = -1;\n      for (r = 0; r < rows.length; ++r) {\n        var row = rows[r];\n        dates += row.dates__uint16.length;\n        for(var d = 0; d < row.dates__uint16.length; ++d) {\n          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);\n        }\n      }\n\n      if(this.options.cumulative) {\n        dates = (1 + maxDateSlots) * rows.length;\n      }\n\n      var type = this.options.cumulative ? Uint32Array: Uint8Array;\n\n      // reserve memory for all the dates\n      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size\n      var timeCount = new Int32Array(maxDateSlots + 1);\n      var renderData = new (this.options.valueDataType || type)(dates);\n      var renderDataPos = new Uint32Array(dates);\n\n      prof_mem.inc(\n        4 * maxDateSlots + // timeIndex\n        4 * maxDateSlots + // timeCount\n        dates + //renderData\n        dates * 4\n      ); //renderDataPos\n\n      prof_point_count.inc(rows.length);\n\n      var rowsPerSlot = {};\n\n      // precache pixel positions\n      for (var r = 0; r < rows.length; ++r) {\n        var row = rows[r];\n        x[r] = row.x__uint8 * this.options.resolution;\n        // fix value when it's in the tile EDGE\n        // TODO: this should be fixed in SQL query\n        if (row.y__uint8 === -1) {\n          y[r] = 0;\n        } else {\n          y[r] = row.y__uint8 * this.options.resolution;\n        }\n\n        var dates = row.dates__uint16;\n        var vals = row.vals__uint8;\n        if (!this.options.cumulative) {\n          for (var j = 0, len = dates.length; j < len; ++j) {\n              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);\n              if(this.options.cumulative) {\n                  vals[j] += prev_val;\n              }\n              prev_val = vals[j];\n              rr.push([r, vals[j]]);\n          }\n        } else {\n          var valByDate = {}\n          for (var j = 0, len = dates.length; j < len; ++j) {\n            valByDate[dates[j]] = vals[j];\n          }\n          var accum = 0;\n\n          // extend the latest to the end\n          for (var j = dates[0]; j <= maxDateSlots; ++j) {\n              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);\n              var v = valByDate[j];\n              if (v) {\n                accum += v;\n              }\n              rr.push([r, accum]);\n          }\n\n          /*var lastDateSlot = dates[dates.length - 1];\n          for (var j = lastDateSlot + 1; j <= maxDateSlots; ++j) {\n            var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);\n            rr.push([r, prev_val]);\n          }\n          */\n        }\n\n      }\n\n      // for each timeslot search active buckets\n      var renderDataIndex = 0;\n      var timeSlotIndex = 0;\n      var i = 0;\n      for(var i = 0; i <= maxDateSlots; ++i) {\n        var c = 0;\n        var slotRows = rowsPerSlot[i]\n        if(slotRows) {\n          for (var r = 0; r < slotRows.length; ++r) {\n            var rr = slotRows[r];\n            ++c;\n            renderDataPos[renderDataIndex] = rr[0]\n            renderData[renderDataIndex] = rr[1];\n            ++renderDataIndex;\n          }\n        }\n        timeIndex[i] = timeSlotIndex;\n        timeCount[i] = c;\n        timeSlotIndex += c;\n      }\n\n      prof_process_time.end();\n\n      return {\n        x: x,\n        y: y,\n        z: zoom,\n        coord: {\n          x: coord.x,\n          y: coord.y,\n          z: zoom\n        },\n        timeCount: timeCount,\n        timeIndex: timeIndex,\n        renderDataPos: renderDataPos,\n        renderData: renderData,\n        maxDate: maxDateSlots\n      };\n    },\n\n    _host: function() {\n      var opts = this.options;\n      var port = opts.sql_api_port;\n      var domain = ((opts.user_name || opts.user) + '.' + (opts.sql_api_domain || 'cartodb.com')) + (port ? ':' + port: '');\n      var protocol = opts.sql_api_protocol || 'http';\n      return this.options.url || protocol + '://' + domain + '/api/v2/sql';\n    },\n\n    url: function(subhost) {\n      var opts = this.options;\n      var protocol = opts.sql_api_protocol || 'http';\n      if (!this.options.cdn_url) {\n        return this._host();\n      }\n      var h = protocol+ \"://\";\n      if (subhost) {\n        h += subhost + \".\";\n      }\n      var cdn_host = opts.cdn_url;\n      if(!cdn_host.http && !cdn_host.https) {\n        throw new Error(\"cdn_host should contain http and/or https entries\");\n      }\n      h += cdn_host[protocol] + \"/\" + (opts.user_name || opts.user) + '/api/v2/sql';\n      return h;\n    },\n\n    _hash: function(str) {\n      var hash = 0;\n      if (!str || str.length == 0) return hash;\n      for (var i = 0, l = str.length; i < l; ++i) {\n          hash = (( (hash << 5 ) - hash ) + str.charCodeAt(i)) | 0;\n      }\n      return hash;\n    },\n\n    _extraParams: function() {\n      if (this.options.extra_params) {\n        var p = [];\n        for(var k in this.options.extra_params) {\n          var v = this.options.extra_params[k];\n          if (v) {\n            p.push(k + \"=\" + encodeURIComponent(v));\n          }\n        }\n        return p.join('&');\n      }\n      return null;\n    },\n\n    isHttps: function() {\n      return this.options.sql_api_protocol && this.options.sql_api_protocol === 'https';\n    },\n\n    // execute actual query\n    sql: function(sql, callback, options) {\n      options = options || {};\n      var subdomains = this.options.subdomains || '0123';\n      if(this.isHttps()) {\n        subdomains = [null]; // no subdomain\n      }\n\n\n      var url;\n      if (options.no_cdn) {\n        url = this._host();\n      } else {\n        url = this.url(subdomains[Math.abs(this._hash(sql))%subdomains.length]);\n      }\n      var extra = this._extraParams();\n      torque.net.get( url + \"?q=\" + encodeURIComponent(sql) + (extra ? \"&\" + extra: ''), function (data) {\n          if(options.parseJSON) {\n            data = JSON.parse(data && data.responseText);\n          }\n          callback && callback(data);\n      });\n    },\n\n    getTileData: function(coord, zoom, callback) {\n      if(!this._ready) {\n        this._tileQueue.push([coord, zoom, callback]);\n      } else {\n        this._getTileData(coord, zoom, callback);\n      }\n    },\n\n    _setReady: function(ready) {\n      this._ready = true;\n      this._processQueue();\n      this.options.ready && this.options.ready();\n    },\n\n    _processQueue: function() {\n      var item;\n      while (item = this._tileQueue.pop()) {\n        this._getTileData.apply(this, item);\n      }\n    },\n\n    /**\n     * `coord` object like {x : tilex, y: tiley }\n     * `zoom` quadtree zoom level\n     */\n    _getTileData: function(coord, zoom, callback) {\n      var prof_fetch_time = Profiler.metric('ProviderJSON:tile_fetch_time').start()\n      this.table = this.options.table;\n      var numTiles = 1 << zoom;\n\n      var column_conv = this.options.column;\n\n      if(this.options.is_time) {\n        column_conv = format(\"date_part('epoch', {column})\", this.options);\n      }\n\n      var sql = \"\" +\n        \"WITH \" +\n        \"par AS (\" +\n        \"  SELECT CDB_XYZ_Resolution({zoom})*{resolution} as res\" +\n        \",  256/{resolution} as tile_size\" +\n        \", CDB_XYZ_Extent({x}, {y}, {zoom}) as ext \"  +\n        \"),\" +\n        \"cte AS ( \"+\n        \"  SELECT ST_SnapToGrid(i.the_geom_webmercator, p.res) g\" +\n        \", {countby} c\" +\n        \", floor(({column_conv} - {start})/{step}) d\" +\n        \"  FROM ({_sql}) i, par p \" +\n        \"  WHERE i.the_geom_webmercator && p.ext \" +\n        \"  GROUP BY g, d\" +\n        \") \" +\n        \"\" +\n        \"SELECT (st_x(g)-st_xmin(p.ext))/p.res x__uint8, \" +\n        \"       (st_y(g)-st_ymin(p.ext))/p.res y__uint8,\" +\n        \" array_agg(c) vals__uint8,\" +\n        \" array_agg(d) dates__uint16\" +\n        // the tile_size where are needed because the overlaps query in cte subquery includes the points\n        // in the left and bottom borders of the tile\n        \" FROM cte, par p where (st_y(g)-st_ymin(p.ext))/p.res < tile_size and (st_x(g)-st_xmin(p.ext))/p.res < tile_size GROUP BY x__uint8, y__uint8\";\n\n\n      var query = format(sql, this.options, {\n        zoom: zoom,\n        x: coord.x,\n        y: coord.y,\n        column_conv: column_conv,\n        _sql: this.getSQL()\n      });\n\n      var self = this;\n      this.sql(query, function (data) {\n        if (data) {\n          var rows = JSON.parse(data.responseText).rows;\n          callback(self.proccessTile(rows, coord, zoom));\n        } else {\n          callback(null);\n        }\n        prof_fetch_time.end();\n      });\n    },\n\n    getKeySpan: function() {\n      return {\n        start: this.options.start * 1000,\n        end: this.options.end * 1000,\n        step: this.options.step,\n        steps: this.options.steps,\n        columnType: this.options.is_time ? 'date': 'number'\n      };\n    },\n\n    setColumn: function(column, isTime) {\n      this.options.column = column;\n      this.options.is_time = isTime === undefined ? true: false;\n      this.reload();\n    },\n\n    setResolution: function(res) {\n      this.options.resolution = res;\n    },\n\n    // return true if tiles has been changed\n    setOptions: function(opt) {\n      var refresh = false;\n\n      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {\n        this.options.resolution = opt.resolution;\n        refresh = true;\n      }\n\n      if(opt.steps !== undefined && opt.steps !== this.options.steps) {\n        this.setSteps(opt.steps, { silent: true });\n        refresh = true;\n      }\n\n      if(opt.column !== undefined && opt.column !== this.options.column) {\n        this.options.column = opt.column;\n        refresh = true;\n      }\n\n      if(opt.countby !== undefined && opt.countby !== this.options.countby) {\n        this.options.countby = opt.countby;\n        refresh = true;\n      }\n\n      if(opt.data_aggregation !== undefined) {\n        var c = opt.data_aggregation === 'cumulative';\n        if (this.options.cumulative !== c) {\n          this.options.cumulative = c;\n          refresh = true;\n        }\n      }\n\n      if (refresh) this.reload();\n      return refresh;\n\n    },\n\n    reload: function() {\n      this._ready = false;\n      this._fetchKeySpan();\n    },\n\n    setSQL: function(sql) {\n      if (this.options.sql != sql) {\n        this.options.sql = sql;\n        this.reload();\n      }\n    },\n\n    getSteps: function() {\n      return Math.min(this.options.steps, this.options.data_steps);\n    },\n\n    setSteps: function(steps, opt) {\n      opt = opt || {};\n      if (this.options.steps !== steps) {\n        this.options.steps = steps;\n        this.options.step = (this.options.end - this.options.start)/this.getSteps();\n        this.options.step = this.options.step || 1;\n        if (!opt.silent) this.reload();\n      }\n    },\n\n    getBounds: function() {\n      return this.options.bounds;\n    },\n\n    getSQL: function() {\n      return this.options.sql || \"select * from \" + this.options.table;\n    },\n\n    _tilerHost: function() {\n      var opts = this.options;\n      var user = (opts.user_name || opts.user);\n      return opts.tiler_protocol +\n           \"://\" + (user ? user + \".\" : \"\")  +\n           opts.tiler_domain +\n           ((opts.tiler_port != \"\") ? (\":\" + opts.tiler_port) : \"\");\n    },\n\n    _fetchUpdateAt: function(callback) {\n      var self = this;\n      var layergroup = {\n        \"version\": \"1.0.1\",\n        \"stat_tag\": this.options.stat_tag || 'torque',\n        \"layers\": [{\n          \"type\": \"cartodb\",\n          \"options\": {\n            \"cartocss_version\": \"2.1.1\", \n            \"cartocss\": \"#layer {}\",\n            \"sql\": this.getSQL()\n          }\n        }]\n      };\n      var url = this._tilerHost() + \"/tiles/layergroup\";\n      var extra = this._extraParams();\n\n      // tiler needs map_key instead of api_key\n      // so replace it\n      if (extra) {\n        extra = extra.replace('api_key=', 'map_key=');\n      }\n\n      url = url +\n        \"?config=\" + encodeURIComponent(JSON.stringify(layergroup)) +\n        \"&callback=?\" + (extra ? \"&\" + extra: '');\n\n      torque.net.jsonp(url, function (data) {\n        var query = format(\"select * from ({sql}) __torque_wrap_sql limit 0\", { sql: self.getSQL() });\n        self.sql(query, function (queryData) {\n          if (data) {\n            callback({\n              updated_at: data.last_updated,\n              fields: queryData.fields\n            });\n          }\n        }, { parseJSON: true });\n      });\n    },\n\n    //\n    // the data range could be set by the user though ``start``\n    // option. It can be fecthed from the table when the start\n    // is not specified.\n    //\n    _fetchKeySpan: function() {\n      var self = this;\n      var max_col, min_col, max_tmpl, min_tmpl;\n\n      this._fetchUpdateAt(function(data) {\n        if (!data) return;\n        self.options.extra_params = self.options.extra_params || {};\n        self.options.extra_params.last_updated = data.updated_at || 0;\n        self.options.extra_params.cache_policy = 'persist';\n        self.options.is_time = data.fields[self.options.column].type === 'date';\n\n        var column_conv = self.options.column;\n        if (self.options.is_time){\n          max_tmpl = \"date_part('epoch', max({column}))\";\n          min_tmpl = \"date_part('epoch', min({column}))\";\n          column_conv = format(\"date_part('epoch', {column})\", self.options);\n        } else {\n          max_tmpl = \"max({column})\";\n          min_tmpl = \"min({column})\";\n        }\n\n        max_col = format(max_tmpl, { column: self.options.column });\n        min_col = format(min_tmpl, { column: self.options.column });\n\n        /*var sql_stats = \"\" +\n        \"WITH summary_groups as ( \" +\n          \"WITH summary as ( \" +\n           \"select   (row_number() over (order by __time_col asc nulls last)+1)/2 as rownum, __time_col \" +\n            \"from (select *, {column} as __time_col from ({sql}) __s) __torque_wrap_sql \" +\n            \"order by __time_col asc \" +\n          \") \" +\n          \"SELECT \" +\n          \"max(__time_col) OVER(PARTITION BY rownum) -  \" +\n          \"min(__time_col) OVER(PARTITION BY rownum) diff \" +\n          \"FROM summary \" +\n        \"), subq as ( \" +\n        \" SELECT \" +\n            \"st_xmax(st_envelope(st_collect(the_geom))) xmax, \" +\n            \"st_ymax(st_envelope(st_collect(the_geom))) ymax, \" +\n            \"st_xmin(st_envelope(st_collect(the_geom))) xmin, \" +\n            \"st_ymin(st_envelope(st_collect(the_geom))) ymin, \" +\n            \"{max_col} max, \" +\n            \"{min_col} min FROM  ({sql}) __torque_wrap_sql \" +\n        \")\" +\n        \"SELECT \" +\n        \"xmax, xmin, ymax, ymin, a.max as max_date, a.min as min_date, \" +\n        \"avg(diff) as diffavg,\" +\n        \"(a.max - a.min)/avg(diff) as num_steps \" +\n        \"FROM summary_groups, subq a  \" +\n        \"WHERE diff > 0 group by xmax, xmin, ymax, ymin, max_date, min_date\";\n        */\n        var sql_stats = \" SELECT \" +\n            \"st_xmax(st_envelope(st_collect(the_geom))) xmax, \" +\n            \"st_ymax(st_envelope(st_collect(the_geom))) ymax, \" +\n            \"st_xmin(st_envelope(st_collect(the_geom))) xmin, \" +\n            \"st_ymin(st_envelope(st_collect(the_geom))) ymin, \" +\n            \"count(*) as num_steps, \" +\n            \"{max_col} max_date, \" +\n            \"{min_col} min_date FROM  ({sql}) __torque_wrap_sql \";\n\n        var sql = format(sql_stats, {\n          max_col: max_col,\n          min_col: min_col,\n          column: column_conv,\n          sql: self.getSQL()\n        });\n\n        self.sql(sql, function(data) {\n          //TODO: manage bounds\n          data = data.rows[0];\n          self.options.start = data.min_date;\n          self.options.end = data.max_date;\n          self.options.step = (data.max_date - data.min_date)/Math.min(self.options.steps, data.num_steps>>0);\n          self.options.data_steps = data.num_steps >> 0;\n          // step can't be 0\n          self.options.step = self.options.step || 1;\n          self.options.bounds = [\n            [data.ymin, data.xmin],\n            [data.ymax, data.xmax]\n          ];\n          self._setReady(true);\n        }, { parseJSON: true, no_cdn: true });\n      }, { parseJSON: true, no_cdn: true})\n    }\n\n  };\n\nmodule.exports = json;\n\n},{\"../\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\",\"../profiler\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/profiler.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/jsonarray.js\":[function(require,module,exports){\nvar torque = require('../');\nvar Profiler = require('../profiler');\n\n  var Uint8Array = torque.types.Uint8Array;\n  var Int32Array = torque.types.Int32Array;\n  var Uint32Array = torque.types.Uint32Array;\n\n  // format('hello, {0}', 'rambo') -> \"hello, rambo\"\n  function format(str, attrs) {\n    for(var i = 1; i < arguments.length; ++i) {\n      var attrs = arguments[i];\n      for(var attr in attrs) {\n        str = str.replace(RegExp('\\\\{' + attr + '\\\\}', 'g'), attrs[attr]);\n      }\n    }\n    return str;\n  }\n\n  var json = function (options) {\n    // check options\n    this.options = options;\n  };\n\n\n  json.prototype = {\n\n    //\n    // return the data aggregated by key:\n    // {\n    //  key0: 12,\n    //  key1: 32\n    //  key2: 25\n    // }\n    //\n    aggregateByKey: function(rows) {\n      function getKeys(row) {\n        var HEADER_SIZE = 3;\n        var valuesCount = row.data[2];\n        var keys = {};\n        for (var s = 0; s < valuesCount; ++s) {\n          keys[row.data[HEADER_SIZE + s]] = row.data[HEADER_SIZE + valuesCount + s];\n        }\n        return keys;\n      }\n      var keys = {};\n      for (r = 0; r < rows.length; ++r) {\n        var rowKeys = getKeys(rows[r]);\n        for(var k in rowKeys) {\n          keys[k] = keys[k] || 0;\n          keys[k] += rowKeys[k];\n        }\n      }\n      return keys;\n    },\n    \n\n\n\n    /**\n     *\n     */\n    proccessTile: function(rows, coord, zoom) {\n      var r;\n      var x = new Uint8Array(rows.length);\n      var y = new Uint8Array(rows.length);\n      var self = this;\n\n      // decode into a javascript strcuture the array\n      function decode_row(row) {\n        var HEADER_SIZE = 3;\n        var o = {\n          x: row.data[0] * self.options.resolution,\n          y: row.data[1] * self.options.resolution,\n          valuesCount: row.data[2],\n          times: [],\n          values: []\n        };\n        for (var s = 0; s < o.valuesCount; ++s) {\n           o.times.push(row.data[HEADER_SIZE + s]);\n           o.values.push(row.data[HEADER_SIZE + o.valuesCount + s]);\n        }\n        if(self.options.cumulative) {\n          for (var s = 1; s < o.valuesCount; ++s) {\n           o.values[s] += o.values[s - 1];\n          }\n        }\n        return o\n      }\n\n      // decode all the rows\n      for (r = 0; r < rows.length; ++r) {\n        rows[r] = decode_row(rows[r]);\n      }\n\n      // count number of dates\n      var dates = 0;\n      var maxDateSlots = 0;\n      for (r = 0; r < rows.length; ++r) {\n        var row = rows[r];\n        dates += row.times.length;\n        for(var d = 0; d < row.times.length; ++d) {\n          maxDateSlots = Math.max(maxDateSlots, row.times[d]);\n        }\n      }\n\n      // reserve memory for all the dates\n      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size\n      var timeCount = new Int32Array(maxDateSlots + 1);\n      var renderData = new (this.options.valueDataType || Uint8Array)(dates);\n      var renderDataPos = new Uint32Array(dates);\n\n      var rowsPerSlot = {};\n\n      // precache pixel positions\n      for (var r = 0; r < rows.length; ++r) {\n        var row = rows[r];\n        x[r] = row.x;\n        y[r] = row.y;\n\n        var dates = row.times;\n        var vals = row.values;\n        for (var j = 0, len = dates.length; j < len; ++j) {\n            var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);\n            rr.push([r, vals[j]]);\n        }\n      }\n\n      // for each timeslot search active buckets\n      var renderDataIndex = 0;\n      var timeSlotIndex = 0;\n      var i = 0;\n      for(var i = 0; i <= maxDateSlots; ++i) {\n        var c = 0;\n        var slotRows = rowsPerSlot[i]\n        if(slotRows) {\n          for (var r = 0; r < slotRows.length; ++r) {\n            var rr = slotRows[r];\n            ++c;\n            renderDataPos[renderDataIndex] = rr[0]\n            renderData[renderDataIndex] = rr[1];\n            ++renderDataIndex;\n          }\n        }\n        timeIndex[i] = timeSlotIndex;\n        timeCount[i] = c;\n        timeSlotIndex += c;\n      }\n\n      return {\n        x: x,\n        y: y,\n        coord: {\n          x: coord.x,\n          y: coord.y,\n          z: zoom\n        },\n        timeCount: timeCount,\n        timeIndex: timeIndex,\n        renderDataPos: renderDataPos,\n        renderData: renderData\n      };\n    },\n\n    url: function() {\n      return this.options.url;\n    },\n\n\n    tileUrl: function(coord, zoom) {\n      var template = this.url();\n      var s = (this.options.subdomains || 'abcd')[(coord.x + coord.y + zoom) % 4];\n      return template\n        .replace('{x}', coord.x)\n        .replace('{y}', coord.y)\n        .replace('{z}', zoom)\n        .replace('{s}', s);\n    },\n\n    getTile: function(coord, zoom, callback) {\n      var template = this.tileUrl(coord, zoom);\n\n      var self = this;\n      var fetchTime = Profiler.metric('jsonarray:fetch time');\n      fetchTime.start();\n      torque.net.get(template, function (data) {\n        fetchTime.end();\n        if(data) {\n          data = JSON.parse(data.responseText);\n        }\n        callback(data);\n      });\n    },\n\n    /**\n     * `coord` object like {x : tilex, y: tiley } \n     * `zoom` quadtree zoom level\n     */\n    getTileData: function(coord, zoom, callback) {\n      var template = this.tileUrl(coord, zoom);\n\n      var self = this;\n      var fetchTime = Profiler.metric('jsonarray:fetch time');\n      fetchTime.start();\n      torque.net.get(template, function (data) {\n        fetchTime.end();\n        var processed = null;\n        \n        var processingTime = Profiler.metric('jsonarray:processing time');\n        var parsingTime = Profiler.metric('jsonarray:parsing time');\n        try {\n          processingTime.start();\n          parsingTime.start();\n          var rows = JSON.parse(data.responseText || data.response).rows;\n          parsingTime.end();\n          processed = self.proccessTile(rows, coord, zoom);\n          processingTime.end();\n        } catch(e) {\n          console.error(\"problem parsing JSON on \", coord, zoom);\n        }\n\n        callback(processed);\n\n      });\n    }\n\n  };\n\n  module.exports = json;\n\n},{\"../\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\",\"../profiler\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/profiler.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/provider/windshaft.js\":[function(require,module,exports){\n  var torque = require('../');\n  var Profiler = require('../profiler');\n\n  var Uint8Array = torque.types.Uint8Array;\n  var Int32Array = torque.types.Int32Array;\n  var Uint32Array = torque.types.Uint32Array;\n\n  // format('hello, {0}', 'rambo') -> \"hello, rambo\"\n  function format(str) {\n    for(var i = 1; i < arguments.length; ++i) {\n      var attrs = arguments[i];\n      for(var attr in attrs) {\n        str = str.replace(RegExp('\\\\{' + attr + '\\\\}', 'g'), attrs[attr]);\n      }\n    }\n    return str;\n  }\n\n  var json = function (options) {\n    this._ready = false;\n    this._tileQueue = [];\n    this.options = options;\n\n    this.options.is_time = this.options.is_time === undefined ? true: this.options.is_time;\n    this.options.tiler_protocol = options.tiler_protocol || 'http';\n    this.options.tiler_domain = options.tiler_domain || 'cartodb.com';\n    this.options.tiler_port = options.tiler_port || 80;\n\n    this.options.coordinates_data_type = this.options.coordinates_data_type || Uint8Array;\n\n    if (this.options.data_aggregation) {\n      this.options.cumulative = this.options.data_aggregation === 'cumulative';\n    }\n    if (this.options.auth_token) {\n      var e = this.options.extra_params || (this.options.extra_params = {});\n      e.auth_token = this.options.auth_token;\n    }\n    if (!this.options.no_fetch_map) {\n      this._fetchMap();\n    }\n  };\n\n  json.prototype = {\n\n    /**\n     * return the torque tile encoded in an efficient javascript\n     * structure:\n     * {\n     *   x:Uint8Array x coordinates in tile reference system, normally from 0-255\n     *   y:Uint8Array y coordinates in tile reference system\n     *   Index: Array index to the properties\n     * }\n     */\n    proccessTile: function(rows, coord, zoom) {\n      var r;\n      var x = new this.options.coordinates_data_type(rows.length);\n      var y = new this.options.coordinates_data_type(rows.length);\n\n      var prof_mem = Profiler.metric('torque.provider.windshaft.mem');\n      var prof_point_count = Profiler.metric('torque.provider.windshaft.points');\n      var prof_process_time = Profiler.metric('torque.provider.windshaft.process_time').start();\n\n      // count number of dates\n      var dates = 0;\n      var maxDateSlots = -1;\n      for (r = 0; r < rows.length; ++r) {\n        var row = rows[r];\n        dates += row.dates__uint16.length;\n        for(var d = 0; d < row.dates__uint16.length; ++d) {\n          maxDateSlots = Math.max(maxDateSlots, row.dates__uint16[d]);\n        }\n      }\n\n      if(this.options.cumulative) {\n        dates = (1 + maxDateSlots) * rows.length;\n      }\n\n      var type = this.options.cumulative ? Uint32Array: Uint8Array;\n\n      // reserve memory for all the dates\n      var timeIndex = new Int32Array(maxDateSlots + 1); //index-size\n      var timeCount = new Int32Array(maxDateSlots + 1);\n      var renderData = new (this.options.valueDataType || type)(dates);\n      var renderDataPos = new Uint32Array(dates);\n\n      prof_mem.inc(\n        4 * maxDateSlots + // timeIndex\n        4 * maxDateSlots + // timeCount\n        dates + //renderData\n        dates * 4\n      ); //renderDataPos\n\n      prof_point_count.inc(rows.length);\n\n      var rowsPerSlot = {};\n\n      // precache pixel positions\n      for (var r = 0; r < rows.length; ++r) {\n        var row = rows[r];\n        x[r] = row.x__uint8 * this.options.resolution;\n        y[r] = row.y__uint8 * this.options.resolution;\n\n        var dates = row.dates__uint16;\n        var vals = row.vals__uint8;\n        if (!this.options.cumulative) {\n          for (var j = 0, len = dates.length; j < len; ++j) {\n              var rr = rowsPerSlot[dates[j]] || (rowsPerSlot[dates[j]] = []);\n              if(this.options.cumulative) {\n                  vals[j] += prev_val;\n              }\n              prev_val = vals[j];\n              rr.push([r, vals[j]]);\n          }\n        } else {\n          var valByDate = {}\n          for (var j = 0, len = dates.length; j < len; ++j) {\n            valByDate[dates[j]] = vals[j];\n          }\n          var accum = 0;\n\n          // extend the latest to the end\n          for (var j = dates[0]; j <= maxDateSlots; ++j) {\n              var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);\n              var v = valByDate[j];\n              if (v) {\n                accum += v;\n              }\n              rr.push([r, accum]);\n          }\n\n          /*var lastDateSlot = dates[dates.length - 1];\n          for (var j = lastDateSlot + 1; j <= maxDateSlots; ++j) {\n            var rr = rowsPerSlot[j] || (rowsPerSlot[j] = []);\n            rr.push([r, prev_val]);\n          }\n          */\n        }\n\n      }\n\n      // for each timeslot search active buckets\n      var renderDataIndex = 0;\n      var timeSlotIndex = 0;\n      var i = 0;\n      for(var i = 0; i <= maxDateSlots; ++i) {\n        var c = 0;\n        var slotRows = rowsPerSlot[i]\n        if(slotRows) {\n          for (var r = 0; r < slotRows.length; ++r) {\n            var rr = slotRows[r];\n            ++c;\n            renderDataPos[renderDataIndex] = rr[0]\n            renderData[renderDataIndex] = rr[1];\n            ++renderDataIndex;\n          }\n        }\n        timeIndex[i] = timeSlotIndex;\n        timeCount[i] = c;\n        timeSlotIndex += c;\n      }\n\n      prof_process_time.end();\n\n      return {\n        x: x,\n        y: y,\n        z: zoom,\n        coord: {\n          x: coord.x,\n          y: coord.y,\n          z: zoom\n        },\n        timeCount: timeCount,\n        timeIndex: timeIndex,\n        renderDataPos: renderDataPos,\n        renderData: renderData,\n        maxDate: maxDateSlots\n      };\n    },\n\n    /*setCartoCSS: function(c) {\n      this.options.cartocss = c;\n    },*/\n\n    setSteps: function(steps, opt) { \n      opt = opt || {};\n      if (this.options.steps !== steps) {\n        this.options.steps = steps;\n        this.options.step = (this.options.end - this.options.start)/this.getSteps();\n        this.options.step = this.options.step || 1;\n        if (!opt.silent) this.reload();\n      }\n    },\n\n    setOptions: function(opt) {\n      var refresh = false;\n\n      if(opt.resolution !== undefined && opt.resolution !== this.options.resolution) {\n        this.options.resolution = opt.resolution;\n        refresh = true;\n      }\n\n      if(opt.steps !== undefined && opt.steps !== this.options.steps) {\n        this.setSteps(opt.steps, { silent: true });\n        refresh = true;\n      }\n\n      if(opt.column !== undefined && opt.column !== this.options.column) {\n        this.options.column = opt.column;\n        refresh = true;\n      }\n\n      if(opt.countby !== undefined && opt.countby !== this.options.countby) {\n        this.options.countby = opt.countby;\n        refresh = true;\n      }\n\n      if(opt.data_aggregation !== undefined) {\n        var c = opt.data_aggregation === 'cumulative';\n        if (this.options.cumulative !== c) {\n          this.options.cumulative = c;\n          refresh = true;\n        }\n      }\n\n      if (refresh) this.reload();\n      return refresh;\n    },\n\n    _extraParams: function(e) {\n      e = torque.extend(torque.extend({}, e), this.options.extra_params);\n      if (e) {\n        var p = [];\n        for(var k in e) {\n          var v = e[k];\n          if (v) {\n            if (torque.isArray(v)) {\n              for (var i = 0, len = v.length; i < len; i++) {\n                p.push(k + \"[]=\" + encodeURIComponent(v[i]));\n              }\n            } else {\n              p.push(k + \"=\" + encodeURIComponent(v));\n            }\n          }\n        }\n        return p.join('&');\n      }\n      return null;\n    },\n\n    getTileData: function(coord, zoom, callback) {\n      if(!this._ready) {\n        this._tileQueue.push([coord, zoom, callback]);\n      } else {\n        this._getTileData(coord, zoom, callback);\n      }\n    },\n\n    _setReady: function(ready) {\n      this._ready = true;\n      this._processQueue();\n      this.options.ready && this.options.ready();\n    },\n\n    _processQueue: function() {\n      var item;\n      while (item = this._tileQueue.pop()) {\n        this._getTileData.apply(this, item);\n      }\n    },\n\n    /**\n     * `coord` object like {x : tilex, y: tiley }\n     * `zoom` quadtree zoom level\n     */\n    _getTileData: function(coord, zoom, callback) {\n      var self = this;\n      var prof_fetch_time = Profiler.metric('torque.provider.windshaft.tile.fetch').start();\n      var subdomains = this.options.subdomains || '0123';\n      var limit_x = Math.pow(2, zoom);\n      var corrected_x = ((coord.x % limit_x) + limit_x) % limit_x;\n      var index = Math.abs(corrected_x + coord.y) % subdomains.length;\n      var url = this.templateUrl\n                .replace('{x}', corrected_x)\n                .replace('{y}', coord.y)\n                .replace('{z}', zoom)\n                .replace('{s}', subdomains[index])\n\n      var extra = this._extraParams();\n      torque.net.get( url + (extra ? \"?\" + extra: ''), function (data) {\n        prof_fetch_time.end();\n        if (data && data.responseText) {\n          var rows = JSON.parse(data.responseText);\n          callback(self.proccessTile(rows, coord, zoom));\n        } else {\n          Profiler.metric('torque.provider.windshaft.tile.error').inc();\n          callback(null);\n        }\n      });\n    },\n\n    getKeySpan: function() {\n      return {\n        start: this.options.start,\n        end: this.options.end,\n        step: this.options.step,\n        steps: this.options.steps,\n        columnType: this.options.column_type\n      };\n    },\n\n    setColumn: function(column, isTime) {\n      this.options.column = column;\n      this.options.is_time = isTime === undefined ? true: false;\n      this.reload();\n    },\n\n    reload: function() {\n      this._ready = false;\n      this._fetchMap();\n    },\n\n    getSteps: function() {\n      return Math.min(this.options.steps, this.options.data_steps);\n    },\n\n    getBounds: function() {\n      return this.options.bounds;\n    },\n\n    getSQL: function() {\n      return this.options.sql || \"select * from \" + this.options.table;\n    },\n\n    setSQL: function(sql) {\n      if (this.options.sql != sql) {\n        this.options.sql = sql;\n        this.reload();\n      }\n    },\n\n    _tilerHost: function() {\n      var opts = this.options;\n      var user = (opts.user_name || opts.user);\n      return opts.tiler_protocol +\n           \"://\" + (user ? user + \".\" : \"\")  +\n           opts.tiler_domain +\n           ((opts.tiler_port != \"\") ? (\":\" + opts.tiler_port) : \"\");\n    },\n\n    url: function() {\n      var opts = this.options;\n      var protocol = opts.tiler_protocol || 'http';\n      if (!this.options.cdn_url || this.options.no_cdn) {\n        return this._tilerHost();\n      }\n      var h = protocol + \"://\"\n      if (protocol === 'http') {\n        h += \"{s}.\";\n      }\n      var cdn_host = opts.cdn_url;\n      if(!cdn_host.http && !cdn_host.https) {\n        throw new Error(\"cdn_host should contain http and/or https entries\");\n      }\n      h += cdn_host[protocol] + \"/\" + (opts.user_name || opts.user);\n      return h;\n    },\n\n    _generateCartoCSS: function() {\n      var attr = {\n        '-torque-frame-count': this.options.steps,\n        '-torque-resolution': this.options.resolution,\n        '-torque-aggregation-function': \"'\" + this.options.countby + \"'\",\n        '-torque-time-attribute': \"'\" + this.options.column + \"'\",\n        '-torque-data-aggregation': this.options.cumulative ? 'cumulative': 'linear',\n      };\n      var st = 'Map{';\n      for (var k in attr) {\n        st += k + \":\" + attr[k] + \";\";\n      }\n      return st + \"}\";\n    },\n\n    _fetchMap: function(callback) {\n      var self = this;\n      var layergroup = {};\n      var host = this.options.dynamic_cdn ? this.url().replace('{s}', '0'): this._tilerHost();\n      var url = host + \"/api/v1/map\";\n      var named = this.options.named_map;\n      var allParams = {};\n\n      if(named) {\n        //tiles/template\n        url = host + \"/api/v1/map/named/\" + named.name + \"/jsonp\";\n        if(typeof named.params !== \"undefined\"){\n          layergroup = named.params;\n        }\n      } else {\n        layergroup = {\n          \"version\": \"1.0.1\",\n          \"stat_tag\": this.options.stat_tag || 'torque',\n          \"layers\": [{\n            \"type\": \"torque\",\n            \"options\": {\n              \"cartocss_version\": \"1.0.0\",\n              \"cartocss\": this._generateCartoCSS(),\n              \"sql\": this.getSQL()\n            }\n          }]\n        };\n      }\n      \n      if(this.options.stat_tag){\n        allParams[\"stat_tag\"] = this.options.stat_tag;\n      }\n\n      extra = this._extraParams(allParams);\n\n      // tiler needs map_key instead of api_key\n      // so replace it\n      if (extra) {\n        extra = extra.replace('api_key=', 'map_key=');\n      }\n\n      url = url +\n        \"?config=\" + encodeURIComponent(JSON.stringify(layergroup)) +\n        \"&callback=?\" + (extra ? \"&\" + extra: '');\n\n      var map_instance_time = Profiler.metric('torque.provider.windshaft.layergroup.time').start();\n      torque.net.jsonp(url, function (data) {\n        map_instance_time.end();\n        if (data) {\n          var torque_key = Object.keys(data.metadata.torque)[0]\n          var opt = data.metadata.torque[torque_key];\n          for(var k in opt) {\n            self.options[k] = opt[k];\n          }\n          // use cdn_url if present\n          if (data.cdn_url) {\n            var c = self.options.cdn_url = self.options.cdn_url || {};\n            c.http = data.cdn_url.http || c.http;\n            c.https = data.cdn_url.https || c.https;\n          }\n          self.templateUrl = self.url() + \"/api/v1/map/\" + data.layergroupid + \"/\" + torque_key + \"/{z}/{x}/{y}.json.torque\";\n          self._setReady(true);\n        } else {\n          Profiler.metric('torque.provider.windshaft.layergroup.error').inc();\n        }\n      }, { callbackName: self.options.instanciateCallback });\n    }\n\n  };\n\n  module.exports = json;\n\n},{\"../\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\",\"../profiler\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/profiler.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/cartocss_render.js\":[function(require,module,exports){\n  var TAU = Math.PI*2;\n  // min value to render a line. \n  // it does not make sense to render a line of a width is not even visible\n  var LINEWIDTH_MIN_VALUE = 0.05; \n\n  function renderPoint(ctx, st) {\n    ctx.fillStyle = st['marker-fill'];\n    var pixel_size = st['marker-width'];\n\n    // render a circle\n    // TODO: fill and stroke order should depend on the order of the properties\n    // in the cartocss.\n\n    // fill\n    ctx.beginPath();\n    ctx.arc(0, 0, pixel_size, 0, TAU, true, true);\n    ctx.closePath();\n    if (st['marker-fill']) {\n      if (st['marker-fill-opacity'] !== undefined || st['marker-opacity'] !== undefined) {\n        ctx.globalAlpha = st['marker-fill-opacity'] || st['marker-opacity'];\n      }\n      ctx.fill();\n    }\n\n    // stroke\n    ctx.globalAlpha = 1.0;\n    if (st['marker-line-color'] && st['marker-line-width'] && st['marker-line-width'] > LINEWIDTH_MIN_VALUE) {\n      if (st['marker-line-opacity'] !== undefined) {\n        ctx.globalAlpha = st['marker-line-opacity'];\n      }\n      if (st['marker-line-width'] !== undefined) {\n        ctx.lineWidth = st['marker-line-width'];\n      }\n      ctx.strokeStyle = st['marker-line-color'];\n\n      // do not render for alpha = 0\n      if (ctx.globalAlpha > 0) {\n        ctx.stroke();\n      }\n    }\n  }\n\n  function renderRectangle(ctx, st) {\n    ctx.fillStyle = st['marker-fill'];\n    var pixel_size = st['marker-width'];\n    var w = pixel_size * 2;\n\n    // fill\n    if (st['marker-fill']) {\n      if (st['marker-fill-opacity'] !== undefined || st['marker-opacity'] !== undefined) {\n        ctx.globalAlpha = st['marker-fill-opacity'] || st['marker-opacity'];\n      }\n      ctx.fillRect(-pixel_size, -pixel_size, w, w)\n    }\n\n    // stroke\n    ctx.globalAlpha = 1.0;\n    if (st['marker-line-color'] && st['marker-line-width']) {\n      if (st['marker-line-opacity']) {\n        ctx.globalAlpha = st['marker-line-opacity'];\n      }\n      if (st['marker-line-width']) {\n        ctx.lineWidth = st['marker-line-width'];\n      }\n      ctx.strokeStyle = st['marker-line-color'];\n\n      // do not render for alpha = 0\n      if (ctx.globalAlpha > 0) {\n        ctx.strokeRect(-pixel_size, -pixel_size, w, w)\n      }\n    }\n  }\n\n  function renderSprite(ctx, img, st) {\n\n    if(img.complete){\n      if (st['marker-fill-opacity'] !== undefined || st['marker-opacity'] !== undefined) {\n        ctx.globalAlpha = st['marker-fill-opacity'] || st['marker-opacity'];\n      }\n      ctx.drawImage(img, 0, 0, img.width, img.height);\n    }\n  }\n\nmodule.exports = {\n    renderPoint: renderPoint,\n    renderSprite: renderSprite,\n    renderRectangle: renderRectangle\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/index.js\":[function(require,module,exports){\nmodule.exports = {\n    cartocss: require('./cartocss_render'),\n    Point: require('./point'),\n    Rectangle: require('./rectangle')\n};\n},{\"./cartocss_render\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/cartocss_render.js\",\"./point\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/point.js\",\"./rectangle\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/rectangle.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/point.js\":[function(require,module,exports){\n(function (global){\nvar torque = require('../');\nvar cartocss = require('./cartocss_render');\nvar Profiler = require('../profiler');\nvar carto = global.carto || require('carto');\nvar Filters = require('./torque_filters');\n\n  var TAU = Math.PI * 2;\n  var DEFAULT_CARTOCSS = [\n    '#layer {',\n    '  marker-fill: #662506;',\n    '  marker-width: 4;',\n    '  [value > 1] { marker-fill: #FEE391; }',\n    '  [value > 2] { marker-fill: #FEC44F; }',\n    '  [value > 3] { marker-fill: #FE9929; }',\n    '  [value > 4] { marker-fill: #EC7014; }',\n    '  [value > 5] { marker-fill: #CC4C02; }',\n    '  [value > 6] { marker-fill: #993404; }',\n    '  [value > 7] { marker-fill: #662506; }',\n    '}'\n  ].join('\\n');\n\n  var COMP_OP_TO_CANVAS = {\n    \"src\": 'source-over',\n    \"src-over\": 'source-over',\n    \"dst-over\": 'destination-over',\n    \"src-in\": 'source-in',\n    \"dst-in\": 'destination-in',\n    \"src-out\": 'source-out',\n    \"dst-out\": 'destination-out',\n    \"src-atop\": 'source-atop',\n    \"dst-atop\": 'destination-atop',\n    \"xor\": 'xor',\n    \"darken\": 'darken',\n    \"lighten\": 'lighten'\n  }\n\n  function compop2canvas(compop) {\n    return COMP_OP_TO_CANVAS[compop] || compop;\n  }\n\n  //\n  // this renderer just render points depending of the value\n  //\n  function PointRenderer(canvas, options) {\n    if (!canvas) {\n      throw new Error(\"canvas can't be undefined\");\n    }\n    this.options = options;\n    this._canvas = canvas;\n    this._ctx = canvas.getContext('2d');\n    this._sprites = []; // sprites per layer\n    this._shader = null;\n    this._icons = {};\n    this._iconsToLoad = 0;\n    this._filters = new Filters(this._canvas, {canvasClass: options.canvasClass});\n    this.setCartoCSS(this.options.cartocss || DEFAULT_CARTOCSS);\n    this.TILE_SIZE = 256;\n    this._style = null;\n    this._gradients = {};\n    \n    this._forcePoints = false;\n  }\n\n  torque.extend(PointRenderer.prototype, torque.Event, {\n\n    clearCanvas: function() {\n      var canvas = this._canvas;\n      var color = this._Map['-torque-clear-color']\n      // shortcut for the default value\n      if (color  === \"rgba(255, 255, 255, 0)\" || !color) {\n        this._canvas.width = this._canvas.width;\n      } else {\n        var ctx = this._ctx;\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        var compop = this._Map['comp-op']\n        ctx.globalCompositeOperation = compop2canvas(compop);\n        ctx.fillStyle = color;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      }\n    },\n\n    setCanvas: function(canvas) {\n      this._canvas = canvas;\n      this._ctx = canvas.getContext('2d');\n    },\n\n    //\n    // sets the cartocss style to render stuff\n    //\n    setCartoCSS: function(cartocss) {\n      // clean sprites\n      this.setShader(new carto.RendererJS().render(cartocss));\n    },\n\n    setShader: function(shader) {\n      // clean sprites\n      this._sprites = [];\n      this._shader = shader;\n      this._Map = this._shader.getDefault().getStyle({}, { zoom: 0 });\n      var img_names = this._shader.getImageURLs();\n      this._preloadIcons(img_names);\n    },\n\n    clearSpriteCache: function() {\n      this._sprites = [];\n    },\n\n\n    //\n    // generate sprite based on cartocss style\n    //\n    generateSprite: function(shader, value, shaderVars) {\n      var self = this;\n      var prof = Profiler.metric('torque.renderer.point.generateSprite').start();\n      var st = shader.getStyle({\n        value: value\n      }, shaderVars);\n      if(this._style === null || this._style !== st){\n        this._style = st;\n      }\n\n      var pointSize = st['marker-width'];\n      if (!pointSize) {\n        return null;\n      }\n\n      if (st['marker-opacity'] === 0 && !st['marker-line-opacity']) {\n        return null;\n      }\n\n      var canvas = this._createCanvas();\n      var ctx = canvas.getContext('2d');\n\n      var markerFile = st[\"marker-file\"] || st[\"point-file\"];\n      var qualifiedUrl = markerFile && this._qualifyURL(markerFile);\n\n      if (qualifiedUrl && this._iconsToLoad <= 0 && this._icons[qualifiedUrl]) {\n        var img = this._icons[qualifiedUrl];\n\n        var dWidth = st['marker-width'] * 2 || img.width;\n        var dHeight = (st['marker-height'] || dWidth) * (img.width / img.height);\n\n        canvas.width = ctx.width = dWidth;\n        canvas.height = ctx.height = dHeight;\n\n        ctx.scale(dWidth/img.width, dHeight/img.height);\n\n        cartocss.renderSprite(ctx, img, st);\n      } else {\n        // take into account the exterior ring to calculate the size\n        var canvasSize = (st['marker-line-width'] || 0) + pointSize*2;\n        var w = ctx.width = canvas.width = ctx.height = canvas.height = Math.ceil(canvasSize);\n        ctx.translate(w/2, w/2);\n\n        var mt = st['marker-type'];\n        if (mt && mt === 'rectangle') {\n          cartocss.renderRectangle(ctx, st);\n        } else {\n          cartocss.renderPoint(ctx, st);\n        }\n      }\n      prof.end(true);\n      if (torque.flags.sprites_to_images) {\n        var i = this._createImage();\n        i.src = canvas.toDataURL();\n        return i;\n      }\n      \n      return canvas;\n    },\n\n    //\n    // renders all the layers (and frames for each layer) from cartocss\n    //\n    renderTile: function(tile, key, callback) {\n      if (this._iconsToLoad > 0) {\n          this.on('allIconsLoaded', function() {\n              this.renderTile.apply(this, [tile, key, callback]);\n          });\n          return false;\n      }\n      var prof = Profiler.metric('torque.renderer.point.renderLayers').start();\n      var layers = this._shader.getLayers();\n      for(var i = 0, n = layers.length; i < n; ++i ) {\n        var layer = layers[i];\n        if (layer.name() !== \"Map\") {\n          var sprites = this._sprites[i] || (this._sprites[i] = {});\n          // frames for each layer\n          for(var fr = 0; fr < layer.frames().length; ++fr) {\n            var frame = layer.frames()[fr];\n            var fr_sprites = sprites[frame] || (sprites[frame] = []);\n            this._renderTile(tile, key - frame, frame, fr_sprites, layer);\n          }\n        }\n      }\n      \n      prof.end(true);\n\n      return callback && callback(null);\n    },\n\n    _createCanvas: function() {\n      return this.options.canvasClass\n        ? new this.options.canvasClass()\n        : document.createElement('canvas');\n    },\n\n    _createImage: function() {\n      return this.options.imageClass\n        ? new this.options.imageClass()\n        : new Image();\n    },\n\n    _setImageSrc: function(img, url, callback) {\n      if (this.options.setImageSrc) {\n        this.options.setImageSrc(img, url, callback);\n      } else {\n        img.onload = function(){\n            callback(null);\n        };\n        img.onerror = function(){\n            callback(new Error('Could not load image'));\n        };\n        img.src = url;\n      }\n    },\n\n    _qualifyURL: function(url) {\n      if (typeof this.options.qualifyURL !== \"undefined\"){\n        return this.options.qualifyURL(url);\n      }\n      else{\n        var a = document.createElement('a');\n        a.href = url;\n        return a.href;\n      }\n    },\n\n    //\n    // renders a tile in the canvas for key defined in \n    // the torque tile\n    //\n    _renderTile: function(tile, key, frame_offset, sprites, shader, shaderVars) {\n      if (!this._canvas) return;\n\n      var prof = Profiler.metric('torque.renderer.point.renderTile').start();\n      var ctx = this._ctx;\n      var blendMode = compop2canvas(shader.eval('comp-op')) || this.options.blendmode;\n      if (blendMode) {\n        ctx.globalCompositeOperation = blendMode;\n      }\n      if (this.options.cumulative && key > tile.maxDate) {\n        //TODO: precache because this tile is not going to change\n        key = tile.maxDate;\n      }\n      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1)\n      var activePixels = tile.timeCount[key];\n      var anchor = this.options.resolution/2;\n      if (activePixels) {\n        var pixelIndex = tile.timeIndex[key];\n        for(var p = 0; p < activePixels; ++p) {\n          var posIdx = tile.renderDataPos[pixelIndex + p];\n          var c = tile.renderData[pixelIndex + p];\n          if (c) {\n           var sp = sprites[c];\n           if (sp === undefined) {\n             sp = sprites[c] = this.generateSprite(shader, c, torque.extend({ zoom: tile.z, 'frame-offset': frame_offset }, shaderVars));\n           }\n           if (sp) {\n             var x = tile.x[posIdx]- (sp.width >> 1) + anchor;\n             var y = tileMax - tile.y[posIdx] + anchor; // flip mercator\n             ctx.drawImage(sp, x, y - (sp.height >> 1));\n           }\n          }\n        }\n      }\n      \n\n      prof.end(true);\n    },\n\n    setBlendMode: function(b) {\n      this.options.blendmode = b;\n    },\n\n    /**\n     * get active points for a step in active zoom\n     * returns a list of bounding boxes [[sw, ne] , [], []] where ne is a {lat: .., lon: ...} obj\n     * empty list if there is no active pixels\n     */\n    getActivePointsBBox: function(tile, step) {\n      var positions = [];\n      var mercator = new torque.Mercator();\n\n      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1);\n      //this.renderer.renderTile(tile, this.key, pos.x, pos.y);\n      var activePixels = tile.timeCount[step];\n      var pixelIndex = tile.timeIndex[step];\n      for(var p = 0; p < activePixels; ++p) {\n        var posIdx = tile.renderDataPos[pixelIndex + p];\n        var c = tile.renderData[pixelIndex + p];\n        if (c) {\n         var x = tile.x[posIdx];\n         var y = tileMax - tile.y[posIdx]; // flip mercator\n         positions.push(mercator.tilePixelBBox(\n           tile.coord.x,\n           tile.coord.y,\n           tile.coord.z,\n           x, y\n         ));\n        }\n      }\n      return positions;\n    },\n\n    // return the value for x, y (tile coordinates)\n    // null for no value\n    getValueFor: function(tile, step, px, py) {\n      var mercator = new torque.Mercator();\n      var res = this.options.resolution;\n      var res2 = res >> 1;\n\n      var tileMax = this.options.resolution * (this.TILE_SIZE/this.options.resolution - 1);\n      //this.renderer.renderTile(tile, this.key, pos.x, pos.y);\n      var activePixels = tile.timeCount[step];\n      var pixelIndex = tile.timeIndex[step];\n      for(var p = 0; p < activePixels; ++p) {\n        var posIdx = tile.renderDataPos[pixelIndex + p];\n        var c = tile.renderData[pixelIndex + p];\n        if (c) {\n         var x = tile.x[posIdx];\n         var y = tileMax - tile.y[posIdx];\n         var dx = px + res2 - x;\n         var dy = py + res2 - y;\n         if (dx >= 0 && dx < res && dy >= 0 && dy < res) {\n           return {\n             value: c,\n             bbox: mercator.tilePixelBBox(\n               tile.coord.x,\n               tile.coord.y,\n               tile.coord.z,\n               x - res2, y - res2, res\n             )\n           }\n         }\n        }\n      }\n      return null;\n    },\n\n    _preloadIcons: function(img_names) {\n      var self = this;\n\n      if (img_names.length > 0 && !this._forcePoints) {\n\n        var qualifiedImageUrlSet = Object.keys(img_names.reduce(function(imgNamesMap, imgName) {\n            var qualifiedUrl = self._qualifyURL(imgName);\n            if (!self._icons[qualifiedUrl]) {\n                imgNamesMap[qualifiedUrl] = true;\n            }\n            return imgNamesMap;\n        }, {}));\n\n        var filtered = self._shader.getLayers().some(function(layer) {\n          return typeof layer.shader[\"image-filters\"] !== \"undefined\";\n        });\n\n        this._iconsToLoad += qualifiedImageUrlSet.length;\n\n        qualifiedImageUrlSet.forEach(function(qualifiedImageUrl) {\n          self._icons[qualifiedImageUrl] = null;\n\n          var img = self._createImage();\n\n          if (filtered) {\n            img.crossOrigin = 'Anonymous';\n          }\n\n          self._setImageSrc(img, qualifiedImageUrl, function(err) {\n            if (err) {\n              self._forcePoints = true;\n              self.clearSpriteCache();\n              self._iconsToLoad = 0;\n              self.fire(\"allIconsLoaded\");\n              if(filtered) {\n                console.info(\"Only CORS-enabled, or same domain image-files can be used in combination with image-filters\");\n              }\n              console.error(\"Couldn't get marker-file \" + qualifiedImageUrl);\n            } else {\n              self._icons[qualifiedImageUrl] = img;\n              self._iconsToLoad--;\n\n              if (self._iconsToLoad <= 0){\n                self.clearSpriteCache();\n                self.fire(\"allIconsLoaded\");\n              }\n            }\n          });\n        });\n      } else {\n          this.fire(\"allIconsLoaded\");\n      }\n  },\n\n  applyFilters: function(){\n    if(this._style){\n      if(this._style['image-filters']){\n        function gradientKey(imf){\n          var hash = \"\"\n          for(var i = 0; i < imf.args.length; i++){\n            var rgb = imf.args[i].rgb;\n            hash += rgb[0] + \":\" + rgb[1] + \":\" + rgb[2];\n          }\n          return hash;\n        }\n        var gradient = this._gradients[gradientKey(this._style['image-filters'])];\n        if(!gradient){\n          function componentToHex(c) {\n            var hex = c.toString(16);\n            return hex.length == 1 ? \"0\" + hex : hex;\n          }\n\n          function rgbToHex(r, g, b) {\n            return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n          }\n          gradient = {};\n          var colorize = this._style['image-filters'].args;\n          \n          var increment = 1/colorize.length;\n          for (var i = 0; i < colorize.length; i++){\n            var key = increment * i + increment;\n            var rgb = colorize[i].rgb;\n            var formattedColor = rgbToHex(rgb[0], rgb[1], rgb[2]);\n            gradient[key] = formattedColor;\n          }\n          this._gradients[gradientKey(this._style['image-filters'])] = gradient;\n        }\n        this._filters.gradient(gradient);\n        this._filters.draw();\n      }\n    }\n  }\n});\n\n\n  // exports public api\nmodule.exports = PointRenderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/index.js\",\"../profiler\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/profiler.js\",\"./cartocss_render\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/cartocss_render.js\",\"./torque_filters\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/torque_filters.js\",\"carto\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/rectangle.js\":[function(require,module,exports){\n(function (global){\nvar carto = global.carto || require('carto');\n\n  var DEFAULT_CARTOCSS = [\n    '#layer {',\n    '  polygon-fill: #FFFF00;',\n    '  [value > 10] { polygon-fill: #FFFF00; }',\n    '  [value > 100] { polygon-fill: #FFCC00; }',\n    '  [value > 1000] { polygon-fill: #FE9929; }',\n    '  [value > 10000] { polygon-fill: #FF6600; }',\n    '  [value > 100000] { polygon-fill: #FF3300; }',\n    '}'\n  ].join('\\n');\n\n  var TAU = Math.PI * 2;\n\n  //\n  // this renderer just render points depending of the value\n  // \n  function RectanbleRenderer(canvas, options) {\n    this.options = options;\n    carto.tree.Reference.set(torque['torque-reference']);\n    this.setCanvas(canvas);\n    this.setCartoCSS(this.options.cartocss || DEFAULT_CARTOCSS);\n  }\n\n  RectanbleRenderer.prototype = {\n\n    //\n    // sets the cartocss style to render stuff\n    //\n    setCartoCSS: function(cartocss) {\n      this._cartoCssStyle = new carto.RendererJS().render(cartocss);\n      if(this._cartoCssStyle.getLayers().length > 1) {\n        throw new Error(\"only one CartoCSS layer is supported\");\n      }\n      this._shader = this._cartoCssStyle.getLayers()[0].shader;\n    },\n\n    setCanvas: function(canvas) {\n      if(!canvas) return;\n      this._canvas = canvas;\n      this._ctx = canvas.getContext('2d');\n    },\n\n    accumulate: function(tile, keys) {\n      var prof = Profiler.metric('RectangleRender:accumulate').start();\n      var x, y, posIdx, p, k, key, activePixels, pixelIndex;\n      var res = this.options.resolution;\n      var s = 256/res;\n      var accum = new Float32Array(s*s);\n\n      if(typeof(keys) !== 'object') {\n        keys = [keys];\n      }\n\n      for(k = 0; k < keys.length; ++k) {\n        key = keys[k];\n        activePixels = tile.timeCount[key];\n        if(activePixels) {\n          pixelIndex = tile.timeIndex[key];\n          for(p = 0; p < activePixels; ++p) {\n            posIdx = tile.renderDataPos[pixelIndex + p];\n            x = tile.x[posIdx]/res;\n            y = tile.y[posIdx]/res;\n            accum[x*s + y] += tile.renderData[pixelIndex + p];\n          }\n        }\n      }\n\n      prof.end();\n      return accum;\n    },\n\n    renderTileAccum: function(accum, px, py) {\n      var prof = Profiler.metric('RectangleRender:renderTileAccum').start();\n      var color, x, y, alpha;\n      var res = this.options.resolution;\n      var ctx = this._ctx;\n      var s = (256/res) | 0;\n      var s2 = s*s;\n      var colors = this._colors;\n      if(this.options.blendmode) {\n        ctx.globalCompositeOperation = this.options.blendmode;\n      }\n      var polygon_alpha = this._shader['polygon-opacity'] || function() { return 1.0; };\n      for(var i = 0; i < s2; ++i) {\n        var xy = i;\n        var value = accum[i];\n        if(value) {\n          x = (xy/s) | 0;\n          y = xy % s;\n          // by-pass the style generation for improving performance\n          color = this._shader['polygon-fill']({ value: value }, { zoom: 0 });\n          ctx.fillStyle = color;\n          //TODO: each function should have a default value for each \n          //property defined in the cartocss\n          alpha = polygon_alpha({ value: value }, { zoom: 0 });\n          if(alpha === null) {\n            alpha = 1.0;\n          }\n          ctx.globalAlpha = alpha;\n          ctx.fillRect(x * res, 256 - res - y * res, res, res);\n        }\n      }\n      prof.end();\n    },\n\n    //\n    // renders a tile in the canvas for key defined in \n    // the torque tile\n    //\n    renderTile: function(tile, key, callback) {\n      if(!this._canvas) return;\n\n      var res = this.options.resolution;\n\n      //var prof = Profiler.get('render').start();\n      var ctx = this._ctx;\n      var colors = this._colors;\n      var activepixels = tile.timeCount[key];\n      if(activepixels) {\n        var w = this._canvas.width;\n        var h = this._canvas.height;\n        //var imageData = ctx.getImageData(0, 0, w, h);\n        //var pixels = imageData.data;\n        var pixelIndex = tile.timeIndex[key];\n        for(var p = 0; p < activePixels; ++p) {\n          var posIdx = tile.renderDataPos[pixelIndex + p];\n          var c = tile.renderData[pixelIndex + p];\n          if(c) {\n           var color = colors[Math.min(c, colors.length - 1)];\n           var x = tile.x[posIdx];// + px;\n           var y = tile.y[posIdx]; //+ py;\n\n           ctx.fillStyle = color;\n           ctx.fillRect(x, y, res, res);\n           /*\n\n           for(var xx = 0; xx < res; ++xx) {\n            for(var yy = 0; yy < res; ++yy) {\n              var idx = 4*((x+xx) + w*(y + yy));\n              pixels[idx + 0] = color[0];\n              pixels[idx + 1] = color[1];\n              pixels[idx + 2] = color[2];\n              pixels[idx + 3] = color[3];\n            }\n           }\n           */\n          }\n        }\n        //ctx.putImageData(imageData, 0, 0);\n      }\n      //prof.end();\n      return callback && callback(null);\n    }\n  };\n\n\n  // exports public api\nmodule.exports = RectanbleRenderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"carto\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/renderer/torque_filters.js\":[function(require,module,exports){\n/*\n Based on simpleheat, a tiny JavaScript library for drawing heatmaps with Canvas, \n by Vladimir Agafonkin\n https://github.com/mourner/simpleheat\n*/\n\n'use strict';\n\nfunction torque_filters(canvas, options) {\n    // jshint newcap: false, validthis: true\n    if (!(this instanceof torque_filters)) { return new torque_filters(canvas, options); }\n\n    options = options || {};\n\n    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;\n\n    this._ctx = canvas.getContext('2d');\n    this._width = canvas.width;\n    this._height = canvas.height;\n\n    this._max = 1;\n    this._data = [];\n\n    this.canvasClass = options.canvasClass;\n}\n\ntorque_filters.prototype = {\n\n    defaultGradient: {\n        0.4: 'blue',\n        0.6: 'cyan',\n        0.7: 'lime',\n        0.8: 'yellow',\n        1.0: 'red'\n    },\n\n    gradient: function (grad) {\n        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n        var canvas = this._createCanvas(),\n            ctx = canvas.getContext('2d'),\n            gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n        canvas.width = 1;\n        canvas.height = 256;\n\n        for (var i in grad) {\n            gradient.addColorStop(+i, grad[i]);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, 1, 256);\n\n        this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n        return this;\n    },\n\n    draw: function () {\n        if (!this._grad) {\n            this.gradient(this.defaultGradient);\n        }\n\n        var ctx = this._ctx;\n        var colored = ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);\n        this._colorize(colored.data, this._grad);\n        ctx.putImageData(colored, 0, 0);\n\n        return this;\n    },\n\n    _colorize: function (pixels, gradient) {\n        for (var i = 3, len = pixels.length, j; i < len; i += 4) {\n            j = pixels[i] * 4; // get gradient color from opacity value\n\n            if (j) {\n                pixels[i - 3] = gradient[j];\n                pixels[i - 2] = gradient[j + 1];\n                pixels[i - 1] = gradient[j + 2];\n            }\n        }\n    },\n\n    _createCanvas: function() {\n        return this.canvasClass\n            ? new this.canvasClass()\n            : document.createElement('canvas');\n    }\n};\n\nmodule.exports = torque_filters;\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/request.js\":[function(require,module,exports){\n(function (global){\nvar torque = require('./core');\n\n  var lastCall = null;\n\n  function jsonp(url, callback, options) {\n     options = options || {};\n     options.timeout = options.timeout === undefined ? 10000: options.timeout;\n     var head = document.getElementsByTagName('head')[0];\n     var script = document.createElement('script');\n\n     // function name\n     var fnName = options.callbackName || 'torque_' + Date.now();\n\n     if (torque.isFunction(fnName)) {\n       fnName = fnName();\n     }\n\n     function clean() {\n       head.removeChild(script);\n       clearTimeout(timeoutTimer);\n       delete window[fnName];\n     }\n\n     window[fnName] = function() {\n       clean();\n       callback.apply(window, arguments);\n     };\n\n     // timeout for errors\n     var timeoutTimer = setTimeout(function() { \n       clean();\n       callback.call(window, null); \n     }, options.timeout);\n\n     // setup url\n     url = url.replace('callback=\\?', 'callback=' + fnName);\n     script.type = 'text/javascript';\n     script.src = url;\n     script.async = true;\n     // defer the loading because IE9 loads in the same frame the script\n     // so Loader._script is null\n     setTimeout(function() { head.appendChild(script); }, 0);\n  }\n\n  function get(url, callback, options) {\n    options = options || {\n      method: 'GET',\n      data: null,\n      responseType: 'text'\n    };\n    lastCall = { url: url, callback: callback };\n    var request = XMLHttpRequest;\n    // from d3.js\n    if (global.XDomainRequest\n        && !(\"withCredentials\" in request)\n        && /^(http(s)?:)?\\/\\//.test(url)) request = XDomainRequest;\n\n    var req = new request();\n    req.open(options.method, url, true);\n\n\n    function respond() {\n      var status = req.status, result;\n      var r = options.responseType === 'arraybuffer' ? req.response: req.responseText;\n      if (!status && r || status >= 200 && status < 300 || status === 304) {\n        callback(req);\n      } else {\n        callback(null);\n      }\n    }\n\n    \"onload\" in req\n      ? req.onload = req.onerror = respond\n      : req.onreadystatechange = function() { req.readyState > 3 && respond(); };\n\n    req.onprogress = function() {};\n\n    req.responseType = options.responseType; //'arraybuffer';\n    if (options.data) {\n      req.setRequestHeader(\"Content-type\", \"application/json\");\n      //req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\")\n      req.setRequestHeader(\"Accept\", \"*\");\n    }\n    req.send(options.data);\n    return req;\n  }\n\n  function post(url, data, callback) {\n    return get(url, callback, {\n      data: data,\n      method: \"POST\"\n    });\n  }\n\nmodule.exports = {\n    get: get,\n    post: post,\n    jsonp: jsonp,\n    lastCall: function() { return lastCall; }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./core\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/lib/torque/core.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/functions.js\":[function(require,module,exports){\n(function (tree) {\n\ntree.functions = {\n    rgb: function (r, g, b) {\n        return this.rgba(r, g, b, 1.0);\n    },\n    rgba: function (r, g, b, a) {\n        var rgb = [r, g, b].map(function (c) { return number(c); });\n        a = number(a);\n        if (rgb.some(isNaN) || isNaN(a)) return null;\n        return new tree.Color(rgb, a);\n    },\n    // Only require val\n    stop: function (val) {\n        var color, mode;\n        if (arguments.length > 1) color = arguments[1];\n        if (arguments.length > 2) mode = arguments[2];\n\n        return {\n            is: 'tag',\n            val: val,\n            color: color,\n            mode: mode,\n            toString: function(env) {\n                return '\\n\\t<stop value=\"' + val.ev(env) + '\"' +\n                    (color ? ' color=\"' + color.ev(env) + '\" ' : '') +\n                    (mode ? ' mode=\"' + mode.ev(env) + '\" ' : '') +\n                    '/>';\n            }\n        };\n    },\n    hsl: function (h, s, l) {\n        return this.hsla(h, s, l, 1.0);\n    },\n    hsla: function (h, s, l, a) {\n        h = (number(h) % 360) / 360;\n        s = number(s); l = number(l); a = number(a);\n        if ([h, s, l, a].some(isNaN)) return null;\n\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,\n            m1 = l * 2 - m2;\n\n        return this.rgba(hue(h + 1/3) * 255,\n                         hue(h)       * 255,\n                         hue(h - 1/3) * 255,\n                         a);\n\n        function hue(h) {\n            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);\n            if      (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n            else if (h * 2 < 1) return m2;\n            else if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;\n            else                return m1;\n        }\n    },\n    hue: function (color) {\n        if (!('toHSL' in color)) return null;\n        return new tree.Dimension(Math.round(color.toHSL().h));\n    },\n    saturation: function (color) {\n        if (!('toHSL' in color)) return null;\n        return new tree.Dimension(Math.round(color.toHSL().s * 100), '%');\n    },\n    lightness: function (color) {\n        if (!('toHSL' in color)) return null;\n        return new tree.Dimension(Math.round(color.toHSL().l * 100), '%');\n    },\n    alpha: function (color) {\n        if (!('toHSL' in color)) return null;\n        return new tree.Dimension(color.toHSL().a);\n    },\n    saturate: function (color, amount) {\n        if (!('toHSL' in color)) return null;\n        var hsl = color.toHSL();\n\n        hsl.s += amount.value / 100;\n        hsl.s = clamp(hsl.s);\n        return hsla(hsl);\n    },\n    desaturate: function (color, amount) {\n        if (!('toHSL' in color)) return null;\n        var hsl = color.toHSL();\n\n        hsl.s -= amount.value / 100;\n        hsl.s = clamp(hsl.s);\n        return hsla(hsl);\n    },\n    lighten: function (color, amount) {\n        if (!('toHSL' in color)) return null;\n        var hsl = color.toHSL();\n\n        hsl.l += amount.value / 100;\n        hsl.l = clamp(hsl.l);\n        return hsla(hsl);\n    },\n    darken: function (color, amount) {\n        if (!('toHSL' in color)) return null;\n        var hsl = color.toHSL();\n\n        hsl.l -= amount.value / 100;\n        hsl.l = clamp(hsl.l);\n        return hsla(hsl);\n    },\n    fadein: function (color, amount) {\n        if (!('toHSL' in color)) return null;\n        var hsl = color.toHSL();\n\n        hsl.a += amount.value / 100;\n        hsl.a = clamp(hsl.a);\n        return hsla(hsl);\n    },\n    fadeout: function (color, amount) {\n        if (!('toHSL' in color)) return null;\n        var hsl = color.toHSL();\n\n        hsl.a -= amount.value / 100;\n        hsl.a = clamp(hsl.a);\n        return hsla(hsl);\n    },\n    spin: function (color, amount) {\n        if (!('toHSL' in color)) return null;\n        var hsl = color.toHSL();\n        var hue = (hsl.h + amount.value) % 360;\n\n        hsl.h = hue < 0 ? 360 + hue : hue;\n\n        return hsla(hsl);\n    },\n    replace: function (entity, a, b) {\n        if (entity.is === 'field') {\n            return entity.toString + '.replace(' + a.toString() + ', ' + b.toString() + ')';\n        } else {\n            return entity.replace(a, b);\n        }\n    },\n    //\n    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein\n    // http://sass-lang.com\n    //\n    mix: function (color1, color2, weight) {\n        var p = weight.value / 100.0;\n        var w = p * 2 - 1;\n        var a = color1.toHSL().a - color2.toHSL().a;\n\n        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n        var w2 = 1 - w1;\n\n        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,\n                   color1.rgb[1] * w1 + color2.rgb[1] * w2,\n                   color1.rgb[2] * w1 + color2.rgb[2] * w2];\n\n        var alpha = color1.alpha * p + color2.alpha * (1 - p);\n\n        return new tree.Color(rgb, alpha);\n    },\n    greyscale: function (color) {\n        return this.desaturate(color, new tree.Dimension(100));\n    },\n    '%': function (quoted /* arg, arg, ...*/) {\n        var args = Array.prototype.slice.call(arguments, 1),\n            str = quoted.value;\n\n        for (var i = 0; i < args.length; i++) {\n            str = str.replace(/%s/,    args[i].value)\n                     .replace(/%[da]/, args[i].toString());\n        }\n        str = str.replace(/%%/g, '%');\n        return new tree.Quoted(str);\n    }\n};\n\nvar image_filter_functors = [\n    'emboss', 'blur', 'gray', 'sobel', 'edge-detect',\n    'x-gradient', 'y-gradient', 'sharpen'];\n\nfor (var i = 0; i < image_filter_functors.length; i++) {\n    var f = image_filter_functors[i];\n    tree.functions[f] = (function(f) {\n        return function() {\n            return new tree.ImageFilter(f);\n        };\n    })(f);\n}\n\ntree.functions['agg-stack-blur'] = function(x, y) {\n    return new tree.ImageFilter('agg-stack-blur', [x, y]);\n};\n\ntree.functions['scale-hsla'] = function(h0,h1,s0,s1,l0,l1,a0,a1) {\n    return new tree.ImageFilter('scale-hsla', [h0,h1,s0,s1,l0,l1,a0,a1]);\n};\n\nfunction hsla(h) {\n    return tree.functions.hsla(h.h, h.s, h.l, h.a);\n}\n\nfunction number(n) {\n    if (n instanceof tree.Dimension) {\n        return parseFloat(n.unit == '%' ? n.value / 100 : n.value);\n    } else if (typeof(n) === 'number') {\n        return n;\n    } else {\n        return NaN;\n    }\n}\n\nfunction clamp(val) {\n    return Math.min(1, Math.max(0, val));\n}\n\n})(require('./tree'));\n\n},{\"./tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\":[function(require,module,exports){\n(function (process,__dirname){\nvar util = require('util'),\n    fs = require('fs'),\n    path = require('path');\n\n\nfunction getVersion() {\n    if (process.browser) {\n        return require('../../package.json').version.split('.');\n    } else if (parseInt(process.version.split('.')[1], 10) > 4) {\n        return require('../../package.json').version.split('.');\n    } else {\n        // older node\n        var package_json = JSON.parse(fs.readFileSync(path.join(__dirname,'../../package.json')));\n        return package_json.version.split('.');\n    }\n}\n\nvar carto = {\n    version: getVersion(),\n    Parser: require('./parser').Parser,\n    Renderer: require('./renderer').Renderer,\n    tree: require('./tree'),\n    RendererJS: require('./renderer_js'),\n    default_reference: require('./torque-reference'),\n\n    // @TODO\n    writeError: function(ctx, options) {\n        var message = '';\n        var extract = ctx.extract;\n        var error = [];\n\n        options = options || {};\n\n        if (options.silent) { return; }\n\n        options.indent = options.indent || '';\n\n        if (!('index' in ctx) || !extract) {\n            return util.error(options.indent + (ctx.stack || ctx.message));\n        }\n\n        if (typeof(extract[0]) === 'string') {\n            error.push(stylize((ctx.line - 1) + ' ' + extract[0], 'grey'));\n        }\n\n        if (extract[1] === '' && typeof extract[2] === 'undefined') {\n            extract[1] = '';\n        }\n        error.push(ctx.line + ' ' + extract[1].slice(0, ctx.column) +\n            stylize(stylize(extract[1][ctx.column], 'bold') +\n            extract[1].slice(ctx.column + 1), 'yellow'));\n\n        if (typeof(extract[2]) === 'string') {\n            error.push(stylize((ctx.line + 1) + ' ' + extract[2], 'grey'));\n        }\n        error = options.indent + error.join('\\n' + options.indent) + '\\033[0m\\n';\n\n        message = options.indent + message + stylize(ctx.message, 'red');\n        if (ctx.filename) (message += stylize(' in ', 'red') + ctx.filename);\n\n        util.error(message, error);\n\n        if (ctx.callLine) {\n            util.error(stylize('from ', 'red') + (ctx.filename || ''));\n            util.error(stylize(ctx.callLine, 'grey') + ' ' + ctx.callExtract);\n        }\n        if (ctx.stack) { util.error(stylize(ctx.stack, 'red')); }\n    }\n};\n\nrequire('./tree/call');\nrequire('./tree/color');\nrequire('./tree/comment');\nrequire('./tree/definition');\nrequire('./tree/dimension');\nrequire('./tree/element');\nrequire('./tree/expression');\nrequire('./tree/filterset');\nrequire('./tree/filter');\nrequire('./tree/field');\nrequire('./tree/keyword');\nrequire('./tree/layer');\nrequire('./tree/literal');\nrequire('./tree/operation');\nrequire('./tree/quoted');\nrequire('./tree/imagefilter');\nrequire('./tree/reference');\nrequire('./tree/rule');\nrequire('./tree/ruleset');\nrequire('./tree/selector');\nrequire('./tree/style');\nrequire('./tree/url');\nrequire('./tree/value');\nrequire('./tree/variable');\nrequire('./tree/zoom');\nrequire('./tree/invalid');\nrequire('./tree/fontset');\nrequire('./tree/frame_offset');\nrequire('./functions');\n\nfor (var k in carto) { exports[k] = carto[k]; }\n\n// Stylize a string\nfunction stylize(str, style) {\n    var styles = {\n        'bold' : [1, 22],\n        'inverse' : [7, 27],\n        'underline' : [4, 24],\n        'yellow' : [33, 39],\n        'green' : [32, 39],\n        'red' : [31, 39],\n        'grey' : [90, 39]\n    };\n    return '\\033[' + styles[style][0] + 'm' + str +\n           '\\033[' + styles[style][1] + 'm';\n}\n\n}).call(this,require('_process'),\"/node_modules/torque.js/node_modules/carto/lib/carto\")\n},{\"../../package.json\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/package.json\",\"./functions\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/functions.js\",\"./parser\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/parser.js\",\"./renderer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/renderer.js\",\"./renderer_js\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/renderer_js.js\",\"./torque-reference\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/torque-reference.js\",\"./tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"./tree/call\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/call.js\",\"./tree/color\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/color.js\",\"./tree/comment\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/comment.js\",\"./tree/definition\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/definition.js\",\"./tree/dimension\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/dimension.js\",\"./tree/element\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/element.js\",\"./tree/expression\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/expression.js\",\"./tree/field\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/field.js\",\"./tree/filter\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/filter.js\",\"./tree/filterset\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/filterset.js\",\"./tree/fontset\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/fontset.js\",\"./tree/frame_offset\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/frame_offset.js\",\"./tree/imagefilter\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/imagefilter.js\",\"./tree/invalid\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/invalid.js\",\"./tree/keyword\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/keyword.js\",\"./tree/layer\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/layer.js\",\"./tree/literal\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/literal.js\",\"./tree/operation\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/operation.js\",\"./tree/quoted\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/quoted.js\",\"./tree/reference\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/reference.js\",\"./tree/rule\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/rule.js\",\"./tree/ruleset\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/ruleset.js\",\"./tree/selector\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/selector.js\",\"./tree/style\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/style.js\",\"./tree/url\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/url.js\",\"./tree/value\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/value.js\",\"./tree/variable\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/variable.js\",\"./tree/zoom\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/zoom.js\",\"_process\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/process/browser.js\",\"fs\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/lib/_empty.js\",\"path\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/path-browserify/index.js\",\"util\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/util/util.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/parser.js\":[function(require,module,exports){\n(function (global){\nvar carto = exports,\n    tree = require('./tree'),\n    _ = global._ || require('underscore');\n\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\ncarto.Parser = function Parser(env) {\n    var input,       // LeSS input string\n        i,           // current index in `input`\n        j,           // current chunk\n        temp,        // temporarily holds a chunk's state, for backtracking\n        memo,        // temporarily holds `i`, when backtracking\n        furthest,    // furthest index the parser has gone to\n        chunks,      // chunkified input\n        current,     // index of current chunk, in `input`\n        parser;\n\n    var that = this;\n\n    // This function is called after all files\n    // have been imported through `@import`.\n    var finish = function() {};\n\n    function save()    {\n        temp = chunks[j];\n        memo = i;\n        current = i;\n    }\n    function restore() {\n        chunks[j] = temp;\n        i = memo;\n        current = i;\n    }\n\n    function sync() {\n        if (i > current) {\n            chunks[j] = chunks[j].slice(i - current);\n            current = i;\n        }\n    }\n    //\n    // Parse from a token, regexp or string, and move forward if match\n    //\n    function $(tok) {\n        var match, args, length, c, index, endIndex, k;\n\n        // Non-terminal\n        if (tok instanceof Function) {\n            return tok.call(parser.parsers);\n        // Terminal\n        // Either match a single character in the input,\n        // or match a regexp in the current chunk (chunk[j]).\n        } else if (typeof(tok) === 'string') {\n            match = input.charAt(i) === tok ? tok : null;\n            length = 1;\n            sync();\n        } else {\n            sync();\n\n            match = tok.exec(chunks[j]);\n            if (match) {\n                length = match[0].length;\n            } else {\n                return null;\n            }\n        }\n\n        // The match is confirmed, add the match length to `i`,\n        // and consume any extra white-space characters (' ' || '\\n')\n        // which come after that. The reason for this is that LeSS's\n        // grammar is mostly white-space insensitive.\n        if (match) {\n            var mem = i += length;\n            endIndex = i + chunks[j].length - length;\n\n            while (i < endIndex) {\n                c = input.charCodeAt(i);\n                if (! (c === 32 || c === 10 || c === 9)) { break; }\n                i++;\n            }\n            chunks[j] = chunks[j].slice(length + (i - mem));\n            current = i;\n\n            if (chunks[j].length === 0 && j < chunks.length - 1) { j++; }\n\n            if (typeof(match) === 'string') {\n                return match;\n            } else {\n                return match.length === 1 ? match[0] : match;\n            }\n        }\n    }\n\n    // Same as $(), but don't change the state of the parser,\n    // just return the match.\n    function peek(tok) {\n        if (typeof(tok) === 'string') {\n            return input.charAt(i) === tok;\n        } else {\n            return !!tok.test(chunks[j]);\n        }\n    }\n\n    function extractErrorLine(style, errorIndex) {\n        return (style.slice(0, errorIndex).match(/\\n/g) || '').length + 1;\n    }\n\n\n    // Make an error object from a passed set of properties.\n    // Accepted properties:\n    // - `message`: Text of the error message.\n    // - `filename`: Filename where the error occurred.\n    // - `index`: Char. index where the error occurred.\n    function makeError(err) {\n        var einput;\n\n        _(err).defaults({\n            index: furthest,\n            filename: env.filename,\n            message: 'Parse error.',\n            line: 0,\n            column: -1\n        });\n\n        if (err.filename && that.env.inputs && that.env.inputs[err.filename]) {\n            einput = that.env.inputs[err.filename];\n        } else {\n            einput = input;\n        }\n\n        err.line = extractErrorLine(einput, err.index);\n        for (var n = err.index; n >= 0 && einput.charAt(n) !== '\\n'; n--) {\n            err.column++;\n        }\n\n        return new Error(_('<%=filename%>:<%=line%>:<%=column%> <%=message%>').template(err));\n    }\n\n    this.env = env = env || {};\n    this.env.filename = this.env.filename || null;\n    this.env.inputs = this.env.inputs || {};\n\n    // The Parser\n    parser = {\n\n        extractErrorLine: extractErrorLine,\n        //\n        // Parse an input string into an abstract syntax tree.\n        // Throws an error on parse errors.\n        parse: function(str) {\n            var root, start, end, zone, line, lines, buff = [], c, error = null;\n\n            i = j = current = furthest = 0;\n            chunks = [];\n            input = str.replace(/\\r\\n/g, '\\n');\n            if (env.filename) {\n                that.env.inputs[env.filename] = input;\n            }\n\n            var early_exit = false;\n\n            // Split the input into chunks.\n            chunks = (function (chunks) {\n                var j = 0,\n                    skip = /(?:@\\{[\\w-]+\\}|[^\"'`\\{\\}\\/\\(\\)\\\\])+/g,\n                    comment = /\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/|\\/\\/.*/g,\n                    string = /\"((?:[^\"\\\\\\r\\n]|\\\\.)*)\"|'((?:[^'\\\\\\r\\n]|\\\\.)*)'|`((?:[^`]|\\\\.)*)`/g,\n                    level = 0,\n                    match,\n                    chunk = chunks[0],\n                    inParam;\n\n                for (var i = 0, c, cc; i < input.length;) {\n                    skip.lastIndex = i;\n                    if (match = skip.exec(input)) {\n                        if (match.index === i) {\n                            i += match[0].length;\n                            chunk.push(match[0]);\n                        }\n                    }\n                    c = input.charAt(i);\n                    comment.lastIndex = string.lastIndex = i;\n\n                    if (match = string.exec(input)) {\n                        if (match.index === i) {\n                            i += match[0].length;\n                            chunk.push(match[0]);\n                            continue;\n                        }\n                    }\n\n                    if (!inParam && c === '/') {\n                        cc = input.charAt(i + 1);\n                        if (cc === '/' || cc === '*') {\n                            if (match = comment.exec(input)) {\n                                if (match.index === i) {\n                                    i += match[0].length;\n                                    chunk.push(match[0]);\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n\n                    switch (c) {\n                        case '{': if (! inParam) { level ++;        chunk.push(c);                           break; }\n                        case '}': if (! inParam) { level --;        chunk.push(c); chunks[++j] = chunk = []; break; }\n                        case '(': if (! inParam) { inParam = true;  chunk.push(c);                           break; }\n                        case ')': if (  inParam) { inParam = false; chunk.push(c);                           break; }\n                        default:                                    chunk.push(c);\n                    }\n\n                    i++;\n                }\n                if (level !== 0) {\n                    error = {\n                        index: i - 1,\n                        type: 'Parse',\n                        message: (level > 0) ? \"missing closing `}`\" : \"missing opening `{`\"\n                    };\n                }\n\n                return chunks.map(function (c) { return c.join(''); });\n            })([[]]);\n\n            if (error) {\n                throw makeError(error);\n            }\n\n            // Start with the primary rule.\n            // The whole syntax tree is held under a Ruleset node,\n            // with the `root` property set to true, so no `{}` are\n            // output.\n            root = new tree.Ruleset([], $(this.parsers.primary));\n            root.root = true;\n\n            // Get an array of Ruleset objects, flattened\n            // and sorted according to specificitySort\n            root.toList = (function() {\n                var line, lines, column;\n                return function(env) {\n                    env.error = function(e) {\n                        if (!env.errors) env.errors = new Error('');\n                        if (env.errors.message) {\n                            env.errors.message += '\\n' + makeError(e).message;\n                        } else {\n                            env.errors.message = makeError(e).message;\n                        }\n                    };\n                    env.frames = env.frames || [];\n\n\n                    // call populates Invalid-caused errors\n                    var definitions = this.flatten([], [], env);\n                    definitions.sort(specificitySort);\n                    return definitions;\n                };\n            })();\n\n            // Sort rules by specificity: this function expects selectors to be\n            // split already.\n            //\n            // Written to be used as a .sort(Function);\n            // argument.\n            //\n            // [1, 0, 0, 467] > [0, 0, 1, 520]\n            var specificitySort = function(a, b) {\n                var as = a.specificity;\n                var bs = b.specificity;\n\n                if (as[0] != bs[0]) return bs[0] - as[0];\n                if (as[1] != bs[1]) return bs[1] - as[1];\n                if (as[2] != bs[2]) return bs[2] - as[2];\n                return bs[3] - as[3];\n            };\n\n            return root;\n        },\n\n        // Here in, the parsing rules/functions\n        //\n        // The basic structure of the syntax tree generated is as follows:\n        //\n        //   Ruleset ->  Rule -> Value -> Expression -> Entity\n        //\n        //  In general, most rules will try to parse a token with the `$()` function, and if the return\n        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n        //  first, before parsing, that's when we use `peek()`.\n        parsers: {\n            // The `primary` rule is the *entry* and *exit* point of the parser.\n            // The rules here can appear at any level of the parse tree.\n            //\n            // The recursive nature of the grammar is an interplay between the `block`\n            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n            // as represented by this simplified grammar:\n            //\n            //     primary    (ruleset | rule)+\n            //     ruleset    selector+ block\n            //     block      '{' primary '}'\n            //\n            // Only at one point is the primary rule not called from the\n            // block rule: at the root level.\n            primary: function() {\n                var node, root = [];\n\n                while ((node = $(this.rule) || $(this.ruleset) ||\n                               $(this.comment)) ||\n                               $(/^[\\s\\n]+/) || (node = $(this.invalid))) {\n                    if (node) root.push(node);\n                }\n                return root;\n            },\n\n            invalid: function () {\n                var chunk = $(/^[^;\\n]*[;\\n]/);\n\n                // To fail gracefully, match everything until a semicolon or linebreak.\n                if (chunk) {\n                    return new tree.Invalid(chunk, memo);\n                }\n            },\n\n            // We create a Comment node for CSS comments `/* */`,\n            // but keep the LeSS comments `//` silent, by just skipping\n            // over them.\n            comment: function() {\n                var comment;\n\n                if (input.charAt(i) !== '/') return;\n\n                if (input.charAt(i + 1) === '/') {\n                    return new tree.Comment($(/^\\/\\/.*/), true);\n                } else if (comment = $(/^\\/\\*(?:[^*]|\\*+[^\\/*])*\\*+\\/\\n?/)) {\n                    return new tree.Comment(comment);\n                }\n            },\n\n            // Entities are tokens which can be found inside an Expression\n            entities: {\n\n                // A string, which supports escaping \" and ' \"milky way\" 'he\\'s the one!'\n                quoted: function() {\n                    if (input.charAt(i) !== '\"' && input.charAt(i) !== \"'\") return;\n                    var str = $(/^\"((?:[^\"\\\\\\r\\n]|\\\\.)*)\"|'((?:[^'\\\\\\r\\n]|\\\\.)*)'/);\n                    if (str) {\n                        return new tree.Quoted(str[1] || str[2]);\n                    }\n                },\n\n                // A reference to a Mapnik field, like [NAME]\n                // Behind the scenes, this has the same representation, but Carto\n                // needs to be careful to warn when unsupported operations are used.\n                field: function() {\n                    if (! $('[')) return;\n                    var field_name = $(/(^[^\\]]+)/);\n                    if (! $(']')) return;\n                    if (field_name) return new tree.Field(field_name[1]);\n                },\n\n                // This is a comparison operator\n                comparison: function() {\n                    var str = $(/^=~|=|!=|<=|>=|<|>/);\n                    if (str) {\n                        return str;\n                    }\n                },\n\n                // A catch-all word, such as: hard-light\n                // These can start with either a letter or a dash (-),\n                // and then contain numbers, underscores, and letters.\n                keyword: function() {\n                    var k = $(/^[A-Za-z-]+[A-Za-z-0-9_]*/);\n                    if (k) { return new tree.Keyword(k); }\n                },\n\n                // A function call like rgb(255, 0, 255)\n                // The arguments are parsed with the `entities.arguments` parser.\n                call: function() {\n                    var name, args;\n\n                    if (!(name = /^([\\w\\-]+|%)\\(/.exec(chunks[j]))) return;\n\n                    name = name[1];\n\n                    if (name === 'url') {\n                        // url() is handled by the url parser instead\n                        return null;\n                    } else {\n                        i += name.length;\n                    }\n\n                    $('('); // Parse the '(' and consume whitespace.\n\n                    args = $(this.entities['arguments']);\n\n                    if (!$(')')) return;\n\n                    if (name) {\n                        return new tree.Call(name, args, i);\n                    }\n                },\n                // Arguments are comma-separated expressions\n                'arguments': function() {\n                    var args = [], arg;\n\n                    while (arg = $(this.expression)) {\n                        args.push(arg);\n                        if (! $(',')) { break; }\n                    }\n\n                    return args;\n                },\n                literal: function() {\n                    return $(this.entities.dimension) ||\n                        $(this.entities.keywordcolor) ||\n                        $(this.entities.hexcolor) ||\n                        $(this.entities.quoted);\n                },\n\n                // Parse url() tokens\n                //\n                // We use a specific rule for urls, because they don't really behave like\n                // standard function calls. The difference is that the argument doesn't have\n                // to be enclosed within a string, so it can't be parsed as an Expression.\n                url: function() {\n                    var value;\n\n                    if (input.charAt(i) !== 'u' || !$(/^url\\(/)) return;\n                    value = $(this.entities.quoted) || $(this.entities.variable) ||\n                            $(/^[\\-\\w%@$\\/.&=:;#+?~]+/) || '';\n                    if (! $(')')) {\n                        return new tree.Invalid(value, memo, 'Missing closing ) in URL.');\n                    } else {\n                        return new tree.URL((typeof value.value !== 'undefined' ||\n                            value instanceof tree.Variable) ?\n                            value : new tree.Quoted(value));\n                    }\n                },\n\n                // A Variable entity, such as `@fink`, in\n                //\n                //     width: @fink + 2px\n                //\n                // We use a different parser for variable definitions,\n                // see `parsers.variable`.\n                variable: function() {\n                    var name, index = i;\n\n                    if (input.charAt(i) === '@' && (name = $(/^@[\\w-]+/))) {\n                        return new tree.Variable(name, index, env.filename);\n                    }\n                },\n\n                hexcolor: function() {\n                    var rgb;\n                    if (input.charAt(i) === '#' && (rgb = $(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/))) {\n                        return new tree.Color(rgb[1]);\n                    }\n                },\n\n                keywordcolor: function() {\n                    var rgb = chunks[j].match(/^[a-z]+/);\n                    if (rgb && rgb[0] in tree.Reference.data.colors) {\n                        return new tree.Color(tree.Reference.data.colors[$(/^[a-z]+/)]);\n                    }\n                },\n\n                // A Dimension, that is, a number and a unit. The only\n                // unit that has an effect is %\n                dimension: function() {\n                    var c = input.charCodeAt(i);\n                    if ((c > 57 || c < 45) || c === 47) return;\n                    var value = $(/^(-?\\d*\\.?\\d+(?:[eE][-+]?\\d+)?)(\\%|\\w+)?/);\n                    if (value) {\n                        return new tree.Dimension(value[1], value[2], memo);\n                    }\n                }\n            },\n\n            // The variable part of a variable definition.\n            // Used in the `rule` parser. Like @fink:\n            variable: function() {\n                var name;\n\n                if (input.charAt(i) === '@' && (name = $(/^(@[\\w-]+)\\s*:/))) {\n                    return name[1];\n                }\n            },\n\n            // Entities are the smallest recognized token,\n            // and can be found inside a rule's value.\n            entity: function() {\n                return $(this.entities.call) ||\n                    $(this.entities.literal) ||\n                    $(this.entities.field) ||\n                    $(this.entities.variable) ||\n                    $(this.entities.url) ||\n                    $(this.entities.keyword);\n            },\n\n            // A Rule terminator. Note that we use `peek()` to check for '}',\n            // because the `block` rule will be expecting it, but we still need to make sure\n            // it's there, if ';' was ommitted.\n            end: function() {\n                return $(';') || peek('}');\n            },\n\n            // Elements are the building blocks for Selectors. They consist of\n            // an element name, such as a tag a class, or `*`.\n            element: function() {\n                var e = $(/^(?:[.#][\\w\\-]+|\\*|Map)/);\n                if (e) return new tree.Element(e);\n            },\n\n            // Attachments allow adding multiple lines, polygons etc. to an\n            // object. There can only be one attachment per selector.\n            attachment: function() {\n                var s = $(/^::([\\w\\-]+(?:\\/[\\w\\-]+)*)/);\n                if (s) return s[1];\n            },\n\n            // Selectors are made out of one or more Elements, see above.\n            selector: function() {\n                var a, attachment,\n                    e, elements = [],\n                    f, filters = new tree.Filterset(),\n                    z, zooms = [],\n                    frame_offset = tree.FrameOffset.none;\n                    segments = 0, conditions = 0;\n\n                while (\n                        (e = $(this.element)) ||\n                        (z = $(this.zoom)) ||\n                        (fo = $(this.frame_offset)) ||\n                        (f = $(this.filter)) ||\n                        (a = $(this.attachment))\n                    ) {\n                    segments++;\n                    if (e) {\n                        elements.push(e);\n                    } else if (z) {\n                        zooms.push(z);\n                        conditions++;\n                    } else if (fo) {\n                        frame_offset = fo;\n                        conditions++;\n                    } else if (f) {\n                        var err = filters.add(f);\n                        if (err) {\n                            throw makeError({\n                                message: err,\n                                index: i - 1\n                            });\n                        }\n                        conditions++;\n                    } else if (attachment) {\n                        throw makeError({\n                            message: 'Encountered second attachment name.',\n                            index: i - 1\n                        });\n                    } else {\n                        attachment = a;\n                    }\n\n                    var c = input.charAt(i);\n                    if (c === '{' || c === '}' || c === ';' || c === ',') { break; }\n                }\n\n                if (segments) {\n                    return new tree.Selector(filters, zooms, frame_offset, elements, attachment, conditions, memo);\n                }\n            },\n\n            filter: function() {\n                save();\n                var key, op, val;\n                if (! $('[')) return;\n                if (key = $(/^[a-zA-Z0-9\\-_]+/) ||\n                    $(this.entities.quoted) ||\n                    $(this.entities.variable) ||\n                    $(this.entities.keyword) ||\n                    $(this.entities.field)) {\n                    // TODO: remove at 1.0.0\n                    if (key instanceof tree.Quoted) {\n                        key = new tree.Field(key.toString());\n                    }\n                    if ((op = $(this.entities.comparison)) &&\n                        (val = $(this.entities.quoted) ||\n                             $(this.entities.variable) ||\n                             $(this.entities.dimension) ||\n                             $(this.entities.keyword) ||\n                             $(this.entities.field))) {\n                        if (! $(']')) {\n                            throw makeError({\n                                message: 'Missing closing ] of filter.',\n                                index: memo - 1\n                            });\n                        }\n                        if (!key.is) key = new tree.Field(key);\n                        return new tree.Filter(key, op, val, memo, env.filename);\n                    }\n                }\n            },\n\n            frame_offset: function() {\n                save();\n                var op, val;\n                if ($(/^\\[\\s*frame-offset/g) &&\n                    (op = $(this.entities.comparison)) &&\n                    (val = $(/^\\d+/)) &&\n                    $(']'))  {\n                        return tree.FrameOffset(op, val, memo);\n                }\n            },\n\n            zoom: function() {\n                save();\n                var op, val;\n                if ($(/^\\[\\s*zoom/g) &&\n                    (op = $(this.entities.comparison)) &&\n                    (val = $(this.entities.variable) || $(this.entities.dimension)) && $(']')) {\n                        return new tree.Zoom(op, val, memo);\n                } else {\n                    // backtrack\n                    restore();\n                }\n            },\n\n            // The `block` rule is used by `ruleset`\n            // It's a wrapper around the `primary` rule, with added `{}`.\n            block: function() {\n                var content;\n\n                if ($('{') && (content = $(this.primary)) && $('}')) {\n                    return content;\n                }\n            },\n\n            // div, .class, body > p {...}\n            ruleset: function() {\n                var selectors = [], s, f, l, rules, filters = [];\n                save();\n\n                while (s = $(this.selector)) {\n                    selectors.push(s);\n                    while ($(this.comment)) {}\n                    if (! $(',')) { break; }\n                    while ($(this.comment)) {}\n                }\n                if (s) {\n                    while ($(this.comment)) {}\n                }\n\n                if (selectors.length > 0 && (rules = $(this.block))) {\n                    if (selectors.length === 1 &&\n                        selectors[0].elements.length &&\n                        selectors[0].elements[0].value === 'Map') {\n                        var rs = new tree.Ruleset(selectors, rules);\n                        rs.isMap = true;\n                        return rs;\n                    }\n                    return new tree.Ruleset(selectors, rules);\n                } else {\n                    // Backtrack\n                    restore();\n                }\n            },\n\n            rule: function() {\n                var name, value, c = input.charAt(i);\n                save();\n\n                if (c === '.' || c === '#') { return; }\n\n                if (name = $(this.variable) || $(this.property)) {\n                    value = $(this.value);\n\n                    if (value && $(this.end)) {\n                        return new tree.Rule(name, value, memo, env.filename);\n                    } else {\n                        furthest = i;\n                        restore();\n                    }\n                }\n            },\n\n            font: function() {\n                var value = [], expression = [], weight, font, e;\n\n                while (e = $(this.entity)) {\n                    expression.push(e);\n                }\n\n                value.push(new tree.Expression(expression));\n\n                if ($(',')) {\n                    while (e = $(this.expression)) {\n                        value.push(e);\n                        if (! $(',')) { break; }\n                    }\n                }\n                return new tree.Value(value);\n            },\n\n            // A Value is a comma-delimited list of Expressions\n            // In a Rule, a Value represents everything after the `:`,\n            // and before the `;`.\n            value: function() {\n                var e, expressions = [];\n\n                while (e = $(this.expression)) {\n                    expressions.push(e);\n                    if (! $(',')) { break; }\n                }\n\n                if (expressions.length > 1) {\n                    return new tree.Value(expressions.map(function(e) {\n                        return e.value[0];\n                    }));\n                } else if (expressions.length === 1) {\n                    return new tree.Value(expressions);\n                }\n            },\n            // A sub-expression, contained by parenthensis\n            sub: function() {\n                var e;\n\n                if ($('(') && (e = $(this.expression)) && $(')')) {\n                    return e;\n                }\n            },\n            // This is a misnomer because it actually handles multiplication\n            // and division.\n            multiplication: function() {\n                var m, a, op, operation;\n                if (m = $(this.operand)) {\n                    while ((op = ($('/') || $('*') || $('%'))) && (a = $(this.operand))) {\n                        operation = new tree.Operation(op, [operation || m, a], memo);\n                    }\n                    return operation || m;\n                }\n            },\n            addition: function() {\n                var m, a, op, operation;\n                if (m = $(this.multiplication)) {\n                    while ((op = $(/^[-+]\\s+/) || (input.charAt(i - 1) != ' ' && ($('+') || $('-')))) &&\n                           (a = $(this.multiplication))) {\n                        operation = new tree.Operation(op, [operation || m, a], memo);\n                    }\n                    return operation || m;\n                }\n            },\n\n            // An operand is anything that can be part of an operation,\n            // such as a Color, or a Variable\n            operand: function() {\n                return $(this.sub) || $(this.entity);\n            },\n\n            // Expressions either represent mathematical operations,\n            // or white-space delimited Entities.  @var * 2\n            expression: function() {\n                var e, delim, entities = [], d;\n\n                while (e = $(this.addition) || $(this.entity)) {\n                    entities.push(e);\n                }\n\n                if (entities.length > 0) {\n                    return new tree.Expression(entities);\n                }\n            },\n            property: function() {\n                var name = $(/^(([a-z][-a-z_0-9]*\\/)?\\*?-?[-a-z_0-9]+)\\s*:/);\n                if (name) return name[1];\n            }\n        }\n    };\n    return parser;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/renderer.js\":[function(require,module,exports){\n(function (global){\nvar _ = global._ || require('underscore');\nvar carto = require('./index');\n\ncarto.Renderer = function Renderer(env, options) {\n    this.env = env || {};\n    this.options = options || {};\n    this.options.mapnik_version = this.options.mapnik_version || '3.0.0';\n};\n\n/**\n * Prepare a MSS document (given as an string) into a\n * XML Style fragment (mostly useful for debugging)\n *\n * @param {String} data the mss contents as a string.\n */\ncarto.Renderer.prototype.renderMSS = function render(data) {\n    // effects is a container for side-effects, which currently\n    // are limited to FontSets.\n    var env = _(this.env).defaults({\n        benchmark: false,\n        validation_data: false,\n        effects: []\n    });\n\n    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {\n        throw new Error(\"Could not set mapnik version to \" + this.options.mapnik_version);\n    }\n\n    var output = [];\n    var styles = [];\n\n    if (env.benchmark) console.time('Parsing MSS');\n    var parser = (carto.Parser(env)).parse(data);\n    if (env.benchmark) console.timeEnd('Parsing MSS');\n\n    if (env.benchmark) console.time('Rule generation');\n    var rule_list = parser.toList(env);\n    if (env.benchmark) console.timeEnd('Rule generation');\n\n    if (env.benchmark) console.time('Rule inheritance');\n    var rules = inheritDefinitions(rule_list, env);\n    if (env.benchmark) console.timeEnd('Rule inheritance');\n\n    if (env.benchmark) console.time('Style sort');\n    var sorted = sortStyles(rules,env);\n    if (env.benchmark) console.timeEnd('Style sort');\n\n    if (env.benchmark) console.time('Total Style generation');\n    for (var k = 0, rule, style_name; k < sorted.length; k++) {\n        rule = sorted[k];\n        style_name = 'style' + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');\n        styles.push(style_name);\n        var bench_name = '\\tStyle \"'+style_name+'\" (#'+k+') toXML';\n        if (env.benchmark) console.time(bench_name);\n        // env.effects can be modified by this call\n        output.push(carto.tree.StyleXML(style_name, rule.attachment, rule, env));\n        if (env.benchmark) console.timeEnd(bench_name);\n    }\n    if (env.benchmark) console.timeEnd('Total Style generation');\n    if (env.errors) throw env.errors;\n    return output.join('\\n');\n};\n\n/**\n * Prepare a MML document (given as an object) into a\n * fully-localized XML file ready for Mapnik2 consumption\n *\n * @param {String} m - the JSON file as a string.\n */\ncarto.Renderer.prototype.render = function render(m) {\n    // effects is a container for side-effects, which currently\n    // are limited to FontSets.\n    var env = _(this.env).defaults({\n        benchmark: false,\n        validation_data: false,\n        effects: [],\n        ppi: 90.714\n    });\n\n    if (!carto.tree.Reference.setVersion(this.options.mapnik_version)) {\n        throw new Error(\"Could not set mapnik version to \" + this.options.mapnik_version);\n    }\n\n    var output = [];\n\n    // Transform stylesheets into definitions.\n    var definitions = _(m.Stylesheet).chain()\n        .map(function(s) {\n            if (typeof s == 'string') {\n                throw new Error(\"Stylesheet object is expected not a string: '\" + s + \"'\");\n            }\n            // Passing the environment from stylesheet to stylesheet,\n            // allows frames and effects to be maintained.\n            env = _(env).extend({filename:s.id});\n\n            var time = +new Date(),\n                root = (carto.Parser(env)).parse(s.data);\n            if (env.benchmark)\n                console.warn('Parsing time: ' + (new Date() - time) + 'ms');\n            return root.toList(env);\n        })\n        .flatten()\n        .value();\n\n    function appliesTo(name, classIndex) {\n        return function(definition) {\n            return definition.appliesTo(l.name, classIndex);\n        };\n    }\n\n    // Iterate through layers and create styles custom-built\n    // for each of them, and apply those styles to the layers.\n    var styles, l, classIndex, rules, sorted, matching;\n    for (var i = 0; i < m.Layer.length; i++) {\n        l = m.Layer[i];\n        styles = [];\n        classIndex = {};\n\n        if (env.benchmark) console.warn('processing layer: ' + l.id);\n        // Classes are given as space-separated alphanumeric strings.\n        var classes = (l['class'] || '').split(/\\s+/g);\n        for (var j = 0; j < classes.length; j++) {\n            classIndex[classes[j]] = true;\n        }\n        matching = definitions.filter(appliesTo(l.name, classIndex));\n        rules = inheritDefinitions(matching, env);\n        sorted = sortStyles(rules, env);\n\n        for (var k = 0, rule, style_name; k < sorted.length; k++) {\n            rule = sorted[k];\n            style_name = l.name + (rule.attachment !== '__default__' ? '-' + rule.attachment : '');\n\n            // env.effects can be modified by this call\n            var styleXML = carto.tree.StyleXML(style_name, rule.attachment, rule, env);\n\n            if (styleXML) {\n                output.push(styleXML);\n                styles.push(style_name);\n            }\n        }\n\n        output.push(carto.tree.LayerXML(l, styles));\n    }\n\n    output.unshift(env.effects.map(function(e) {\n        return e.toXML(env);\n    }).join('\\n'));\n\n    var map_properties = getMapProperties(m, definitions, env);\n\n    // Exit on errors.\n    if (env.errors) throw env.errors;\n\n    // Pass TileJSON and other custom parameters through to Mapnik XML.\n    var parameters = _(m).reduce(function(memo, v, k) {\n        if (!v && v !== 0) return memo;\n\n        switch (k) {\n        // Known skippable properties.\n        case 'srs':\n        case 'Layer':\n        case 'Stylesheet':\n            break;\n        // Non URL-bound TileJSON properties.\n        case 'bounds':\n        case 'center':\n        case 'minzoom':\n        case 'maxzoom':\n        case 'version':\n            memo.push('  <Parameter name=\"' + k + '\">' + v + '</Parameter>');\n            break;\n        // Properties that require CDATA.\n        case 'name':\n        case 'description':\n        case 'legend':\n        case 'attribution':\n        case 'template':\n            memo.push('  <Parameter name=\"' + k + '\"><![CDATA[' + v + ']]></Parameter>');\n            break;\n        // Mapnik image format.\n        case 'format':\n            memo.push('  <Parameter name=\"' + k + '\">' + v + '</Parameter>');\n            break;\n        // Mapnik interactivity settings.\n        case 'interactivity':\n            memo.push('  <Parameter name=\"interactivity_layer\">' + v.layer + '</Parameter>');\n            memo.push('  <Parameter name=\"interactivity_fields\">' + v.fields + '</Parameter>');\n            break;\n        // Support any additional scalar properties.\n        default:\n            if ('string' === typeof v) {\n                memo.push('  <Parameter name=\"' + k + '\"><![CDATA[' + v + ']]></Parameter>');\n            } else if ('number' === typeof v) {\n                memo.push('  <Parameter name=\"' + k + '\">' + v + '</Parameter>');\n            } else if ('boolean' === typeof v) {\n                memo.push('  <Parameter name=\"' + k + '\">' + v + '</Parameter>');\n            }\n            break;\n        }\n        return memo;\n    }, []);\n    if (parameters.length) output.unshift(\n        '<Parameters>\\n' +\n        parameters.join('\\n') +\n        '\\n</Parameters>\\n'\n    );\n\n    var properties = _(map_properties).map(function(v) { return ' ' + v; }).join('');\n\n    output.unshift(\n        '<?xml version=\"1.0\" ' +\n        'encoding=\"utf-8\"?>\\n' +\n        '<!DOCTYPE Map[]>\\n' +\n        '<Map' + properties +'>\\n');\n    output.push('</Map>');\n    return output.join('\\n');\n};\n\n/**\n * This function currently modifies 'current'\n * @param {Array}  current  current list of rules\n * @param {Object} definition a Definition object to add to the rules\n * @param {Object} byFilter an object/dictionary of existing filters. This is\n * actually keyed `attachment->filter`\n * @param {Object} env the current environment\n*/\nfunction addRules(current, definition, byFilter, env) {\n    var newFilters = definition.filters,\n        newRules = definition.rules,\n        updatedFilters, clone, previous;\n\n    // The current definition might have been split up into\n    // multiple definitions already.\n    for (var k = 0; k < current.length; k++) {\n        updatedFilters = current[k].filters.cloneWith(newFilters);\n        if (updatedFilters) {\n            previous = byFilter[updatedFilters];\n            if (previous) {\n                // There's already a definition with those exact\n                // filters. Add the current definitions' rules\n                // and stop processing it as the existing rule\n                // has already gone down the inheritance chain.\n                previous.addRules(newRules);\n            } else {\n                clone = current[k].clone(updatedFilters);\n                // Make sure that we're only maintaining the clone\n                // when we did actually add rules. If not, there's\n                // no need to keep the clone around.\n                if (clone.addRules(newRules)) {\n                    // We inserted an element before this one, so we need\n                    // to make sure that in the next loop iteration, we're\n                    // not performing the same task for this element again,\n                    // hence the k++.\n                    byFilter[updatedFilters] = clone;\n                    current.splice(k, 0, clone);\n                    k++;\n                }\n            }\n        } else if (updatedFilters === null) {\n            // if updatedFilters is null, then adding the filters doesn't\n            // invalidate or split the selector, so we addRules to the\n            // combined selector\n\n            // Filters can be added, but they don't change the\n            // filters. This means we don't have to split the\n            // definition.\n            //\n            // this is cloned here because of shared classes, see\n            // sharedclass.mss\n            current[k] = current[k].clone();\n            current[k].addRules(newRules);\n        }\n        // if updatedFeatures is false, then the filters split the rule,\n        // so they aren't the same inheritance chain\n    }\n    return current;\n}\n\n/**\n * Apply inherited styles from their ancestors to them.\n *\n * called either once per render (in the case of mss) or per layer\n * (for mml)\n *\n * @param {Object} definitions - a list of definitions objects\n *   that contain .rules\n * @param {Object} env - the environment\n * @return {Array<Array>} an array of arrays is returned,\n *   in which each array refers to a specific attachment\n */\nfunction inheritDefinitions(definitions, env) {\n    var inheritTime = +new Date();\n    // definitions are ordered by specificity,\n    // high (index 0) to low\n    var byAttachment = {},\n        byFilter = {};\n    var result = [];\n    var current, previous, attachment;\n\n    // Evaluate the filters specified by each definition with the given\n    // environment to correctly resolve variable references\n    definitions.forEach(function(d) {\n        d.filters.ev(env);\n    });\n\n    for (var i = 0; i < definitions.length; i++) {\n\n        attachment = definitions[i].attachment;\n        current = [definitions[i]];\n\n        if (!byAttachment[attachment]) {\n            byAttachment[attachment] = [];\n            byAttachment[attachment].attachment = attachment;\n            byFilter[attachment] = {};\n            result.push(byAttachment[attachment]);\n        }\n\n        // Iterate over all subsequent rules.\n        for (var j = i + 1; j < definitions.length; j++) {\n            if (definitions[j].attachment === attachment) {\n                // Only inherit rules from the same attachment.\n                current = addRules(current, definitions[j], byFilter[attachment], env);\n            }\n        }\n\n        for (var k = 0; k < current.length; k++) {\n            byFilter[attachment][current[k].filters] = current[k];\n            byAttachment[attachment].push(current[k]);\n        }\n    }\n\n    if (env.benchmark) console.warn('Inheritance time: ' + ((new Date() - inheritTime)) + 'ms');\n\n    return result;\n\n}\n\n// Sort styles by the minimum index of their rules.\n// This sorts a slice of the styles, so it returns a sorted\n// array but does not change the input.\nfunction sortStylesIndex(a, b) { return b.index - a.index; }\nfunction sortStyles(styles, env) {\n    for (var i = 0; i < styles.length; i++) {\n        var style = styles[i];\n        style.index = Infinity;\n        for (var b = 0; b < style.length; b++) {\n            var rules = style[b].rules;\n            for (var r = 0; r < rules.length; r++) {\n                var rule = rules[r];\n                if (rule.index < style.index) {\n                    style.index = rule.index;\n                }\n            }\n        }\n    }\n\n    var result = styles.slice();\n    result.sort(sortStylesIndex);\n    return result;\n}\n\n/**\n * Find a rule like Map { background-color: #fff; },\n * if any, and return a list of properties to be inserted\n * into the <Map element of the resulting XML. Translates\n * properties of the mml object at `m` directly into XML\n * properties.\n *\n * @param {Object} m the mml object.\n * @param {Array} definitions the output of toList.\n * @param {Object} env\n * @return {String} rendered properties.\n */\nfunction getMapProperties(m, definitions, env) {\n    var rules = {};\n    var symbolizers = carto.tree.Reference.data.symbolizers.map;\n\n    _(m).each(function(value, key) {\n        if (key in symbolizers) rules[key] = key + '=\"' + value + '\"';\n    });\n\n    definitions.filter(function(r) {\n        return r.elements.join('') === 'Map';\n    }).forEach(function(r) {\n        for (var i = 0; i < r.rules.length; i++) {\n            var key = r.rules[i].name;\n            if (!(key in symbolizers)) {\n                env.error({\n                    message: 'Rule ' + key + ' not allowed for Map.',\n                    index: r.rules[i].index\n                });\n            }\n            rules[key] = r.rules[i].ev(env).toXML(env);\n        }\n    });\n    return rules;\n}\n\nmodule.exports = carto;\nmodule.exports.addRules = addRules;\nmodule.exports.inheritDefinitions = inheritDefinitions;\nmodule.exports.sortStyles = sortStyles;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./index\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/renderer_js.js\":[function(require,module,exports){\n(function (global){\n(function(carto) {\nvar tree = require('./tree');\nvar _ = global._ || require('underscore');\n\n\nfunction CartoCSS(style, options) {\n  this.options = options || {};\n  this.imageURLs = [];\n  if(style) {\n    this.setStyle(style);\n  }\n}\n\nCartoCSS.Layer = function(shader, options) {\n  this.options = options;\n  this.shader = shader;\n};\n\n\nCartoCSS.Layer.prototype = {\n\n  fullName: function() {\n    return this.shader.attachment;\n  },\n\n  name: function() {\n    return this.fullName().split('::')[0];\n  },\n\n  // frames this layer need to be rendered\n  frames: function() {\n    return this.shader.frames;\n  },\n\n  attachment: function() {\n    return this.fullName().split('::')[1];\n  },\n\n  eval: function(prop) {\n    var p = this.shader[prop];\n    if (!p || !p.style) return;\n    return p.style({}, { zoom: 0, 'frame-offset': 0 });\n  },\n\n  /*\n   * `props`: feature properties\n   * `context`: rendering properties, i.e zoom\n   */\n  getStyle: function(props, context) {\n    var style = {};\n    for(var i in this.shader) {\n      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {\n        style[i] = this.shader[i].style(props, context);\n      }\n    }\n    return style;\n  },\n\n  /**\n   * return the symbolizers that need to be rendered with \n   * this style. The order is the rendering order.\n   * @returns a list with 3 possible values 'line', 'marker', 'polygon'\n   */\n  getSymbolizers: function() {\n    return this.shader.symbolizers;\n  },\n\n  /**\n   * returns if the style varies with some feature property.\n   * Useful to optimize rendering\n   */\n  isVariable: function() {\n    for(var i in this.shader) {\n      if(i !== 'attachment' && i !== 'zoom' && i !== 'frames' && i !== 'symbolizers') {\n        if (!this.shader[i].constant) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n\n  getShader: function() {\n    return this.shader;\n  },\n\n  /**\n   * returns true if a feature needs to be rendered\n   */\n  filter: function(featureType, props, context) {\n    for(var i in this.shader) {\n     var s = this.shader[i](props, context);\n     if(s) {\n       return true;\n     }\n    }\n    return false;\n  },\n\n  //\n  // given a geoemtry type returns the transformed one acording the CartoCSS\n  // For points there are two kind of types: point and sprite, the first one \n  // is a circle, second one is an image sprite\n  //\n  // the other geometry types are the same than geojson (polygon, linestring...)\n  //\n  transformGeometry: function(type) {\n    return type;\n  },\n\n  transformGeometries: function(geojson) {\n    return geojson;\n  }\n\n};\n\nCartoCSS.prototype = {\n\n  setStyle: function(style) {\n    var layers = this.parse(style);\n    if(!layers) {\n      throw new Error(this.parse_env.errors);\n    }\n    this.layers = layers.map(function(shader) {\n        return new CartoCSS.Layer(shader);\n    });\n  },\n\n  getLayers: function() {\n    return this.layers;\n  },\n\n  getDefault: function() {\n    return this.findLayer({ attachment: '__default__' });\n  },\n\n  findLayer: function(where) {\n    return _.find(this.layers, function(value) {\n      for (var key in where) {\n        var v = value[key];\n        if (typeof(v) === 'function') {\n          v = v.call(value);\n        }\n        if (where[key] !== v) return false;\n      }\n      return true;\n    });\n  },\n\n  _createFn: function(ops) {\n    var body = ops.join('\\n');\n    if(this.options.debug) console.log(body);\n    return Function(\"data\",\"ctx\", \"var _value = null; \" +  body + \"; return _value; \");\n  },\n\n  _compile: function(shader) {\n    if(typeof shader === 'string') {\n        shader = eval(\"(function() { return \" + shader +\"; })()\");\n    }\n    this.shader_src = shader;\n    for(var attr in shader) {\n        var c = mapper[attr];\n        if(c) {\n            this.compiled[c] = eval(\"(function() { return shader[attr]; })();\");\n        }\n    }\n  },\n  getImageURLs: function(){\n    return this.imageURLs;\n  },\n\n  parse: function(cartocss) {\n    var parse_env = {\n      frames: [],\n      errors: [],\n      error: function(obj) {\n        this.errors.push(obj);\n      }\n    };\n    this.parse_env = parse_env;\n\n    var ruleset = null;\n    try {\n      ruleset = (new carto.Parser(parse_env)).parse(cartocss);\n    } catch(e) {\n      // add the style.mss string to match the response from the server\n      parse_env.errors.push(e.message);\n      return;\n    }\n    if(ruleset) {\n\n      function defKey(def) {\n        return def.elements[0] + \"::\" + def.attachment;\n      }\n      var defs = ruleset.toList(parse_env);\n      defs.reverse();\n      // group by elements[0].value::attachment\n      var layers = {};\n      for(var i = 0; i < defs.length; ++i) {\n        var def = defs[i];\n        var key = defKey(def);\n        var layer = layers[key] = (layers[key] || {\n          symbolizers: []\n        });\n        for(var u = 0; u<def.rules.length; u++){\n            if(def.rules[u].name === \"marker-file\" || def.rules[u].name === \"point-file\"){\n                var value = def.rules[u].value.value[0].value[0].value.value;\n                this.imageURLs.push(value);\n            }\n        } \n        layer.frames = [];\n        layer.zoom = tree.Zoom.all;\n        var props = def.toJS(parse_env);\n        if (this.options.debug) console.log(\"props\", props);\n        for(var v in props) {\n          var lyr = layer[v] = layer[v] || {\n            constant: false,\n            symbolizer: null,\n            js: [],\n            index: 0\n          };\n          // build javascript statements\n          lyr.js.push(props[v].map(function(a) { return a.js; }).join('\\n'));\n          // get symbolizer for prop\n          lyr.symbolizer = _.first(props[v].map(function(a) { return a.symbolizer; }));\n          // serach the max index to know rendering order\n          lyr.index = _.max(props[v].map(function(a) { return a.index; }).concat(lyr.index));\n          lyr.constant = !_.any(props[v].map(function(a) { return !a.constant; }));\n        }\n      }\n\n      var ordered_layers = [];\n      if (this.options.debug) console.log(layers);\n\n      var done = {};\n      for(var i = 0; i < defs.length; ++i) {\n        var def = defs[i];\n        var k = defKey(def);\n        var layer = layers[k];\n        if(!done[k]) {\n          if(this.options.debug) console.log(\"**\", k);\n          for(var prop in layer) {\n            if (prop !== 'zoom' && prop !== 'frames' && prop !== 'symbolizers') {\n              if(this.options.debug) console.log(\"*\", prop);\n              layer[prop].style = this._createFn(layer[prop].js);\n              layer.symbolizers.push(layer[prop].symbolizer);\n              layer.symbolizers = _.uniq(layer.symbolizers);\n            }\n          }\n          layer.attachment = k;\n          ordered_layers.push(layer);\n          done[k] = true;\n        }\n        layer.zoom |= def.zoom;\n        layer.frames.push(def.frame_offset);\n      }\n\n      // uniq the frames\n      for(i = 0; i < ordered_layers.length; ++i) {\n        ordered_layers[i].frames = _.uniq(ordered_layers[i].frames);\n      }\n\n      return ordered_layers;\n\n    }\n    return null;\n  }\n};\n\n\ncarto.RendererJS = function (options) {\n    this.options = options || {};\n    this.options.mapnik_version = this.options.mapnik_version || 'latest';\n};\n\n// Prepare a javascript object which contains the layers\ncarto.RendererJS.prototype.render = function render(cartocss, callback) {\n    var reference = require('./torque-reference');\n    tree.Reference.setData(reference.version.latest);\n    return new CartoCSS(cartocss, this.options);\n}\n\nif(typeof(module) !== 'undefined') {\n  module.exports = carto.RendererJS;\n}\n\n\n})(require('../carto'));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../carto\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/index.js\",\"./torque-reference\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/torque-reference.js\",\"./tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/torque-reference.js\":[function(require,module,exports){\nvar _mapnik_reference_latest = {\n    \"version\": \"2.1.1\",\n    \"style\": {\n        \"filter-mode\": {\n            \"type\": [\n                \"all\",\n                \"first\"\n            ],\n            \"doc\": \"Control the processing behavior of Rule filters within a Style. If 'all' is used then all Rules are processed sequentially independent of whether any previous filters matched. If 'first' is used then it means processing ends after the first match (a positive filter evaluation) and no further Rules in the Style are processed ('first' is usually the default for CSS implementations on top of Mapnik to simplify translation from CSS to Mapnik XML)\",\n            \"default-value\": \"all\",\n            \"default-meaning\": \"All Rules in a Style are processed whether they have filters or not and whether or not the filter conditions evaluate to true.\"\n        },\n        \"image-filters\": {\n            \"css\": \"image-filters\",\n            \"default-value\": \"none\",\n            \"default-meaning\": \"no filters\",\n            \"type\": \"functions\",\n            \"functions\": [\n                [\"agg-stack-blur\", 2],\n                [\"emboss\", 0],\n                [\"blur\", 0],\n                [\"gray\", 0],\n                [\"sobel\", 0],\n                [\"edge-detect\", 0],\n                [\"x-gradient\", 0],\n                [\"y-gradient\", 0],\n                [\"invert\", 0],\n                [\"sharpen\", 0],\n                [\"colorize-alpha\", -1],\n                [\"color-to-alpha\", 1],\n                [\"scale-hsla\", 8]\n            ],\n            \"doc\": \"A list of image filters.\"\n        },\n        \"comp-op\": {\n            \"css\": \"comp-op\",\n            \"default-value\": \"src-over\",\n            \"default-meaning\": \"add the current layer on top of other layers\",\n            \"doc\": \"Composite operation. This defines how this layer should behave relative to layers atop or below it.\",\n            \"type\": [\"clear\",\n                \"src\",\n                \"dst\",\n                \"src-over\",\n                \"source-over\", // added for torque\n                \"dst-over\",\n                \"src-in\",\n                \"dst-in\",\n                \"src-out\",\n                \"dst-out\",\n                \"src-atop\",\n                \"dst-atop\",\n                \"xor\",\n                \"plus\",\n                \"minus\",\n                \"multiply\",\n                \"screen\",\n                \"overlay\",\n                \"darken\",\n                \"lighten\",\n                \"lighter\", // added for torque\n                \"color-dodge\",\n                \"color-burn\",\n                \"hard-light\",\n                \"soft-light\",\n                \"difference\",\n                \"exclusion\",\n                \"contrast\",\n                \"invert\",\n                \"invert-rgb\",\n                \"grain-merge\",\n                \"grain-extract\",\n                \"hue\",\n                \"saturation\",\n                \"color\",\n                \"value\"\n            ]\n        },\n        \"opacity\": {\n            \"css\": \"opacity\",\n            \"type\": \"float\",\n            \"doc\": \"An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)\",\n            \"default-value\": 1,\n            \"default-meaning\": \"no separate buffer will be used and no alpha will be applied to the style after rendering\"\n        }\n    },\n    \"layer\" : {\n        \"name\": {\n            \"default-value\": \"\",\n            \"type\":\"string\",\n            \"required\" : true,\n            \"default-meaning\": \"No layer name has been provided\",\n            \"doc\": \"The name of a layer. Can be anything you wish and is not strictly validated, but ideally unique  in the map\"\n        },\n        \"srs\": {\n            \"default-value\": \"\",\n            \"type\":\"string\",\n            \"default-meaning\": \"No srs value is provided and the value will be inherited from the Map's srs\",\n            \"doc\": \"The spatial reference system definition for the layer, aka the projection. Can either be a proj4 literal string like '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs' or, if the proper proj4 epsg/nad/etc identifier files are installed, a string that uses an id like: '+init=epsg:4326'\"\n        },\n        \"status\": {\n            \"default-value\": true,\n            \"type\":\"boolean\",\n            \"default-meaning\": \"This layer will be marked as active and available for processing\",\n            \"doc\": \"A property that can be set to false to disable this layer from being processed\"\n        },\n        \"minzoom\": {\n            \"default-value\": \"0\",\n            \"type\":\"float\",\n            \"default-meaning\": \"The layer will be visible at the minimum possible scale\",\n            \"doc\": \"The minimum scale denominator that this layer will be visible at. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6\"\n        },\n        \"maxzoom\": {\n            \"default-value\": \"1.79769e+308\",\n            \"type\":\"float\",\n            \"default-meaning\": \"The layer will be visible at the maximum possible scale\",\n            \"doc\": \"The maximum scale denominator that this layer will be visible at. The default is the numeric limit of the C++ double type, which may vary slightly by system, but is likely a massive number like 1.79769e+308 and ensures that this layer will always be visible unless the value is reduced. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6\"\n        },\n        \"queryable\": {\n            \"default-value\": false,\n            \"type\":\"boolean\",\n            \"default-meaning\": \"The layer will not be available for the direct querying of data values\",\n            \"doc\": \"This property was added for GetFeatureInfo/WMS compatibility and is rarely used. It is off by default meaning that in a WMS context the layer will not be able to be queried unless the property is explicitly set to true\"\n        },\n        \"clear-label-cache\": {\n            \"default-value\": false,\n            \"type\":\"boolean\",\n            \"default-meaning\": \"The renderer's collision detector cache (used for avoiding duplicate labels and overlapping markers) will not be cleared immediately before processing this layer\",\n            \"doc\": \"This property, by default off, can be enabled to allow a user to clear the collision detector cache before a given layer is processed. This may be desirable to ensure that a given layers data shows up on the map even if it normally would not because of collisions with previously rendered labels or markers\"\n        },\n        \"group-by\": {\n            \"default-value\": \"\",\n            \"type\":\"string\",\n            \"default-meaning\": \"No special layer grouping will be used during rendering\",\n            \"doc\": \"https://github.com/mapnik/mapnik/wiki/Grouped-rendering\"\n        },\n        \"buffer-size\": {\n            \"default-value\": \"0\",\n            \"type\":\"float\",\n            \"default-meaning\": \"No buffer will be used\",\n            \"doc\": \"Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering\"\n        },\n        \"maximum-extent\": {\n            \"default-value\": \"none\",\n            \"type\":\"bbox\",\n            \"default-meaning\": \"No clipping extent will be used\",\n            \"doc\": \"An extent to be used to limit the bounds used to query this specific layer data during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Layer.\"\n        }\n    },\n    \"symbolizers\" : {\n        \"*\": {\n            \"image-filters\": {\n                \"css\": \"image-filters\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"no filters\",\n                \"type\": \"functions\",\n                \"functions\": [\n                    [\"agg-stack-blur\", 2],\n                    [\"emboss\", 0],\n                    [\"blur\", 0],\n                    [\"gray\", 0],\n                    [\"sobel\", 0],\n                    [\"edge-detect\", 0],\n                    [\"x-gradient\", 0],\n                    [\"y-gradient\", 0],\n                    [\"invert\", 0],\n                    [\"sharpen\", 0],\n                    [\"colorize-alpha\", -1],\n                    [\"color-to-alpha\", 1],\n                    [\"scale-hsla\", 8]\n                ],\n                \"doc\": \"A list of image filters.\"\n            },\n            \"comp-op\": {\n                \"css\": \"comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current layer on top of other layers\",\n                \"doc\": \"Composite operation. This defines how this layer should behave relative to layers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"source-over\", // added for torque\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"lighter\", // added for torque\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            },\n            \"opacity\": {\n                \"css\": \"opacity\",\n                \"type\": \"float\",\n                \"doc\": \"An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)\",\n                \"default-value\": 1,\n                \"default-meaning\": \"no separate buffer will be used and no alpha will be applied to the style after rendering\"\n            }\n        },\n        \"map\": {\n            \"background-color\": {\n                \"css\": \"background-color\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"transparent\",\n                \"type\": \"color\",\n                \"doc\": \"Map Background color\"\n            },\n            \"background-image\": {\n                \"css\": \"background-image\",\n                \"type\": \"uri\",\n                \"default-value\": \"\",\n                \"default-meaning\": \"transparent\",\n                \"doc\": \"An image that is repeated below all features on a map as a background.\",\n                \"description\": \"Map Background image\"\n            },\n            \"srs\": {\n                \"css\": \"srs\",\n                \"type\": \"string\",\n                \"default-value\": \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\",\n                \"default-meaning\": \"The proj4 literal of EPSG:4326 is assumed to be the Map's spatial reference and all data from layers within this map will be plotted using this coordinate system. If any layers do not declare an srs value then they will be assumed to be in the same srs as the Map and not transformations will be needed to plot them in the Map's coordinate space\",\n                \"doc\": \"Map spatial reference (proj4 string)\"\n            },\n            \"buffer-size\": {\n                \"css\": \"buffer-size\",\n                \"default-value\": \"0\",\n                \"type\":\"float\",\n                \"default-meaning\": \"No buffer will be used\",\n                \"doc\": \"Extra tolerance around the map (in pixels) used to ensure labels crossing tile boundaries are equally rendered in each tile (e.g. cut in each tile). Not intended to be used in combination with \\\"avoid-edges\\\".\"\n            },\n            \"maximum-extent\": {\n                \"css\": \"\",\n                \"default-value\": \"none\",\n                \"type\":\"bbox\",\n                \"default-meaning\": \"No clipping extent will be used\",\n                \"doc\": \"An extent to be used to limit the bounds used to query all layers during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Map.\"\n            },\n            \"base\": {\n                \"css\": \"base\",\n                \"default-value\": \"\",\n                \"default-meaning\": \"This base path defaults to an empty string meaning that any relative paths to files referenced in styles or layers will be interpreted relative to the application process.\",\n                \"type\": \"string\",\n                \"doc\": \"Any relative paths used to reference files will be understood as relative to this directory path if the map is loaded from an in memory object rather than from the filesystem. If the map is loaded from the filesystem and this option is not provided it will be set to the directory of the stylesheet.\"\n            },\n            \"paths-from-xml\": {\n                \"css\": \"\",\n                \"default-value\": true,\n                \"default-meaning\": \"Paths read from XML will be interpreted from the location of the XML\",\n                \"type\": \"boolean\",\n                \"doc\": \"value to control whether paths in the XML will be interpreted from the location of the XML or from the working directory of the program that calls load_map()\"\n            },\n            \"minimum-version\": {\n                \"css\": \"\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"Mapnik version will not be detected and no error will be thrown about compatibility\",\n                \"type\": \"string\",\n                \"doc\": \"The minumum Mapnik version (e.g. 0.7.2) needed to use certain functionality in the stylesheet\"\n            },\n            \"font-directory\": {\n                \"css\": \"font-directory\",\n                \"type\": \"uri\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"No map-specific fonts will be registered\",\n                \"doc\": \"Path to a directory which holds fonts which should be registered when the Map is loaded (in addition to any fonts that may be automatically registered).\"\n            }\n        },\n        \"polygon\": {\n            \"fill\": {\n                \"css\": \"polygon-fill\",\n                \"type\": \"color\",\n                \"default-value\": \"rgba(128,128,128,1)\",\n                \"default-meaning\": \"gray and fully opaque (alpha = 1), same as rgb(128,128,128)\",\n                \"doc\": \"Fill color to assign to a polygon\"\n            },\n            \"fill-opacity\": {\n                \"css\": \"polygon-opacity\",\n                \"type\": \"float\",\n                \"doc\": \"The opacity of the polygon\",\n                \"default-value\": 1,\n                \"default-meaning\": \"opaque\"\n            },\n            \"gamma\": {\n                \"css\": \"polygon-gamma\",\n                \"type\": \"float\",\n                \"default-value\": 1,\n                \"default-meaning\": \"fully antialiased\",\n                \"range\": \"0-1\",\n                \"doc\": \"Level of antialiasing of polygon edges\"\n            },\n            \"gamma-method\": {\n                \"css\": \"polygon-gamma-method\",\n                \"type\": [\n                    \"power\",\n                    \"linear\",\n                    \"none\",\n                    \"threshold\",\n                    \"multiply\"\n                ],\n                \"default-value\": \"power\",\n                \"default-meaning\": \"pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA\",\n                \"doc\": \"An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h\"\n            },\n            \"clip\": {\n                \"css\": \"polygon-clip\",\n                \"type\": \"boolean\",\n                \"default-value\": true,\n                \"default-meaning\": \"geometry will be clipped to map bounds before rendering\",\n                \"doc\": \"geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts.\"\n            },\n            \"smooth\": {\n                \"css\": \"polygon-smooth\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no smoothing\",\n                \"range\": \"0-1\",\n                \"doc\": \"Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries.\"\n            },\n            \"geometry-transform\": {\n                \"css\": \"polygon-geometry-transform\",\n                \"type\": \"functions\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"geometry will not be transformed\",\n                \"doc\": \"Allows transformation functions to be applied to the geometry.\",\n                \"functions\": [\n                    [\"matrix\", 6],\n                    [\"translate\", 2],\n                    [\"scale\", 2],\n                    [\"rotate\", 3],\n                    [\"skewX\", 1],\n                    [\"skewY\", 1]\n                ]\n            },\n            \"comp-op\": {\n                \"css\": \"polygon-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"line\": {\n            \"stroke\": {\n                \"css\": \"line-color\",\n                \"default-value\": \"rgba(0,0,0,1)\",\n                \"type\": \"color\",\n                \"default-meaning\": \"black and fully opaque (alpha = 1), same as rgb(0,0,0)\",\n                \"doc\": \"The color of a drawn line\"\n            },\n            \"stroke-width\": {\n                \"css\": \"line-width\",\n                \"default-value\": 1,\n                \"type\": \"float\",\n                \"doc\": \"The width of a line in pixels\"\n            },\n            \"stroke-opacity\": {\n                \"css\": \"line-opacity\",\n                \"default-value\": 1,\n                \"type\": \"float\",\n                \"default-meaning\": \"opaque\",\n                \"doc\": \"The opacity of a line\"\n            },\n            \"stroke-linejoin\": {\n                \"css\": \"line-join\",\n                \"default-value\": \"miter\",\n                \"type\": [\n                    \"miter\",\n                    \"round\",\n                    \"bevel\"\n                ],\n                \"doc\": \"The behavior of lines when joining\"\n            },\n            \"stroke-linecap\": {\n                \"css\": \"line-cap\",\n                \"default-value\": \"butt\",\n                \"type\": [\n                    \"butt\",\n                    \"round\",\n                    \"square\"\n                ],\n                \"doc\": \"The display of line endings\"\n            },\n            \"stroke-gamma\": {\n                \"css\": \"line-gamma\",\n                \"type\": \"float\",\n                \"default-value\": 1,\n                \"default-meaning\": \"fully antialiased\",\n                \"range\": \"0-1\",\n                \"doc\": \"Level of antialiasing of stroke line\"\n            },\n            \"stroke-gamma-method\": {\n                \"css\": \"line-gamma-method\",\n                \"type\": [\n                    \"power\",\n                    \"linear\",\n                    \"none\",\n                    \"threshold\",\n                    \"multiply\"\n                ],\n                \"default-value\": \"power\",\n                \"default-meaning\": \"pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA\",\n                \"doc\": \"An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h\"\n            },\n            \"stroke-dasharray\": {\n                \"css\": \"line-dasharray\",\n                \"type\": \"numbers\",\n                \"doc\": \"A pair of length values [a,b], where (a) is the dash length and (b) is the gap length respectively. More than two values are supported for more complex patterns.\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"solid line\"\n            },\n            \"stroke-dashoffset\": {\n                \"css\": \"line-dash-offset\",\n                \"type\": \"numbers\",\n                \"doc\": \"valid parameter but not currently used in renderers (only exists for experimental svg support in Mapnik which is not yet enabled)\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"solid line\"\n            },\n            \"stroke-miterlimit\": {\n                \"css\": \"line-miterlimit\",\n                \"type\": \"float\",\n                \"doc\": \"The limit on the ratio of the miter length to the stroke-width. Used to automatically convert miter joins to bevel joins for sharp angles to avoid the miter extending beyond the thickness of the stroking path. Normally will not need to be set, but a larger value can sometimes help avoid jaggy artifacts.\",\n                \"default-value\": 4.0,\n                \"default-meaning\": \"Will auto-convert miters to bevel line joins when theta is less than 29 degrees as per the SVG spec: 'miterLength / stroke-width = 1 / sin ( theta / 2 )'\"\n            },\n            \"clip\": {\n                \"css\": \"line-clip\",\n                \"type\": \"boolean\",\n                \"default-value\": true,\n                \"default-meaning\": \"geometry will be clipped to map bounds before rendering\",\n                \"doc\": \"geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts.\"\n            },\n            \"smooth\": {\n                \"css\": \"line-smooth\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no smoothing\",\n                \"range\": \"0-1\",\n                \"doc\": \"Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries.\"\n            },\n            \"offset\": {\n                \"css\": \"line-offset\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no offset\",\n                \"doc\": \"Offsets a line a number of pixels parallel to its actual path. Postive values move the line left, negative values move it right (relative to the directionality of the line).\"\n            },\n            \"rasterizer\": {\n                \"css\": \"line-rasterizer\",\n                \"type\": [\n                    \"full\",\n                    \"fast\"\n                ],\n                \"default-value\": \"full\",\n                \"doc\": \"Exposes an alternate AGG rendering method that sacrifices some accuracy for speed.\"\n            },\n            \"geometry-transform\": {\n                \"css\": \"line-geometry-transform\",\n                \"type\": \"functions\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"geometry will not be transformed\",\n                \"doc\": \"Allows transformation functions to be applied to the geometry.\",\n                \"functions\": [\n                    [\"matrix\", 6],\n                    [\"translate\", 2],\n                    [\"scale\", 2],\n                    [\"rotate\", 3],\n                    [\"skewX\", 1],\n                    [\"skewY\", 1]\n                ]\n            },\n            \"comp-op\": {\n                \"css\": \"line-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"markers\": {\n            \"file\": {\n                \"css\": \"marker-file\",\n                \"doc\": \"An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.\",\n                \"default-value\": \"\",\n                \"default-meaning\": \"An ellipse or circle, if width equals height\",\n                \"type\": \"uri\"\n            },\n            \"opacity\": {\n                \"css\": \"marker-opacity\",\n                \"doc\": \"The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke\",\n                \"default-value\": 1,\n                \"default-meaning\": \"The stroke-opacity and fill-opacity will be used\",\n                \"type\": \"float\"\n            },\n            \"fill-opacity\": {\n                \"css\": \"marker-fill-opacity\",\n                \"doc\": \"The fill opacity of the marker\",\n                \"default-value\": 1,\n                \"default-meaning\": \"opaque\",\n                \"type\": \"float\"\n            },\n            \"stroke\": {\n                \"css\": \"marker-line-color\",\n                \"doc\": \"The color of the stroke around a marker shape.\",\n                \"default-value\": \"black\",\n                \"type\": \"color\"\n            },\n            \"stroke-width\": {\n                \"css\": \"marker-line-width\",\n                \"doc\": \"The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.\",\n                \"type\": \"float\"\n            },\n            \"stroke-opacity\": {\n                \"css\": \"marker-line-opacity\",\n                \"default-value\": 1,\n                \"default-meaning\": \"opaque\",\n                \"doc\": \"The opacity of a line\",\n                \"type\": \"float\"\n            },\n            \"placement\": {\n                \"css\": \"marker-placement\",\n                \"type\": [\n                    \"point\",\n                    \"line\",\n                    \"interior\"\n                ],\n                \"default-value\": \"point\",\n                \"default-meaning\": \"Place markers at the center point (centroid) of the geometry\",\n                \"doc\": \"Attempt to place markers on a point, in the center of a polygon, or if markers-placement:line, then multiple times along a line. 'interior' placement can be used to ensure that points placed on polygons are forced to be inside the polygon interior\"\n            },\n            \"multi-policy\": {\n                \"css\": \"marker-multi-policy\",\n                \"type\": [\n                    \"each\",\n                    \"whole\",\n                    \"largest\"\n                ],\n                \"default-value\": \"each\",\n                \"default-meaning\": \"If a feature contains multiple geometries and the placement type is either point or interior then a marker will be rendered for each\",\n                \"doc\": \"A special setting to allow the user to control rendering behavior for 'multi-geometries' (when a feature contains multiple geometries). This setting does not apply to markers placed along lines. The 'each' policy is default and means all geometries will get a marker. The 'whole' policy means that the aggregate centroid between all geometries will be used. The 'largest' policy means that only the largest (by bounding box areas) feature will get a rendered marker (this is how text labeling behaves by default).\"\n            },\n            \"marker-type\": {\n                \"css\": \"marker-type\",\n                \"type\": [\n                    \"arrow\",\n                    \"ellipse\",\n                    \"rectangle\"\n                ],\n                \"default-value\": \"ellipse\",\n                \"doc\": \"The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an arrow or an ellipse (a circle if height is equal to width)\"\n            },\n            \"width\": {\n                \"css\": \"marker-width\",\n                \"default-value\": 10,\n                \"doc\": \"The width of the marker, if using one of the default types.\",\n                \"type\": \"float\",\n                \"expression\": true\n            },\n            \"height\": {\n                \"css\": \"marker-height\",\n                \"default-value\": 10,\n                \"doc\": \"The height of the marker, if using one of the default types.\",\n                \"type\": \"float\",\n                \"expression\": true\n            },\n            \"fill\": {\n                \"css\": \"marker-fill\",\n                \"default-value\": \"blue\",\n                \"doc\": \"The color of the area of the marker.\",\n                \"type\": \"color\"\n            },\n            \"allow-overlap\": {\n                \"css\": \"marker-allow-overlap\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"doc\": \"Control whether overlapping markers are shown or hidden.\",\n                \"default-meaning\": \"Do not allow makers to overlap with each other - overlapping markers will not be shown.\"\n            },\n            \"ignore-placement\": {\n                \"css\": \"marker-ignore-placement\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"default-meaning\": \"do not store the bbox of this geometry in the collision detector cache\",\n                \"doc\": \"value to control whether the placement of the feature will prevent the placement of other features\"\n            },\n            \"spacing\": {\n                \"css\": \"marker-spacing\",\n                \"doc\": \"Space between repeated labels\",\n                \"default-value\": 100,\n                \"type\": \"float\"\n            },\n            \"max-error\": {\n                \"css\": \"marker-max-error\",\n                \"type\": \"float\",\n                \"default-value\": 0.2,\n                \"doc\": \"The maximum difference between actual marker placement and the marker-spacing parameter. Setting a high value can allow the renderer to try to resolve placement conflicts with other symbolizers.\"\n            },\n            \"transform\": {\n                \"css\": \"marker-transform\",\n                \"type\": \"functions\",\n                \"functions\": [\n                    [\"matrix\", 6],\n                    [\"translate\", 2],\n                    [\"scale\", 2],\n                    [\"rotate\", 3],\n                    [\"skewX\", 1],\n                    [\"skewY\", 1]\n                ],\n                \"default-value\": \"\",\n                \"default-meaning\": \"No transformation\",\n                \"doc\": \"SVG transformation definition\"\n            },\n            \"clip\": {\n                \"css\": \"marker-clip\",\n                \"type\": \"boolean\",\n                \"default-value\": true,\n                \"default-meaning\": \"geometry will be clipped to map bounds before rendering\",\n                \"doc\": \"geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts.\"\n            },\n            \"smooth\": {\n                \"css\": \"marker-smooth\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no smoothing\",\n                \"range\": \"0-1\",\n                \"doc\": \"Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries.\"\n            },\n            \"geometry-transform\": {\n                \"css\": \"marker-geometry-transform\",\n                \"type\": \"functions\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"geometry will not be transformed\",\n                \"doc\": \"Allows transformation functions to be applied to the geometry.\",\n                \"functions\": [\n                    [\"matrix\", 6],\n                    [\"translate\", 2],\n                    [\"scale\", 2],\n                    [\"rotate\", 3],\n                    [\"skewX\", 1],\n                    [\"skewY\", 1]\n                ]\n            },\n            \"comp-op\": {\n                \"css\": \"marker-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"shield\": {\n            \"name\": {\n                \"css\": \"shield-name\",\n                \"type\": \"string\",\n                \"expression\": true,\n                \"serialization\": \"content\",\n                \"doc\": \"Value to use for a shield\\\"s text label. Data columns are specified using brackets like [column_name]\"\n            },\n            \"file\": {\n                \"css\": \"shield-file\",\n                \"required\": true,\n                \"type\": \"uri\",\n                \"default-value\": \"none\",\n                \"doc\": \"Image file to render behind the shield text\"\n            },\n            \"face-name\": {\n                \"css\": \"shield-face-name\",\n                \"type\": \"string\",\n                \"validate\": \"font\",\n                \"doc\": \"Font name and style to use for the shield text\",\n                \"default-value\": \"\",\n                \"required\": true\n            },\n            \"unlock-image\": {\n                \"css\": \"shield-unlock-image\",\n                \"type\": \"boolean\",\n                \"doc\": \"This parameter should be set to true if you are trying to position text beside rather than on top of the shield image\",\n                \"default-value\": false,\n                \"default-meaning\": \"text alignment relative to the shield image uses the center of the image as the anchor for text positioning.\"\n            },\n            \"size\": {\n                \"css\": \"shield-size\",\n                \"type\": \"float\",\n                \"doc\": \"The size of the shield text in pixels\"\n            },\n            \"fill\": {\n                \"css\": \"shield-fill\",\n                \"type\": \"color\",\n                \"doc\": \"The color of the shield text\"\n            },\n            \"placement\": {\n                \"css\": \"shield-placement\",\n                \"type\": [\n                    \"point\",\n                    \"line\",\n                    \"vertex\",\n                    \"interior\"\n                ],\n                \"default-value\": \"point\",\n                \"doc\": \"How this shield should be placed. Point placement attempts to place it on top of points, line places along lines multiple times per feature, vertex places on the vertexes of polygons, and interior attempts to place inside of polygons.\"\n            },\n            \"avoid-edges\": {\n                \"css\": \"shield-avoid-edges\",\n                \"doc\": \"Tell positioning algorithm to avoid labeling near intersection edges.\",\n                \"type\": \"boolean\",\n                \"default-value\": false\n            },\n            \"allow-overlap\": {\n                \"css\": \"shield-allow-overlap\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"doc\": \"Control whether overlapping shields are shown or hidden.\",\n                \"default-meaning\": \"Do not allow shields to overlap with other map elements already placed.\"\n            },\n            \"minimum-distance\": {\n                \"css\": \"shield-min-distance\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"doc\": \"Minimum distance to the next shield symbol, not necessarily the same shield.\"\n            },\n            \"spacing\": {\n                \"css\": \"shield-spacing\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"doc\": \"The spacing between repeated occurrences of the same shield on a line\"\n            },\n            \"minimum-padding\": {\n                \"css\": \"shield-min-padding\",\n                \"default-value\": 0,\n                \"doc\": \"Determines the minimum amount of padding that a shield gets relative to other shields\",\n                \"type\": \"float\"\n            },\n            \"wrap-width\": {\n                \"css\": \"shield-wrap-width\",\n                \"type\": \"unsigned\",\n                \"default-value\": 0,\n                \"doc\": \"Length of a chunk of text in characters before wrapping text\"\n            },\n            \"wrap-before\": {\n                \"css\": \"shield-wrap-before\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"doc\": \"Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width.\"\n            },\n            \"wrap-character\": {\n                \"css\": \"shield-wrap-character\",\n                \"type\": \"string\",\n                \"default-value\": \" \",\n                \"doc\": \"Use this character instead of a space to wrap long names.\"\n            },\n            \"halo-fill\": {\n                \"css\": \"shield-halo-fill\",\n                \"type\": \"color\",\n                \"default-value\": \"#FFFFFF\",\n                \"default-meaning\": \"white\",\n                \"doc\": \"Specifies the color of the halo around the text.\"\n            },\n            \"halo-radius\": {\n                \"css\": \"shield-halo-radius\",\n                \"doc\": \"Specify the radius of the halo in pixels\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no halo\",\n                \"type\": \"float\"\n            },\n            \"character-spacing\": {\n                \"css\": \"shield-character-spacing\",\n                \"type\": \"unsigned\",\n                \"default-value\": 0,\n                \"doc\": \"Horizontal spacing between characters (in pixels). Currently works for point placement only, not line placement.\"\n            },\n            \"line-spacing\": {\n                \"css\": \"shield-line-spacing\",\n                \"doc\": \"Vertical spacing between lines of multiline labels (in pixels)\",\n                \"type\": \"unsigned\"\n            },\n            \"dx\": {\n                \"css\": \"shield-text-dx\",\n                \"type\": \"float\",\n                \"doc\": \"Displace text within shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right\",\n                \"default-value\": 0\n            },\n            \"dy\": {\n                \"css\": \"shield-text-dy\",\n                \"type\": \"float\",\n                \"doc\": \"Displace text within shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down\",\n                \"default-value\": 0\n            },\n            \"shield-dx\": {\n                \"css\": \"shield-dx\",\n                \"type\": \"float\",\n                \"doc\": \"Displace shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right\",\n                \"default-value\": 0\n            },\n            \"shield-dy\": {\n                \"css\": \"shield-dy\",\n                \"type\": \"float\",\n                \"doc\": \"Displace shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down\",\n                \"default-value\": 0\n            },\n            \"opacity\": {\n                \"css\": \"shield-opacity\",\n                \"type\": \"float\",\n                \"doc\": \"(Default 1.0) - opacity of the image used for the shield\",\n                \"default-value\": 1\n            },\n            \"text-opacity\": {\n                \"css\": \"shield-text-opacity\",\n                \"type\": \"float\",\n                \"doc\": \"(Default 1.0) - opacity of the text placed on top of the shield\",\n                \"default-value\": 1\n            },\n            \"horizontal-alignment\": {\n                \"css\": \"shield-horizontal-alignment\",\n                \"type\": [\n                    \"left\",\n                    \"middle\",\n                    \"right\",\n                    \"auto\"\n                ],\n                \"doc\": \"The shield's horizontal alignment from its centerpoint\",\n                \"default-value\": \"auto\"\n            },\n            \"vertical-alignment\": {\n                \"css\": \"shield-vertical-alignment\",\n                \"type\": [\n                    \"top\",\n                    \"middle\",\n                    \"bottom\",\n                    \"auto\"\n                ],\n                \"doc\": \"The shield's vertical alignment from its centerpoint\",\n                \"default-value\": \"middle\"\n            },\n            \"text-transform\": {\n                \"css\": \"shield-text-transform\",\n                \"type\": [\n                    \"none\",\n                    \"uppercase\",\n                    \"lowercase\",\n                    \"capitalize\"\n                ],\n                \"doc\": \"Transform the case of the characters\",\n                \"default-value\": \"none\"\n            },\n            \"justify-alignment\": {\n                \"css\": \"shield-justify-alignment\",\n                \"type\": [\n                    \"left\",\n                    \"center\",\n                    \"right\",\n                    \"auto\"\n                ],\n                \"doc\": \"Define how text in a shield's label is justified\",\n                \"default-value\": \"auto\"\n            },\n            \"clip\": {\n                \"css\": \"shield-clip\",\n                \"type\": \"boolean\",\n                \"default-value\": true,\n                \"default-meaning\": \"geometry will be clipped to map bounds before rendering\",\n                \"doc\": \"geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts.\"\n            },\n            \"comp-op\": {\n                \"css\": \"shield-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"line-pattern\": {\n            \"file\": {\n                \"css\": \"line-pattern-file\",\n                \"type\": \"uri\",\n                \"default-value\": \"none\",\n                \"required\": true,\n                \"doc\": \"An image file to be repeated and warped along a line\"\n            },\n            \"clip\": {\n                \"css\": \"line-pattern-clip\",\n                \"type\": \"boolean\",\n                \"default-value\": true,\n                \"default-meaning\": \"geometry will be clipped to map bounds before rendering\",\n                \"doc\": \"geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts.\"\n            },\n            \"smooth\": {\n                \"css\": \"line-pattern-smooth\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no smoothing\",\n                \"range\": \"0-1\",\n                \"doc\": \"Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries.\"\n            },\n            \"geometry-transform\": {\n                \"css\": \"line-pattern-geometry-transform\",\n                \"type\": \"functions\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"geometry will not be transformed\",\n                \"doc\": \"Allows transformation functions to be applied to the geometry.\",\n                \"functions\": [\n                    [\"matrix\", 6],\n                    [\"translate\", 2],\n                    [\"scale\", 2],\n                    [\"rotate\", 3],\n                    [\"skewX\", 1],\n                    [\"skewY\", 1]\n                ]\n            },\n            \"comp-op\": {\n                \"css\": \"line-pattern-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"polygon-pattern\": {\n            \"file\": {\n                \"css\": \"polygon-pattern-file\",\n                \"type\": \"uri\",\n                \"default-value\": \"none\",\n                \"required\": true,\n                \"doc\": \"Image to use as a repeated pattern fill within a polygon\"\n            },\n            \"alignment\": {\n                \"css\": \"polygon-pattern-alignment\",\n                \"type\": [\n                    \"local\",\n                    \"global\"\n                ],\n                \"default-value\": \"local\",\n                \"doc\": \"Specify whether to align pattern fills to the layer or to the map.\"\n            },\n            \"gamma\": {\n                \"css\": \"polygon-pattern-gamma\",\n                \"type\": \"float\",\n                \"default-value\": 1,\n                \"default-meaning\": \"fully antialiased\",\n                \"range\": \"0-1\",\n                \"doc\": \"Level of antialiasing of polygon pattern edges\"\n            },\n            \"opacity\": {\n                \"css\": \"polygon-pattern-opacity\",\n                \"type\": \"float\",\n                \"doc\": \"(Default 1.0) - Apply an opacity level to the image used for the pattern\",\n                \"default-value\": 1,\n                \"default-meaning\": \"The image is rendered without modifications\"\n            },\n            \"clip\": {\n                \"css\": \"polygon-pattern-clip\",\n                \"type\": \"boolean\",\n                \"default-value\": true,\n                \"default-meaning\": \"geometry will be clipped to map bounds before rendering\",\n                \"doc\": \"geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts.\"\n            },\n            \"smooth\": {\n                \"css\": \"polygon-pattern-smooth\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no smoothing\",\n                \"range\": \"0-1\",\n                \"doc\": \"Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries.\"\n            },\n            \"geometry-transform\": {\n                \"css\": \"polygon-pattern-geometry-transform\",\n                \"type\": \"functions\",\n                \"default-value\": \"none\",\n                \"default-meaning\": \"geometry will not be transformed\",\n                \"doc\": \"Allows transformation functions to be applied to the geometry.\",\n                \"functions\": [\n                    [\"matrix\", 6],\n                    [\"translate\", 2],\n                    [\"scale\", 2],\n                    [\"rotate\", 3],\n                    [\"skewX\", 1],\n                    [\"skewY\", 1]\n                ]\n            },\n            \"comp-op\": {\n                \"css\": \"polygon-pattern-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"raster\": {\n            \"opacity\": {\n                \"css\": \"raster-opacity\",\n                \"default-value\": 1,\n                \"default-meaning\": \"opaque\",\n                \"type\": \"float\",\n                \"doc\": \"The opacity of the raster symbolizer on top of other symbolizers.\"\n            },\n            \"filter-factor\": {\n                \"css\": \"raster-filter-factor\",\n                \"default-value\": -1,\n                \"default-meaning\": \"Allow the datasource to choose appropriate downscaling.\",\n                \"type\": \"float\",\n                \"doc\": \"This is used by the Raster or Gdal datasources to pre-downscale images using overviews. Higher numbers can sometimes cause much better scaled image output, at the cost of speed.\"\n            },\n            \"scaling\": {\n                \"css\": \"raster-scaling\",\n                \"type\": [\n                    \"near\",\n                    \"fast\",\n                    \"bilinear\",\n                    \"bilinear8\",\n                    \"bicubic\",\n                    \"spline16\",\n                    \"spline36\",\n                    \"hanning\",\n                    \"hamming\",\n                    \"hermite\",\n                    \"kaiser\",\n                    \"quadric\",\n                    \"catrom\",\n                    \"gaussian\",\n                    \"bessel\",\n                    \"mitchell\",\n                    \"sinc\",\n                    \"lanczos\",\n                    \"blackman\"\n                ],\n                \"default-value\": \"near\",\n                \"doc\": \"The scaling algorithm used to making different resolution versions of this raster layer. Bilinear is a good compromise between speed and accuracy, while lanczos gives the highest quality.\"\n            },\n            \"mesh-size\": {\n                \"css\": \"raster-mesh-size\",\n                \"default-value\": 16,\n                \"default-meaning\": \"Reprojection mesh will be 1/16 of the resolution of the source image\",\n                \"type\": \"unsigned\",\n                \"doc\": \"A reduced resolution mesh is used for raster reprojection, and the total image size is divided by the mesh-size to determine the quality of that mesh. Values for mesh-size larger than the default will result in faster reprojection but might lead to distortion.\"\n            },\n            \"comp-op\": {\n                \"css\": \"raster-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"point\": {\n            \"file\": {\n                \"css\": \"point-file\",\n                \"type\": \"uri\",\n                \"required\": false,\n                \"default-value\": \"none\",\n                \"doc\": \"Image file to represent a point\"\n            },\n            \"allow-overlap\": {\n                \"css\": \"point-allow-overlap\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"doc\": \"Control whether overlapping points are shown or hidden.\",\n                \"default-meaning\": \"Do not allow points to overlap with each other - overlapping markers will not be shown.\"\n            },\n            \"ignore-placement\": {\n                \"css\": \"point-ignore-placement\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"default-meaning\": \"do not store the bbox of this geometry in the collision detector cache\",\n                \"doc\": \"value to control whether the placement of the feature will prevent the placement of other features\"\n            },\n            \"opacity\": {\n                \"css\": \"point-opacity\",\n                \"type\": \"float\",\n                \"default-value\": 1.0,\n                \"default-meaning\": \"Fully opaque\",\n                \"doc\": \"A value from 0 to 1 to control the opacity of the point\"\n            },\n            \"placement\": {\n                \"css\": \"point-placement\",\n                \"type\": [\n                    \"centroid\",\n                    \"interior\"\n                ],\n                \"doc\": \"How this point should be placed. Centroid calculates the geometric center of a polygon, which can be outside of it, while interior always places inside of a polygon.\",\n                \"default-value\": \"centroid\"\n            },\n            \"transform\": {\n                \"css\": \"point-transform\",\n                \"type\": \"functions\",\n                \"functions\": [\n                    [\"matrix\", 6],\n                    [\"translate\", 2],\n                    [\"scale\", 2],\n                    [\"rotate\", 3],\n                    [\"skewX\", 1],\n                    [\"skewY\", 1]\n                ],\n                \"default-value\": \"\",\n                \"default-meaning\": \"No transformation\",\n                \"doc\": \"SVG transformation definition\"\n            },\n            \"comp-op\": {\n                \"css\": \"point-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"text\": {\n            \"name\": {\n                \"css\": \"text-name\",\n                \"type\": \"string\",\n                \"expression\": true,\n                \"required\": true,\n                \"default-value\": \"\",\n                \"serialization\": \"content\",\n                \"doc\": \"Value to use for a text label. Data columns are specified using brackets like [column_name]\"\n            },\n            \"face-name\": {\n                \"css\": \"text-face-name\",\n                \"type\": \"string\",\n                \"validate\": \"font\",\n                \"doc\": \"Font name and style to render a label in\",\n                \"required\": true\n            },\n            \"size\": {\n                \"css\": \"text-size\",\n                \"type\": \"float\",\n                \"default-value\": 10,\n                \"doc\": \"Text size in pixels\"\n            },\n            \"text-ratio\": {\n                \"css\": \"text-ratio\",\n                \"doc\": \"Define the amount of text (of the total) present on successive lines when wrapping occurs\",\n                \"default-value\": 0,\n                \"type\": \"unsigned\"\n            },\n            \"wrap-width\": {\n                \"css\": \"text-wrap-width\",\n                \"doc\": \"Length of a chunk of text in characters before wrapping text\",\n                \"default-value\": 0,\n                \"type\": \"unsigned\"\n            },\n            \"wrap-before\": {\n                \"css\": \"text-wrap-before\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"doc\": \"Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width.\"\n            },\n            \"wrap-character\": {\n                \"css\": \"text-wrap-character\",\n                \"type\": \"string\",\n                \"default-value\": \" \",\n                \"doc\": \"Use this character instead of a space to wrap long text.\"\n            },\n            \"spacing\": {\n                \"css\": \"text-spacing\",\n                \"type\": \"unsigned\",\n                \"doc\": \"Distance between repeated text labels on a line (aka. label-spacing)\"\n            },\n            \"character-spacing\": {\n                \"css\": \"text-character-spacing\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"doc\": \"Horizontal spacing adjustment between characters in pixels\"\n            },\n            \"line-spacing\": {\n                \"css\": \"text-line-spacing\",\n                \"default-value\": 0,\n                \"type\": \"unsigned\",\n                \"doc\": \"Vertical spacing adjustment between lines in pixels\"\n            },\n            \"label-position-tolerance\": {\n                \"css\": \"text-label-position-tolerance\",\n                \"default-value\": 0,\n                \"type\": \"unsigned\",\n                \"doc\": \"Allows the label to be displaced from its ideal position by a number of pixels (only works with placement:line)\"\n            },\n            \"max-char-angle-delta\": {\n                \"css\": \"text-max-char-angle-delta\",\n                \"type\": \"float\",\n                \"default-value\": \"22.5\",\n                \"doc\": \"The maximum angle change, in degrees, allowed between adjacent characters in a label. This value internally is converted to radians to the default is 22.5*math.pi/180.0. The higher the value the fewer labels will be placed around around sharp corners.\"\n            },\n            \"fill\": {\n                \"css\": \"text-fill\",\n                \"doc\": \"Specifies the color for the text\",\n                \"default-value\": \"#000000\",\n                \"type\": \"color\"\n            },\n            \"opacity\": {\n                \"css\": \"text-opacity\",\n                \"doc\": \"A number from 0 to 1 specifying the opacity for the text\",\n                \"default-value\": 1.0,\n                \"default-meaning\": \"Fully opaque\",\n                \"type\": \"float\"\n            },\n            \"halo-fill\": {\n                \"css\": \"text-halo-fill\",\n                \"type\": \"color\",\n                \"default-value\": \"#FFFFFF\",\n                \"default-meaning\": \"white\",\n                \"doc\": \"Specifies the color of the halo around the text.\"\n            },\n            \"halo-radius\": {\n                \"css\": \"text-halo-radius\",\n                \"doc\": \"Specify the radius of the halo in pixels\",\n                \"default-value\": 0,\n                \"default-meaning\": \"no halo\",\n                \"type\": \"float\"\n            },\n            \"dx\": {\n                \"css\": \"text-dx\",\n                \"type\": \"float\",\n                \"doc\": \"Displace text by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right\",\n                \"default-value\": 0\n            },\n            \"dy\": {\n                \"css\": \"text-dy\",\n                \"type\": \"float\",\n                \"doc\": \"Displace text by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down\",\n                \"default-value\": 0\n            },\n            \"vertical-alignment\": {\n                \"css\": \"text-vertical-alignment\",\n                \"type\": [\n                  \"top\",\n                  \"middle\",\n                  \"bottom\",\n                  \"auto\"\n                ],\n                \"doc\": \"Position of label relative to point position.\",\n                \"default-value\": \"auto\",\n                \"default-meaning\": \"Default affected by value of dy; \\\"bottom\\\" for dy>0, \\\"top\\\" for dy<0.\"\n            },\n            \"avoid-edges\": {\n                \"css\": \"text-avoid-edges\",\n                \"doc\": \"Tell positioning algorithm to avoid labeling near intersection edges.\",\n                \"default-value\": false,\n                \"type\": \"boolean\"\n            },\n            \"minimum-distance\": {\n                \"css\": \"text-min-distance\",\n                \"doc\": \"Minimum permitted distance to the next text symbolizer.\",\n                \"type\": \"float\"\n            },\n            \"minimum-padding\": {\n                \"css\": \"text-min-padding\",\n                \"doc\": \"Determines the minimum amount of padding that a text symbolizer gets relative to other text\",\n                \"type\": \"float\"\n            },\n            \"minimum-path-length\": {\n                \"css\": \"text-min-path-length\",\n                \"type\": \"float\",\n                \"default-value\": 0,\n                \"default-meaning\": \"place labels on all paths\",\n                \"doc\": \"Place labels only on paths longer than this value.\"\n            },\n            \"allow-overlap\": {\n                \"css\": \"text-allow-overlap\",\n                \"type\": \"boolean\",\n                \"default-value\": false,\n                \"doc\": \"Control whether overlapping text is shown or hidden.\",\n                \"default-meaning\": \"Do not allow text to overlap with other text - overlapping markers will not be shown.\"\n            },\n            \"orientation\": {\n                \"css\": \"text-orientation\",\n                \"type\": \"float\",\n                \"expression\": true,\n                \"doc\": \"Rotate the text.\"\n            },\n            \"placement\": {\n                \"css\": \"text-placement\",\n                \"type\": [\n                    \"point\",\n                    \"line\",\n                    \"vertex\",\n                    \"interior\"\n                ],\n                \"default-value\": \"point\",\n                \"doc\": \"Control the style of placement of a point versus the geometry it is attached to.\"\n            },\n            \"placement-type\": {\n                \"css\": \"text-placement-type\",\n                \"doc\": \"Re-position and/or re-size text to avoid overlaps. \\\"simple\\\" for basic algorithm (using text-placements string,) \\\"dummy\\\" to turn this feature off.\",\n                \"type\": [\n                    \"dummy\",\n                    \"simple\"\n                ],\n                \"default-value\": \"dummy\"\n            },\n            \"placements\": {\n                \"css\": \"text-placements\",\n                \"type\": \"string\",\n                \"default-value\": \"\",\n                \"doc\": \"If \\\"placement-type\\\" is set to \\\"simple\\\", use this \\\"POSITIONS,[SIZES]\\\" string. An example is `text-placements: \\\"E,NE,SE,W,NW,SW\\\";` \"\n            },\n            \"text-transform\": {\n                \"css\": \"text-transform\",\n                \"type\": [\n                    \"none\",\n                    \"uppercase\",\n                    \"lowercase\",\n                    \"capitalize\"\n                ],\n                \"doc\": \"Transform the case of the characters\",\n                \"default-value\": \"none\"\n            },\n            \"horizontal-alignment\": {\n                \"css\": \"text-horizontal-alignment\",\n                \"type\": [\n                    \"left\",\n                    \"middle\",\n                    \"right\",\n                    \"auto\"\n                ],\n                \"doc\": \"The text's horizontal alignment from its centerpoint\",\n                \"default-value\": \"auto\"\n            },\n            \"justify-alignment\": {\n                \"css\": \"text-align\",\n                \"type\": [\n                    \"left\",\n                    \"right\",\n                    \"center\",\n                    \"auto\"\n                ],\n                \"doc\": \"Define how text is justified\",\n                \"default-value\": \"auto\",\n                \"default-meaning\": \"Auto alignment means that text will be centered by default except when using the `placement-type` parameter - in that case either right or left justification will be used automatically depending on where the text could be fit given the `text-placements` directives\"\n            },\n            \"clip\": {\n                \"css\": \"text-clip\",\n                \"type\": \"boolean\",\n                \"default-value\": true,\n                \"default-meaning\": \"geometry will be clipped to map bounds before rendering\",\n                \"doc\": \"geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts.\"\n            },\n            \"comp-op\": {\n                \"css\": \"text-comp-op\",\n                \"default-value\": \"src-over\",\n                \"default-meaning\": \"add the current symbolizer on top of other symbolizer\",\n                \"doc\": \"Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.\",\n                \"type\": [\"clear\",\n                    \"src\",\n                    \"dst\",\n                    \"src-over\",\n                    \"dst-over\",\n                    \"src-in\",\n                    \"dst-in\",\n                    \"src-out\",\n                    \"dst-out\",\n                    \"src-atop\",\n                    \"dst-atop\",\n                    \"xor\",\n                    \"plus\",\n                    \"minus\",\n                    \"multiply\",\n                    \"screen\",\n                    \"overlay\",\n                    \"darken\",\n                    \"lighten\",\n                    \"color-dodge\",\n                    \"color-burn\",\n                    \"hard-light\",\n                    \"soft-light\",\n                    \"difference\",\n                    \"exclusion\",\n                    \"contrast\",\n                    \"invert\",\n                    \"invert-rgb\",\n                    \"grain-merge\",\n                    \"grain-extract\",\n                    \"hue\",\n                    \"saturation\",\n                    \"color\",\n                    \"value\"\n                ]\n            }\n        },\n        \"building\": {\n            \"fill\": {\n                \"css\": \"building-fill\",\n                \"default-value\": \"#FFFFFF\",\n                \"doc\": \"The color of the buildings walls.\",\n                \"type\": \"color\"\n            },\n            \"fill-opacity\": {\n                \"css\": \"building-fill-opacity\",\n                \"type\": \"float\",\n                \"doc\": \"The opacity of the building as a whole, including all walls.\",\n                \"default-value\": 1\n            },\n            \"height\": {\n                \"css\": \"building-height\",\n                \"doc\": \"The height of the building in pixels.\",\n                \"type\": \"float\",\n                \"expression\": true,\n                \"default-value\": \"0\"\n            }\n        },\n        \"torque\": {\n          \"-torque-clear-color\": {\n              \"css\": \"-torque-clear-color\",\n              \"type\": \"color\",\n              \"default-value\": \"rgba(255, 255, 255, 0)\",\n              \"default-meaning\": \"full clear\",\n              \"doc\": \"color used to clear canvas on each frame\"\n          },\n          \"-torque-frame-count\": {\n              \"css\": \"-torque-frame-count\",\n              \"default-value\": \"128\",\n              \"type\":\"float\",\n              \"default-meaning\": \"the data is broken into 128 time frames\",\n              \"doc\": \"Number of animation steps/frames used in the animation. If the data contains a fewere number of total frames, the lesser value will be used.\"\n          },\n          \"-torque-resolution\": {\n              \"css\": \"-torque-resolution\",\n              \"default-value\": \"2\",\n              \"type\":\"float\",\n              \"default-meaning\": \"\",\n              \"doc\": \"Spatial resolution in pixels. A resolution of 1 means no spatial aggregation of the data. Any other resolution of N results in spatial aggregation into cells of NxN pixels. The value N must be power of 2\"\n          },\n          \"-torque-animation-duration\": {\n              \"css\": \"-torque-animation-duration\",\n              \"default-value\": \"30\",\n              \"type\":\"float\",\n              \"default-meaning\": \"the animation lasts 30 seconds\",\n              \"doc\": \"Animation duration in seconds\"\n          },\n          \"-torque-aggregation-function\": {\n              \"css\": \"-torque-aggregation-function\",\n              \"default-value\": \"count(cartodb_id)\",\n              \"type\": \"string\",\n              \"default-meaning\": \"the value for each cell is the count of points in that cell\",\n              \"doc\": \"A function used to calculate a value from the aggregate data for each cell. See -torque-resolution\"\n          },\n          \"-torque-time-attribute\": {\n              \"css\": \"-torque-time-attribute\",\n              \"default-value\": \"time\",\n              \"type\": \"string\",\n              \"default-meaning\": \"the data column in your table that is of a time based type\",\n              \"doc\": \"The table column that contains the time information used create the animation\"\n          },\n          \"-torque-data-aggregation\": {\n              \"css\": \"-torque-data-aggregation\",\n              \"default-value\": \"linear\",\n              \"type\": [\n                \"linear\",\n                \"cumulative\"\n              ],\n              \"default-meaning\": \"previous values are discarded\",\n              \"doc\": \"A linear animation will discard previous values while a cumulative animation will accumulate them until it restarts\"\n          }\n        }\n    },\n    \"colors\": {\n        \"aliceblue\":  [240, 248, 255],\n        \"antiquewhite\":  [250, 235, 215],\n        \"aqua\":  [0, 255, 255],\n        \"aquamarine\":  [127, 255, 212],\n        \"azure\":  [240, 255, 255],\n        \"beige\":  [245, 245, 220],\n        \"bisque\":  [255, 228, 196],\n        \"black\":  [0, 0, 0],\n        \"blanchedalmond\":  [255,235,205],\n        \"blue\":  [0, 0, 255],\n        \"blueviolet\":  [138, 43, 226],\n        \"brown\":  [165, 42, 42],\n        \"burlywood\":  [222, 184, 135],\n        \"cadetblue\":  [95, 158, 160],\n        \"chartreuse\":  [127, 255, 0],\n        \"chocolate\":  [210, 105, 30],\n        \"coral\":  [255, 127, 80],\n        \"cornflowerblue\":  [100, 149, 237],\n        \"cornsilk\":  [255, 248, 220],\n        \"crimson\":  [220, 20, 60],\n        \"cyan\":  [0, 255, 255],\n        \"darkblue\":  [0, 0, 139],\n        \"darkcyan\":  [0, 139, 139],\n        \"darkgoldenrod\":  [184, 134, 11],\n        \"darkgray\":  [169, 169, 169],\n        \"darkgreen\":  [0, 100, 0],\n        \"darkgrey\":  [169, 169, 169],\n        \"darkkhaki\":  [189, 183, 107],\n        \"darkmagenta\":  [139, 0, 139],\n        \"darkolivegreen\":  [85, 107, 47],\n        \"darkorange\":  [255, 140, 0],\n        \"darkorchid\":  [153, 50, 204],\n        \"darkred\":  [139, 0, 0],\n        \"darksalmon\":  [233, 150, 122],\n        \"darkseagreen\":  [143, 188, 143],\n        \"darkslateblue\":  [72, 61, 139],\n        \"darkslategrey\":  [47, 79, 79],\n        \"darkturquoise\":  [0, 206, 209],\n        \"darkviolet\":  [148, 0, 211],\n        \"deeppink\":  [255, 20, 147],\n        \"deepskyblue\":  [0, 191, 255],\n        \"dimgray\":  [105, 105, 105],\n        \"dimgrey\":  [105, 105, 105],\n        \"dodgerblue\":  [30, 144, 255],\n        \"firebrick\":  [178, 34, 34],\n        \"floralwhite\":  [255, 250, 240],\n        \"forestgreen\":  [34, 139, 34],\n        \"fuchsia\":  [255, 0, 255],\n        \"gainsboro\":  [220, 220, 220],\n        \"ghostwhite\":  [248, 248, 255],\n        \"gold\":  [255, 215, 0],\n        \"goldenrod\":  [218, 165, 32],\n        \"gray\":  [128, 128, 128],\n        \"grey\":  [128, 128, 128],\n        \"green\":  [0, 128, 0],\n        \"greenyellow\":  [173, 255, 47],\n        \"honeydew\":  [240, 255, 240],\n        \"hotpink\":  [255, 105, 180],\n        \"indianred\":  [205, 92, 92],\n        \"indigo\":  [75, 0, 130],\n        \"ivory\":  [255, 255, 240],\n        \"khaki\":  [240, 230, 140],\n        \"lavender\":  [230, 230, 250],\n        \"lavenderblush\":  [255, 240, 245],\n        \"lawngreen\":  [124, 252, 0],\n        \"lemonchiffon\":  [255, 250, 205],\n        \"lightblue\":  [173, 216, 230],\n        \"lightcoral\":  [240, 128, 128],\n        \"lightcyan\":  [224, 255, 255],\n        \"lightgoldenrodyellow\":  [250, 250, 210],\n        \"lightgray\":  [211, 211, 211],\n        \"lightgreen\":  [144, 238, 144],\n        \"lightgrey\":  [211, 211, 211],\n        \"lightpink\":  [255, 182, 193],\n        \"lightsalmon\":  [255, 160, 122],\n        \"lightseagreen\":  [32, 178, 170],\n        \"lightskyblue\":  [135, 206, 250],\n        \"lightslategray\":  [119, 136, 153],\n        \"lightslategrey\":  [119, 136, 153],\n        \"lightsteelblue\":  [176, 196, 222],\n        \"lightyellow\":  [255, 255, 224],\n        \"lime\":  [0, 255, 0],\n        \"limegreen\":  [50, 205, 50],\n        \"linen\":  [250, 240, 230],\n        \"magenta\":  [255, 0, 255],\n        \"maroon\":  [128, 0, 0],\n        \"mediumaquamarine\":  [102, 205, 170],\n        \"mediumblue\":  [0, 0, 205],\n        \"mediumorchid\":  [186, 85, 211],\n        \"mediumpurple\":  [147, 112, 219],\n        \"mediumseagreen\":  [60, 179, 113],\n        \"mediumslateblue\":  [123, 104, 238],\n        \"mediumspringgreen\":  [0, 250, 154],\n        \"mediumturquoise\":  [72, 209, 204],\n        \"mediumvioletred\":  [199, 21, 133],\n        \"midnightblue\":  [25, 25, 112],\n        \"mintcream\":  [245, 255, 250],\n        \"mistyrose\":  [255, 228, 225],\n        \"moccasin\":  [255, 228, 181],\n        \"navajowhite\":  [255, 222, 173],\n        \"navy\":  [0, 0, 128],\n        \"oldlace\":  [253, 245, 230],\n        \"olive\":  [128, 128, 0],\n        \"olivedrab\":  [107, 142, 35],\n        \"orange\":  [255, 165, 0],\n        \"orangered\":  [255, 69, 0],\n        \"orchid\":  [218, 112, 214],\n        \"palegoldenrod\":  [238, 232, 170],\n        \"palegreen\":  [152, 251, 152],\n        \"paleturquoise\":  [175, 238, 238],\n        \"palevioletred\":  [219, 112, 147],\n        \"papayawhip\":  [255, 239, 213],\n        \"peachpuff\":  [255, 218, 185],\n        \"peru\":  [205, 133, 63],\n        \"pink\":  [255, 192, 203],\n        \"plum\":  [221, 160, 221],\n        \"powderblue\":  [176, 224, 230],\n        \"purple\":  [128, 0, 128],\n        \"red\":  [255, 0, 0],\n        \"rosybrown\":  [188, 143, 143],\n        \"royalblue\":  [65, 105, 225],\n        \"saddlebrown\":  [139, 69, 19],\n        \"salmon\":  [250, 128, 114],\n        \"sandybrown\":  [244, 164, 96],\n        \"seagreen\":  [46, 139, 87],\n        \"seashell\":  [255, 245, 238],\n        \"sienna\":  [160, 82, 45],\n        \"silver\":  [192, 192, 192],\n        \"skyblue\":  [135, 206, 235],\n        \"slateblue\":  [106, 90, 205],\n        \"slategray\":  [112, 128, 144],\n        \"slategrey\":  [112, 128, 144],\n        \"snow\":  [255, 250, 250],\n        \"springgreen\":  [0, 255, 127],\n        \"steelblue\":  [70, 130, 180],\n        \"tan\":  [210, 180, 140],\n        \"teal\":  [0, 128, 128],\n        \"thistle\":  [216, 191, 216],\n        \"tomato\":  [255, 99, 71],\n        \"turquoise\":  [64, 224, 208],\n        \"violet\":  [238, 130, 238],\n        \"wheat\":  [245, 222, 179],\n        \"white\":  [255, 255, 255],\n        \"whitesmoke\":  [245, 245, 245],\n        \"yellow\":  [255, 255, 0],\n        \"yellowgreen\":  [154, 205, 50],\n        \"transparent\":  [0, 0, 0, 0]\n    },\n    \"filter\": {\n        \"value\": [\n            \"true\",\n            \"false\",\n            \"null\",\n            \"point\",\n            \"linestring\",\n            \"polygon\",\n            \"collection\"\n        ]\n    }\n}\n\nmodule.exports = {\n  version: {\n    latest: _mapnik_reference_latest,\n    '2.1.1': _mapnik_reference_latest\n  }\n};\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\":[function(require,module,exports){\n/**\n * TODO: document this. What does this do?\n */\nif(typeof(module) !== \"undefined\") {\n  module.exports.find = function (obj, fun) {\n      for (var i = 0, r; i < obj.length; i++) {\n          if (r = fun.call(obj, obj[i])) { return r; }\n      }\n      return null;\n  };\n}\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/call.js\":[function(require,module,exports){\n(function (global){\n(function(tree) {\nvar _ = global._ || require('underscore');\ntree.Call = function Call(name, args, index) {\n    this.name = name;\n    this.args = args;\n    this.index = index;\n};\n\ntree.Call.prototype = {\n    is: 'call',\n    // When evuating a function call,\n    // we either find the function in `tree.functions` [1],\n    // in which case we call it, passing the  evaluated arguments,\n    // or we simply print it out as it appeared originally [2].\n    // The *functions.js* file contains the built-in functions.\n    // The reason why we evaluate the arguments, is in the case where\n    // we try to pass a variable to a function, like: `saturate(@color)`.\n    // The function should receive the value, not the variable.\n    'ev': function(env) {\n        var args = this.args.map(function(a) { return a.ev(env); });\n\n        for (var i = 0; i < args.length; i++) {\n            if (args[i].is === 'undefined') {\n                return {\n                    is: 'undefined',\n                    value: 'undefined'\n                };\n            }\n        }\n\n        if (this.name in tree.functions) {\n            if (tree.functions[this.name].length <= args.length) {\n                var val = tree.functions[this.name].apply(tree.functions, args);\n                if (val === null) {\n                    env.error({\n                        message: 'incorrect arguments given to ' + this.name + '()',\n                        index: this.index,\n                        type: 'runtime',\n                        filename: this.filename\n                    });\n                    return { is: 'undefined', value: 'undefined' };\n                }\n                return val;\n            } else {\n                env.error({\n                    message: 'incorrect number of arguments for ' + this.name +\n                        '(). ' + tree.functions[this.name].length + ' expected.',\n                    index: this.index,\n                    type: 'runtime',\n                    filename: this.filename\n                });\n                return {\n                    is: 'undefined',\n                    value: 'undefined'\n                };\n            }\n        } else {\n            var fn = tree.Reference.mapnikFunctions[this.name];\n            if (fn === undefined) {\n                var functions = _.pairs(tree.Reference.mapnikFunctions);\n                // cheap closest, needs improvement.\n                var name = this.name;\n                var mean = functions.map(function(f) {\n                    return [f[0], tree.Reference.editDistance(name, f[0]), f[1]];\n                }).sort(function(a, b) {\n                    return a[1] - b[1];\n                });\n                env.error({\n                    message: 'unknown function ' + this.name + '(), did you mean ' +\n                        mean[0][0] + '(' + mean[0][2] + ')',\n                    index: this.index,\n                    type: 'runtime',\n                    filename: this.filename\n                });\n                return {\n                    is: 'undefined',\n                    value: 'undefined'\n                };\n            }\n            if (fn !== args.length &&\n                !(Array.isArray(fn) && _.include(fn, args.length)) &&\n                // support variable-arg functions like `colorize-alpha`\n                fn !== -1) {\n                env.error({\n                    message: 'function ' + this.name + '() takes ' +\n                        fn + ' arguments and was given ' + args.length,\n                    index: this.index,\n                    type: 'runtime',\n                    filename: this.filename\n                });\n                return {\n                    is: 'undefined',\n                    value: 'undefined'\n                };\n            } else {\n                // Save the evaluated versions of arguments\n                this.args = args;\n                return this;\n            }\n        }\n    },\n\n    toString: function(env, format) {\n        if (this.args.length) {\n            return this.name + '(' + this.args.join(',') + ')';\n        } else {\n            return this.name;\n        }\n    }\n};\n\n})(require('../tree'));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/color.js\":[function(require,module,exports){\n(function(tree) {\n// RGB Colors - #ff0014, #eee\n// can be initialized with a 3 or 6 char string or a 3 or 4 element\n// numerical array\ntree.Color = function Color(rgb, a) {\n    // The end goal here, is to parse the arguments\n    // into an integer triplet, such as `128, 255, 0`\n    //\n    // This facilitates operations and conversions.\n    if (Array.isArray(rgb)) {\n        this.rgb = rgb.slice(0, 3);\n    } else if (rgb.length == 6) {\n        this.rgb = rgb.match(/.{2}/g).map(function(c) {\n            return parseInt(c, 16);\n        });\n    } else {\n        this.rgb = rgb.split('').map(function(c) {\n            return parseInt(c + c, 16);\n        });\n    }\n\n    if (typeof(a) === 'number') {\n        this.alpha = a;\n    } else if (rgb.length === 4) {\n        this.alpha = rgb[3];\n    } else {\n        this.alpha = 1;\n    }\n};\n\ntree.Color.prototype = {\n    is: 'color',\n    'ev': function() { return this; },\n\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    toString: function() {\n        if (this.alpha < 1.0) {\n            return 'rgba(' + this.rgb.map(function(c) {\n                return Math.round(c);\n            }).concat(this.alpha).join(', ') + ')';\n        } else {\n            return '#' + this.rgb.map(function(i) {\n                i = Math.round(i);\n                i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);\n                return i.length === 1 ? '0' + i : i;\n            }).join('');\n        }\n    },\n\n    // Operations have to be done per-channel, if not,\n    // channels will spill onto each other. Once we have\n    // our result, in the form of an integer triplet,\n    // we create a new Color node to hold the result.\n    operate: function(env, op, other) {\n        var result = [];\n\n        if (! (other instanceof tree.Color)) {\n            other = other.toColor();\n        }\n\n        for (var c = 0; c < 3; c++) {\n            result[c] = tree.operate(op, this.rgb[c], other.rgb[c]);\n        }\n        return new tree.Color(result);\n    },\n\n    toHSL: function() {\n        var r = this.rgb[0] / 255,\n            g = this.rgb[1] / 255,\n            b = this.rgb[2] / 255,\n            a = this.alpha;\n\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\n        var h, s, l = (max + min) / 2, d = max - min;\n\n        if (max === min) {\n            h = s = 0;\n        } else {\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            switch (max) {\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n                case g: h = (b - r) / d + 2; break;\n                case b: h = (r - g) / d + 4; break;\n            }\n            h /= 6;\n        }\n        return { h: h * 360, s: s, l: l, a: a };\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/comment.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Comment = function Comment(value, silent) {\n    this.value = value;\n    this.silent = !!silent;\n};\n\ntree.Comment.prototype = {\n    toString: function(env) {\n        return '<!--' + this.value + '-->';\n    },\n    'ev': function() { return this; }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/definition.js\":[function(require,module,exports){\n(function (global){\n(function(tree) {\nvar assert = require('assert'),\n    _ = global._ || require('underscore');\n\n// A definition is the combination of a selector and rules, like\n// #foo {\n//     polygon-opacity:1.0;\n// }\n//\n// The selector can have filters\ntree.Definition = function Definition(selector, rules) {\n    this.elements = selector.elements;\n    assert.ok(selector.filters instanceof tree.Filterset);\n    this.rules = rules;\n    this.ruleIndex = {};\n    for (var i = 0; i < this.rules.length; i++) {\n        if ('zoom' in this.rules[i]) this.rules[i] = this.rules[i].clone();\n        this.rules[i].zoom = selector.zoom;\n        this.ruleIndex[this.rules[i].updateID()] = true;\n    }\n    this.filters = selector.filters;\n    this.zoom = selector.zoom;\n    this.frame_offset = selector.frame_offset;\n    this.attachment = selector.attachment || '__default__';\n    this.specificity = selector.specificity();\n};\n\ntree.Definition.prototype.toString = function() {\n    var str = this.filters.toString();\n    for (var i = 0; i < this.rules.length; i++) {\n        str += '\\n    ' + this.rules[i];\n    }\n    return str;\n};\n\ntree.Definition.prototype.clone = function(filters) {\n    if (filters) assert.ok(filters instanceof tree.Filterset);\n    var clone = Object.create(tree.Definition.prototype);\n    clone.rules = this.rules.slice();\n    clone.ruleIndex = _.clone(this.ruleIndex);\n    clone.filters = filters ? filters : this.filters.clone();\n    clone.attachment = this.attachment;\n    return clone;\n};\n\ntree.Definition.prototype.addRules = function(rules) {\n    var added = 0;\n\n    // Add only unique rules.\n    for (var i = 0; i < rules.length; i++) {\n        if (!this.ruleIndex[rules[i].id]) {\n            this.rules.push(rules[i]);\n            this.ruleIndex[rules[i].id] = true;\n            added++;\n        }\n    }\n\n    return added;\n};\n\n// Determine whether this selector matches a given id\n// and array of classes, by determining whether\n// all elements it contains match.\ntree.Definition.prototype.appliesTo = function(id, classes) {\n    for (var i = 0, l = this.elements.length; i < l; i++) {\n        var elem = this.elements[i];\n        if (!(elem.wildcard ||\n            (elem.type === 'class' && classes[elem.clean]) ||\n            (elem.type === 'id' && id === elem.clean))) return false;\n    }\n    return true;\n};\n\nfunction symbolizerName(symbolizer) {\n    function capitalize(str) { return str[1].toUpperCase(); }\n    return symbolizer.charAt(0).toUpperCase() +\n           symbolizer.slice(1).replace(/\\-./, capitalize) + 'Symbolizer';\n}\n\n// Get a simple list of the symbolizers, in order\nfunction symbolizerList(sym_order) {\n    return sym_order.sort(function(a, b) { return a[1] - b[1]; })\n        .map(function(v) { return v[0]; });\n}\n\ntree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {\n    var xml = zoom.toXML(env).join('') + this.filters.toXML(env);\n\n    // Sort symbolizers by the index of their first property definition\n    var sym_order = [], indexes = [];\n    for (var key in symbolizers) {\n        indexes = [];\n        for (var prop in symbolizers[key]) {\n            indexes.push(symbolizers[key][prop].index);\n        }\n        var min_idx = Math.min.apply(Math, indexes);\n        sym_order.push([key, min_idx]);\n    }\n\n    sym_order = symbolizerList(sym_order);\n    var sym_count = 0;\n\n    for (var i = 0; i < sym_order.length; i++) {\n        var attributes = symbolizers[sym_order[i]];\n        var symbolizer = sym_order[i].split('/').pop();\n\n        // Skip the magical * symbolizer which is used for universal properties\n        // which are bubbled up to Style elements intead of Symbolizer elements.\n        if (symbolizer === '*') continue;\n        sym_count++;\n\n        var fail = tree.Reference.requiredProperties(symbolizer, attributes);\n        if (fail) {\n            var rule = attributes[Object.keys(attributes).shift()];\n            env.error({\n                message: fail,\n                index: rule.index,\n                filename: rule.filename\n            });\n        }\n\n        var name = symbolizerName(symbolizer);\n\n        var selfclosing = true, tagcontent;\n        xml += '    <' + name + ' ';\n        for (var j in attributes) {\n            if (symbolizer === 'map') env.error({\n                message: 'Map properties are not permitted in other rules',\n                index: attributes[j].index,\n                filename: attributes[j].filename\n            });\n            var x = tree.Reference.selector(attributes[j].name);\n            if (x && x.serialization && x.serialization === 'content') {\n                selfclosing = false;\n                tagcontent = attributes[j].ev(env).toXML(env, true);\n            } else if (x && x.serialization && x.serialization === 'tag') {\n                selfclosing = false;\n                tagcontent = attributes[j].ev(env).toXML(env, true);\n            } else {\n                xml += attributes[j].ev(env).toXML(env) + ' ';\n            }\n        }\n        if (selfclosing) {\n            xml += '/>\\n';\n        } else if (typeof tagcontent !== \"undefined\") {\n            if (tagcontent.indexOf('<') != -1) {\n                xml += '>' + tagcontent + '</' + name + '>\\n';\n            } else {\n                xml += '><![CDATA[' + tagcontent + ']]></' + name + '>\\n';\n            }\n        }\n    }\n    if (!sym_count || !xml) return '';\n    return '  <Rule>\\n' + xml + '  </Rule>\\n';\n};\n\n// Take a zoom range of zooms and 'i', the index of a rule in this.rules,\n// and finds all applicable symbolizers\ntree.Definition.prototype.collectSymbolizers = function(zooms, i) {\n    var symbolizers = {}, child;\n\n    for (var j = i; j < this.rules.length; j++) {\n        child = this.rules[j];\n        var key = child.instance + '/' + child.symbolizer;\n        if (zooms.current & child.zoom &&\n           (!(key in symbolizers) ||\n           (!(child.name in symbolizers[key])))) {\n            zooms.current &= child.zoom;\n            if (!(key in symbolizers)) {\n                symbolizers[key] = {};\n            }\n            symbolizers[key][child.name] = child;\n        }\n    }\n\n    if (Object.keys(symbolizers).length) {\n        zooms.rule &= (zooms.available &= ~zooms.current);\n        return symbolizers;\n    }\n};\n\n// The tree.Zoom.toString function ignores the holes in zoom ranges and outputs\n// scaledenominators that cover the whole range from the first to last bit set.\n// This algorithm can produces zoom ranges that may have holes. However,\n// when using the filter-mode=\"first\", more specific zoom filters will always\n// end up before broader ranges. The filter-mode will pick those first before\n// resorting to the zoom range with the hole and stop processing further rules.\ntree.Definition.prototype.toXML = function(env, existing) {\n    var filter = this.filters.toString();\n    if (!(filter in existing)) existing[filter] = tree.Zoom.all;\n\n    var available = tree.Zoom.all, xml = '', zoom, symbolizers,\n        zooms = { available: tree.Zoom.all };\n    for (var i = 0; i < this.rules.length && available; i++) {\n        zooms.rule = this.rules[i].zoom;\n        if (!(existing[filter] & zooms.rule)) continue;\n\n        while (zooms.current = zooms.rule & available) {\n            if (symbolizers = this.collectSymbolizers(zooms, i)) {\n                if (!(existing[filter] & zooms.current)) continue;\n                xml += this.symbolizersToXML(env, symbolizers,\n                    (new tree.Zoom()).setZoom(existing[filter] & zooms.current));\n                existing[filter] &= ~zooms.current;\n            }\n        }\n    }\n\n    return xml;\n};\n\ntree.Definition.prototype.toJS = function(env) {\n  var shaderAttrs = {};\n\n  // merge conditions from filters with zoom condition of the\n  // definition\n  var zoom = \"(\" + this.zoom + \" & (1 << ctx.zoom))\";\n  var frame_offset = this.frame_offset;\n  var _if = this.filters.toJS(env);\n  var filters = [zoom];\n  if(_if) filters.push(_if);\n  if(frame_offset) filters.push('ctx[\"frame-offset\"] === ' + frame_offset);\n  _if = filters.join(\" && \");\n  _.each(this.rules, function(rule) {\n      if(rule instanceof tree.Rule) {\n        shaderAttrs[rule.name] = shaderAttrs[rule.name] || [];\n\n        var r = {\n          index: rule.index,\n          symbolizer: rule.symbolizer\n        };\n\n        if (_if) {\n          r.js = \"if(\" + _if + \"){\" + rule.value.toJS(env) + \"}\"\n        } else {\n          r.js = rule.value.toJS(env);\n        }\n\n        r.constant = rule.value.ev(env).is !== 'field';\n        r.filtered = !!_if;\n\n        shaderAttrs[rule.name].push(r);\n      } else {\n        throw new Error(\"Ruleset not supported\");\n        //if (rule instanceof tree.Ruleset) {\n          //var sh = rule.toJS(env);\n          //for(var v in sh) {\n            //shaderAttrs[v] = shaderAttrs[v] || [];\n            //for(var attr in sh[v]) {\n              //shaderAttrs[v].push(sh[v][attr]);\n            //}\n          //}\n        //}\n      }\n  });\n  return shaderAttrs;\n};\n\n\n})(require('../tree'));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"assert\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/assert/assert.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/dimension.js\":[function(require,module,exports){\n(function (global){\n(function(tree) {\nvar _ = global._ || require('underscore');\n//\n// A number with a unit\n//\ntree.Dimension = function Dimension(value, unit, index) {\n    this.value = parseFloat(value);\n    this.unit = unit || null;\n    this.index = index;\n};\n\ntree.Dimension.prototype = {\n    is: 'float',\n    physical_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc'],\n    screen_units: ['px', '%'],\n    all_units: ['m', 'cm', 'in', 'mm', 'pt', 'pc', 'px', '%'],\n    densities: {\n        m: 0.0254,\n        mm: 25.4,\n        cm: 2.54,\n        pt: 72,\n        pc: 6\n    },\n    ev: function (env) {\n        if (this.unit && !_.contains(this.all_units, this.unit)) {\n            env.error({\n                message: \"Invalid unit: '\" + this.unit + \"'\",\n                index: this.index\n            });\n            return { is: 'undefined', value: 'undefined' };\n        }\n\n        // normalize units which are not px or %\n        if (this.unit && _.contains(this.physical_units, this.unit)) {\n            if (!env.ppi) {\n                env.error({\n                    message: \"ppi is not set, so metric units can't be used\",\n                    index: this.index\n                });\n                return { is: 'undefined', value: 'undefined' };\n            }\n            // convert all units to inch\n            // convert inch to px using ppi\n            this.value = (this.value / this.densities[this.unit]) * env.ppi;\n            this.unit = 'px';\n        }\n\n        return this;\n    },\n    round: function() {\n        this.value = Math.round(this.value);\n        return this;\n    },\n    toColor: function() {\n        return new tree.Color([this.value, this.value, this.value]);\n    },\n    round: function() {\n        this.value = Math.round(this.value);\n        return this;\n    },\n    toString: function() {\n        return this.value.toString();\n    },\n    operate: function(env, op, other) {\n        if (this.unit === '%' && other.unit !== '%') {\n            env.error({\n                message: 'If two operands differ, the first must not be %',\n                index: this.index\n            });\n            return {\n                is: 'undefined',\n                value: 'undefined'\n            };\n        }\n\n        if (this.unit !== '%' && other.unit === '%') {\n            if (op === '*' || op === '/' || op === '%') {\n                env.error({\n                    message: 'Percent values can only be added or subtracted from other values',\n                    index: this.index\n                });\n                return {\n                    is: 'undefined',\n                    value: 'undefined'\n                };\n            }\n\n            return new tree.Dimension(tree.operate(op,\n                    this.value, this.value * other.value * 0.01),\n                this.unit);\n        }\n\n        //here the operands are either the same (% or undefined or px), or one is undefined and the other is px\n        return new tree.Dimension(tree.operate(op, this.value, other.value),\n            this.unit || other.unit);\n    }\n};\n\n})(require('../tree'));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/element.js\":[function(require,module,exports){\n(function(tree) {\n\n// An element is an id or class selector\ntree.Element = function Element(value) {\n    this.value = value.trim();\n    if (this.value[0] === '#') {\n        this.type = 'id';\n        this.clean = this.value.replace(/^#/, '');\n    }\n    if (this.value[0] === '.') {\n        this.type = 'class';\n        this.clean = this.value.replace(/^\\./, '');\n    }\n    if (this.value.indexOf('*') !== -1) {\n        this.type = 'wildcard';\n    }\n};\n\n// Determine the 'specificity matrix' of this\n// specific selector\ntree.Element.prototype.specificity = function() {\n    return [\n        (this.type === 'id') ? 1 : 0, // a\n        (this.type === 'class') ? 1 : 0  // b\n    ];\n};\n\ntree.Element.prototype.toString = function() { return this.value; };\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/expression.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Expression = function Expression(value) {\n    this.value = value;\n};\n\ntree.Expression.prototype = {\n    is: 'expression',\n    ev: function(env) {\n        if (this.value.length > 1) {\n            return new tree.Expression(this.value.map(function(e) {\n                return e.ev(env);\n            }));\n        } else {\n            return this.value[0].ev(env);\n        }\n    },\n\n    toString: function(env) {\n        return this.value.map(function(e) {\n            return e.toString(env);\n        }).join(' ');\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/field.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Field = function Field(content) {\n    this.value = content || '';\n};\n\ntree.Field.prototype = {\n    is: 'field',\n    toString: function() {\n        return '[' + this.value + ']';\n    },\n    'ev': function() {\n        return this;\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/filter.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Filter = function Filter(key, op, val, index, filename) {\n    this.key = key;\n    this.op = op;\n    this.val = val;\n    this.index = index;\n    this.filename = filename;\n\n    this.id = this.key + this.op + this.val;\n};\n\n// xmlsafe, numeric, suffix\nvar ops = {\n    '<': [' &lt; ', 'numeric'],\n    '>': [' &gt; ', 'numeric'],\n    '=': [' = ', 'both'],\n    '!=': [' != ', 'both'],\n    '<=': [' &lt;= ', 'numeric'],\n    '>=': [' &gt;= ', 'numeric'],\n    '=~': ['.match(', 'string', ')']\n};\n\ntree.Filter.prototype.ev = function(env) {\n    this.key = this.key.ev(env);\n    this.val = this.val.ev(env);\n    return this;\n};\n\ntree.Filter.prototype.toXML = function(env) {\n    if (tree.Reference.data.filter) {\n        if (this.key.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.key.toString())) {\n            env.error({\n                message: this.key.toString() + ' is not a valid keyword in a filter expression',\n                index: this.index,\n                filename: this.filename\n            });\n        }\n        if (this.val.is === 'keyword' && -1 === tree.Reference.data.filter.value.indexOf(this.val.toString())) {\n            env.error({\n                message: this.val.toString() + ' is not a valid keyword in a filter expression',\n                index: this.index,\n                filename: this.filename\n            });\n        }\n    }\n    var key = this.key.toString(false);\n    var val = this.val.toString(this.val.is == 'string');\n\n    if (\n        (ops[this.op][1] == 'numeric' && isNaN(val) && this.val.is !== 'field') ||\n        (ops[this.op][1] == 'string' && (val)[0] != \"'\")\n    ) {\n        env.error({\n            message: 'Cannot use operator \"' + this.op + '\" with value ' + this.val,\n            index: this.index,\n            filename: this.filename\n        });\n    }\n\n    return key + ops[this.op][0] + val + (ops[this.op][2] || '');\n};\n\ntree.Filter.prototype.toString = function() {\n    return '[' + this.id + ']';\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/filterset.js\":[function(require,module,exports){\n(function (global){\nvar tree = require('../tree');\nvar _ = global._ || require('underscore');\n\ntree.Filterset = function Filterset() {\n    this.filters = {};\n};\n\ntree.Filterset.prototype.toXML = function(env) {\n    var filters = [];\n    for (var id in this.filters) {\n        filters.push('(' + this.filters[id].toXML(env).trim() + ')');\n    }\n    if (filters.length) {\n        return '    <Filter>' + filters.join(' and ') + '</Filter>\\n';\n    } else {\n        return '';\n    }\n};\n\ntree.Filterset.prototype.toString = function() {\n    var arr = [];\n    for (var id in this.filters) arr.push(this.filters[id].id);\n    return arr.sort().join('\\t');\n};\n\ntree.Filterset.prototype.ev = function(env) {\n    for (var i in this.filters) {\n        this.filters[i].ev(env);\n    }\n    return this;\n};\n\ntree.Filterset.prototype.clone = function() {\n    var clone = new tree.Filterset();\n    for (var id in this.filters) {\n        clone.filters[id] = this.filters[id];\n    }\n    return clone;\n};\n\n// Note: other has to be a tree.Filterset.\ntree.Filterset.prototype.cloneWith = function(other) {\n    var additions = [];\n    for (var id in other.filters) {\n        var status = this.addable(other.filters[id]);\n        // status is true, false or null. if it's null we don't fail this\n        // clone nor do we add the filter.\n        if (status === false) {\n            return false;\n        }\n        if (status === true) {\n            // Adding the filter will override another value.\n            additions.push(other.filters[id]);\n        }\n    }\n\n    // Adding the other filters doesn't make this filterset invalid, but it\n    // doesn't add anything to it either.\n    if (!additions.length) {\n        return null;\n    }\n\n    // We can successfully add all filters. Now clone the filterset and add the\n    // new rules.\n    var clone = new tree.Filterset();\n\n    // We can add the rules that are already present without going through the\n    // add function as a Filterset is always in it's simplest canonical form.\n    for (id in this.filters) {\n        clone.filters[id] = this.filters[id];\n    }\n\n    // Only add new filters that actually change the filter.\n    while (id = additions.shift()) {\n        clone.add(id);\n    }\n\n    return clone;\n};\n\ntree.Filterset.prototype.toJS = function(env) {\n  var opMap = {\n    '=': '==='\n  };\n  return _.map(this.filters, function(filter) {\n    var op = filter.op;\n    if(op in opMap) {\n      op = opMap[op];\n    }\n    var val = filter.val;\n    if(filter._val !== undefined) {\n      val = filter._val.toString(true);\n    }\n    var attrs = \"data\";\n    return attrs + \".\" + filter.key.value  + \" \" + op + \" \" + (val.is === 'string' ? \"'\"+ val +\"'\" : val);\n  }).join(' && ');\n};\n\n// Returns true when the new filter can be added, false otherwise.\n// It can also return null, and on the other side we test for === true or\n// false\ntree.Filterset.prototype.addable = function(filter) {\n    var key = filter.key.toString(),\n        value = filter.val.toString();\n\n    if (value.match(/^[0-9]+(\\.[0-9]*)?$/)) value = parseFloat(value);\n\n    switch (filter.op) {\n        case '=':\n            // if there is already foo= and we're adding foo=\n            if (this.filters[key + '='] !== undefined) {\n                if (this.filters[key + '='].val.toString() != value) {\n                    return false;\n                } else {\n                    return null;\n                }\n            }\n            if (this.filters[key + '!=' + value] !== undefined) return false;\n            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return false;\n            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;\n            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return false;\n            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val < value) return false;\n            return true;\n\n        case '=~':\n            return true;\n\n        case '!=':\n            if (this.filters[key + '='] !== undefined) return (this.filters[key + '='].val == value) ? false : null;\n            if (this.filters[key + '!=' + value] !== undefined) return null;\n            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;\n            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return null;\n            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return null;\n            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;\n            return true;\n\n        case '>':\n            if (key + '=' in this.filters) {\n                if (this.filters[key + '='].val <= value) {\n                    return false;\n                } else {\n                    return null;\n                }\n            }\n            if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) return false;\n            if (this.filters[key + '<='] !== undefined  && this.filters[key + '<='].val <= value) return false;\n            if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) return null;\n            if (this.filters[key + '>='] !== undefined  && this.filters[key + '>='].val > value) return null;\n            return true;\n\n        case '>=':\n            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val < value) ? false : null;\n            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return false;\n            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return false;\n            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return null;\n            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return null;\n            return true;\n\n        case '<':\n            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val >= value) ? false : null;\n            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;\n            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) return false;\n            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;\n            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) return null;\n            return true;\n\n        case '<=':\n            if (this.filters[key + '=' ] !== undefined) return (this.filters[key + '='].val > value) ? false : null;\n            if (this.filters[key + '>' ] !== undefined && this.filters[key + '>'].val >= value) return false;\n            if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) return false;\n            if (this.filters[key + '<' ] !== undefined && this.filters[key + '<'].val <= value) return null;\n            if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) return null;\n            return true;\n    }\n};\n\n// Does the new filter constitute a conflict?\ntree.Filterset.prototype.conflict = function(filter) {\n    var key = filter.key.toString(),\n        value = filter.val.toString();\n\n    if (!isNaN(parseFloat(value))) value = parseFloat(value);\n\n    // if (a=b) && (a=c)\n    // if (a=b) && (a!=b)\n    // or (a!=b) && (a=b)\n    if ((filter.op === '=' && this.filters[key + '='] !== undefined &&\n        value != this.filters[key + '='].val.toString()) ||\n        (filter.op === '!=' && this.filters[key + '='] !== undefined &&\n        value == this.filters[key + '='].val.toString()) ||\n        (filter.op === '=' && this.filters[key + '!='] !== undefined &&\n        value == this.filters[key + '!='].val.toString())) {\n        return filter.toString() + ' added to ' + this.toString() + ' produces an invalid filter';\n    }\n\n    return false;\n};\n\n// Only call this function for filters that have been cleared by .addable().\ntree.Filterset.prototype.add = function(filter, env) {\n    var key = filter.key.toString(),\n        id,\n        op = filter.op,\n        conflict = this.conflict(filter),\n        numval;\n\n    if (conflict) return conflict;\n\n    if (op === '=') {\n        for (var i in this.filters) {\n            if (this.filters[i].key == key) delete this.filters[i];\n        }\n        this.filters[key + '='] = filter;\n    } else if (op === '!=') {\n        this.filters[key + '!=' + filter.val] = filter;\n    } else if (op === '=~') {\n        this.filters[key + '=~' + filter.val] = filter;\n    } else if (op === '>') {\n        // If there are other filters that are also >\n        // but are less than this one, they don't matter, so\n        // remove them.\n        for (var j in this.filters) {\n            if (this.filters[j].key == key && this.filters[j].val <= filter.val) {\n                delete this.filters[j];\n            }\n        }\n        this.filters[key + '>'] = filter;\n    } else if (op === '>=') {\n        for (var k in this.filters) {\n            numval = (+this.filters[k].val.toString());\n            if (this.filters[k].key == key && numval < filter.val) {\n                delete this.filters[k];\n            }\n        }\n        if (this.filters[key + '!=' + filter.val] !== undefined) {\n            delete this.filters[key + '!=' + filter.val];\n            filter.op = '>';\n            this.filters[key + '>'] = filter;\n        }\n        else {\n            this.filters[key + '>='] = filter;\n        }\n    } else if (op === '<') {\n        for (var l in this.filters) {\n            numval = (+this.filters[l].val.toString());\n            if (this.filters[l].key == key && numval >= filter.val) {\n                delete this.filters[l];\n            }\n        }\n        this.filters[key + '<'] = filter;\n    } else if (op === '<=') {\n        for (var m in this.filters) {\n            numval = (+this.filters[m].val.toString());\n            if (this.filters[m].key == key && numval > filter.val) {\n                delete this.filters[m];\n            }\n        }\n        if (this.filters[key + '!=' + filter.val] !== undefined) {\n            delete this.filters[key + '!=' + filter.val];\n            filter.op = '<';\n            this.filters[key + '<'] = filter;\n        }\n        else {\n            this.filters[key + '<='] = filter;\n        }\n    }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/fontset.js\":[function(require,module,exports){\n(function(tree) {\n\ntree._getFontSet = function(env, fonts) {\n    var fontKey = fonts.join('');\n    if (env._fontMap && env._fontMap[fontKey]) {\n        return env._fontMap[fontKey];\n    }\n\n    var new_fontset = new tree.FontSet(env, fonts);\n    env.effects.push(new_fontset);\n    if (!env._fontMap) env._fontMap = {};\n    env._fontMap[fontKey] = new_fontset;\n    return new_fontset;\n};\n\ntree.FontSet = function FontSet(env, fonts) {\n    this.fonts = fonts;\n    this.name = 'fontset-' + env.effects.length;\n};\n\ntree.FontSet.prototype.toXML = function(env) {\n    return '<FontSet name=\"' +\n        this.name +\n        '\">\\n' +\n        this.fonts.map(function(f) {\n            return '  <Font face-name=\"' + f +'\"/>';\n        }).join('\\n') +\n        '\\n</FontSet>';\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/frame_offset.js\":[function(require,module,exports){\nvar tree = require('../tree');\n\n// Storage for Frame offset value\n// and stores them as bit-sequences so that they can be combined,\n// inverted, and compared quickly.\ntree.FrameOffset = function(op, value, index) {\n    value = parseInt(value, 10);\n    if (value > tree.FrameOffset.max || value <= 0) {\n        throw {\n            message: 'Only frame-offset levels between 1 and ' +\n                tree.FrameOffset.max + ' supported.',\n            index: index\n        };\n    }\n\n    if (op !== '=') {\n        throw {\n            message: 'only = operator is supported for frame-offset',\n            index: index\n        };\n    }\n    return value;\n};\n\ntree.FrameOffset.max = 32;\ntree.FrameOffset.none = 0;\n\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/imagefilter.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.ImageFilter = function ImageFilter(filter, args) {\n    this.filter = filter;\n    this.args = args || null;\n};\n\ntree.ImageFilter.prototype = {\n    is: 'imagefilter',\n    ev: function() { return this; },\n\n    toString: function() {\n        if (this.args) {\n            return this.filter + '(' + this.args.join(',') + ')';\n        } else {\n            return this.filter;\n        }\n    }\n};\n\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/invalid.js\":[function(require,module,exports){\n(function (tree) {\ntree.Invalid = function Invalid(chunk, index, message) {\n    this.chunk = chunk;\n    this.index = index;\n    this.type = 'syntax';\n    this.message = message || \"Invalid code: \" + this.chunk;\n};\n\ntree.Invalid.prototype.is = 'invalid';\n\ntree.Invalid.prototype.ev = function(env) {\n    env.error({\n        chunk: this.chunk,\n        index: this.index,\n        type: 'syntax',\n        message: this.message || \"Invalid code: \" + this.chunk\n    });\n    return {\n        is: 'undefined'\n    };\n};\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/keyword.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Keyword = function Keyword(value) {\n    this.value = value;\n    var special = {\n        'transparent': 'color',\n        'true': 'boolean',\n        'false': 'boolean'\n    };\n    this.is = special[value] ? special[value] : 'keyword';\n};\ntree.Keyword.prototype = {\n    ev: function() { return this; },\n    toString: function() { return this.value; }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/layer.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.LayerXML = function(obj, styles) {\n    var dsoptions = [];\n    for (var i in obj.Datasource) {\n        dsoptions.push('<Parameter name=\"' + i + '\"><![CDATA[' +\n            obj.Datasource[i] + ']]></Parameter>');\n    }\n\n    var prop_string = '';\n    for (var prop in obj.properties) {\n        if (prop === 'minzoom') {\n            prop_string += '  maxzoom=\"' + tree.Zoom.ranges[obj.properties[prop]] + '\"\\n';\n        } else if (prop === 'maxzoom') {\n            prop_string += '  minzoom=\"' + tree.Zoom.ranges[obj.properties[prop]+1] + '\"\\n';\n        } else {\n            prop_string += '  ' + prop + '=\"' + obj.properties[prop] + '\"\\n';\n        }\n    }\n\n    return '<Layer' +\n        ' name=\"' + obj.name + '\"\\n' +\n        prop_string +\n        ((typeof obj.status === 'undefined') ? '' : '  status=\"' + obj.status + '\"\\n') +\n        ((typeof obj.srs === 'undefined') ? '' : '  srs=\"' + obj.srs + '\"') + '>\\n    ' +\n        styles.reverse().map(function(s) {\n            return '<StyleName>' + s + '</StyleName>';\n        }).join('\\n    ') +\n        (dsoptions.length ?\n        '\\n    <Datasource>\\n       ' +\n        dsoptions.join('\\n       ') +\n        '\\n    </Datasource>\\n'\n        : '') +\n        '  </Layer>\\n';\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/literal.js\":[function(require,module,exports){\n// A literal is a literal string for Mapnik - the\n// result of the combination of a `tree.Field` with any\n// other type.\n(function(tree) {\n\ntree.Literal = function Field(content) {\n    this.value = content || '';\n    this.is = 'field';\n};\n\ntree.Literal.prototype = {\n    toString: function() {\n        return this.value;\n    },\n    'ev': function() {\n        return this;\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/operation.js\":[function(require,module,exports){\n// An operation is an expression with an op in between two operands,\n// like 2 + 1.\n(function(tree) {\n\ntree.Operation = function Operation(op, operands, index) {\n    this.op = op.trim();\n    this.operands = operands;\n    this.index = index;\n};\n\ntree.Operation.prototype.is = 'operation';\n\ntree.Operation.prototype.ev = function(env) {\n    var a = this.operands[0].ev(env),\n        b = this.operands[1].ev(env),\n        temp;\n\n    if (a.is === 'undefined' || b.is === 'undefined') {\n        return {\n            is: 'undefined',\n            value: 'undefined'\n        };\n    }\n\n    if (a instanceof tree.Dimension && b instanceof tree.Color) {\n        if (this.op === '*' || this.op === '+') {\n            temp = b, b = a, a = temp;\n        } else {\n            env.error({\n                name: \"OperationError\",\n                message: \"Can't substract or divide a color from a number\",\n                index: this.index\n            });\n        }\n    }\n\n    // Only concatenate plain strings, because this is easily\n    // pre-processed\n    if (a instanceof tree.Quoted && b instanceof tree.Quoted && this.op !== '+') {\n        env.error({\n           message: \"Can't subtract, divide, or multiply strings.\",\n           index: this.index,\n           type: 'runtime',\n           filename: this.filename\n        });\n        return {\n            is: 'undefined',\n            value: 'undefined'\n        };\n    }\n\n    // Fields, literals, dimensions, and quoted strings can be combined.\n    if (a instanceof tree.Field || b instanceof tree.Field ||\n        a instanceof tree.Literal || b instanceof tree.Literal) {\n        if (a.is === 'color' || b.is === 'color') {\n            env.error({\n               message: \"Can't subtract, divide, or multiply colors in expressions.\",\n               index: this.index,\n               type: 'runtime',\n               filename: this.filename\n            });\n            return {\n                is: 'undefined',\n                value: 'undefined'\n            };\n        } else {\n            return new tree.Literal(a.ev(env).toString(true) + this.op + b.ev(env).toString(true));\n        }\n    }\n\n    if (a.operate === undefined) {\n        env.error({\n           message: 'Cannot do math with type ' + a.is + '.',\n           index: this.index,\n           type: 'runtime',\n           filename: this.filename\n        });\n        return {\n            is: 'undefined',\n            value: 'undefined'\n        };\n    }\n\n    return a.operate(env, this.op, b);\n};\n\ntree.operate = function(op, a, b) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '%': return a % b;\n        case '/': return a / b;\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/quoted.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Quoted = function Quoted(content) {\n    this.value = content || '';\n};\n\ntree.Quoted.prototype = {\n    is: 'string',\n\n    toString: function(quotes) {\n        var escapedValue = this.value\n            .replace(/&/g, '&amp;')\n        var xmlvalue = escapedValue\n            .replace(/\\'/g, '\\\\\\'')\n            .replace(/\\\"/g, '&quot;')\n            .replace(/</g, '&lt;')\n            .replace(/\\>/g, '&gt;');\n        return (quotes === true) ? \"'\" + xmlvalue + \"'\" : escapedValue;\n    },\n\n    'ev': function() {\n        return this;\n    },\n\n    operate: function(env, op, other) {\n        return new tree.Quoted(tree.operate(op, this.toString(), other.toString(this.contains_field)));\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/reference.js\":[function(require,module,exports){\n(function (global){\n// Carto pulls in a reference from the `mapnik-reference`\n// module. This file builds indexes from that file for its various\n// options, and provides validation methods for property: value\n// combinations.\n(function(tree) {\n\nvar _ = global._ || require('underscore'),\n    ref = {};\n\nref.setData = function(data) {\n    ref.data = data;\n    ref.selector_cache = generateSelectorCache(data);\n    ref.mapnikFunctions = generateMapnikFunctions(data);\n\n    ref.mapnikFunctions.matrix = [6];\n    ref.mapnikFunctions.translate = [1, 2];\n    ref.mapnikFunctions.scale = [1, 2];\n    ref.mapnikFunctions.rotate = [1, 3];\n    ref.mapnikFunctions.skewX = [1];\n    ref.mapnikFunctions.skewY = [1];\n\n    ref.required_cache = generateRequiredProperties(data);\n};\n\nref.setVersion = function(version) {\n    var mapnik_reference = require('mapnik-reference');\n    if (mapnik_reference.version.hasOwnProperty(version)) {\n        ref.setData(mapnik_reference.version[version]);\n        return true;\n    } else {\n        return false;\n    }\n};\n\nref.selectorData = function(selector, i) {\n    if (ref.selector_cache[selector]) return ref.selector_cache[selector][i];\n};\n\nref.validSelector = function(selector) { return !!ref.selector_cache[selector]; };\nref.selectorName = function(selector) { return ref.selectorData(selector, 2); };\nref.selector = function(selector) { return ref.selectorData(selector, 0); };\nref.symbolizer = function(selector) { return ref.selectorData(selector, 1); };\n\nfunction generateSelectorCache(data) {\n    var index = {};\n    for (var i in data.symbolizers) {\n        for (var j in data.symbolizers[i]) {\n            if (data.symbolizers[i][j].hasOwnProperty('css')) {\n                index[data.symbolizers[i][j].css] = [data.symbolizers[i][j], i, j];\n            }\n        }\n    }\n    return index;\n}\n\nfunction generateMapnikFunctions(data) {\n    var functions = {};\n    for (var i in data.symbolizers) {\n        for (var j in data.symbolizers[i]) {\n            if (data.symbolizers[i][j].type === 'functions') {\n                for (var k = 0; k < data.symbolizers[i][j].functions.length; k++) {\n                    var fn = data.symbolizers[i][j].functions[k];\n                    functions[fn[0]] = fn[1];\n                }\n            }\n        }\n    }\n    return functions;\n}\n\nfunction generateRequiredProperties(data) {\n    var cache = {};\n    for (var symbolizer_name in data.symbolizers) {\n        cache[symbolizer_name] = [];\n        for (var j in data.symbolizers[symbolizer_name]) {\n            if (data.symbolizers[symbolizer_name][j].required) {\n                cache[symbolizer_name].push(data.symbolizers[symbolizer_name][j].css);\n            }\n        }\n    }\n    return cache;\n}\n\nref.requiredProperties = function(symbolizer_name, rules) {\n    var req = ref.required_cache[symbolizer_name];\n    for (var i in req) {\n        if (!(req[i] in rules)) {\n            return 'Property ' + req[i] + ' required for defining ' +\n                symbolizer_name + ' styles.';\n        }\n    }\n};\n\n// TODO: finish implementation - this is dead code\nref._validateValue = {\n    'font': function(env, value) {\n        if (env.validation_data && env.validation_data.fonts) {\n            return env.validation_data.fonts.indexOf(value) != -1;\n        } else {\n            return true;\n        }\n    }\n};\n\nref.isFont = function(selector) {\n    return ref.selector(selector).validate == 'font';\n};\n\n// https://gist.github.com/982927\nref.editDistance = function(a, b){\n    if (a.length === 0) return b.length;\n    if (b.length === 0) return a.length;\n    var matrix = [];\n    for (var i = 0; i <= b.length; i++) { matrix[i] = [i]; }\n    for (var j = 0; j <= a.length; j++) { matrix[0][j] = j; }\n    for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n            if (b.charAt(i-1) == a.charAt(j-1)) {\n                matrix[i][j] = matrix[i-1][j-1];\n            } else {\n                matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution\n                    Math.min(matrix[i][j-1] + 1, // insertion\n                    matrix[i-1][j] + 1)); // deletion\n            }\n        }\n    }\n    return matrix[b.length][a.length];\n};\n\nfunction validateFunctions(value, selector) {\n    if (value.value[0].is === 'string') return true;\n    for (var i in value.value) {\n        for (var j in value.value[i].value) {\n            if (value.value[i].value[j].is !== 'call') return false;\n            var f = _.find(ref\n                .selector(selector).functions, function(x) {\n                    return x[0] == value.value[i].value[j].name;\n                });\n            if (!(f && f[1] == -1)) {\n                // This filter is unknown or given an incorrect number of arguments\n                if (!f || f[1] !== value.value[i].value[j].args.length) return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction validateKeyword(value, selector) {\n    if (typeof ref.selector(selector).type === 'object') {\n        return ref.selector(selector).type\n            .indexOf(value.value[0].value) !== -1;\n    } else {\n        // allow unquoted keywords as strings\n        return ref.selector(selector).type === 'string';\n    }\n}\n\nref.validValue = function(env, selector, value) {\n    var i, j;\n    // TODO: handle in reusable way\n    if (!ref.selector(selector)) {\n        return false;\n    } else if (value.value[0].is == 'keyword') {\n        return validateKeyword(value, selector);\n    } else if (value.value[0].is == 'undefined') {\n        // caught earlier in the chain - ignore here so that\n        // error is not overridden\n        return true;\n    } else if (ref.selector(selector).type == 'numbers') {\n        for (i in value.value) {\n            if (value.value[i].is !== 'float') {\n                return false;\n            }\n        }\n        return true;\n    } else if (ref.selector(selector).type == 'tags') {\n        if (!value.value) return false;\n        if (!value.value[0].value) {\n            return value.value[0].is === 'tag';\n        }\n        for (i = 0; i < value.value[0].value.length; i++) {\n            if (value.value[0].value[i].is !== 'tag') return false;\n        }\n        return true;\n    } else if (ref.selector(selector).type == 'functions') {\n        // For backwards compatibility, you can specify a string for `functions`-compatible\n        // values, though they will not be validated.\n        return validateFunctions(value, selector);\n    } else if (ref.selector(selector).type === 'unsigned') {\n        if (value.value[0].is === 'float') {\n            value.value[0].round();\n            return true;\n        } else {\n            return false;\n        }\n    } else if ((ref.selector(selector).expression)) {\n        return true;\n    } else {\n        if (ref.selector(selector).validate) {\n            var valid = false;\n            for (i = 0; i < value.value.length; i++) {\n                if (ref.selector(selector).type == value.value[i].is &&\n                    ref\n                        ._validateValue\n                            [ref.selector(selector).validate]\n                            (env, value.value[i].value)) {\n                    return true;\n                }\n            }\n            return valid;\n        } else {\n            return ref.selector(selector).type == value.value[0].is;\n        }\n    }\n};\n\ntree.Reference = ref;\n\n})(require('../tree'));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"mapnik-reference\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/mapnik-reference/index.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/rule.js\":[function(require,module,exports){\n(function(tree) {\n// a rule is a single property and value combination, or variable\n// name and value combination, like\n// polygon-opacity: 1.0; or @opacity: 1.0;\ntree.Rule = function Rule(name, value, index, filename) {\n    var parts = name.split('/');\n    this.name = parts.pop();\n    this.instance = parts.length ? parts[0] : '__default__';\n    this.value = (value instanceof tree.Value) ?\n        value : new tree.Value([value]);\n    this.index = index;\n    this.symbolizer = tree.Reference.symbolizer(this.name);\n    this.filename = filename;\n    this.variable = (name.charAt(0) === '@');\n};\n\ntree.Rule.prototype.is = 'rule';\n\ntree.Rule.prototype.clone = function() {\n    var clone = Object.create(tree.Rule.prototype);\n    clone.name = this.name;\n    clone.value = this.value;\n    clone.index = this.index;\n    clone.instance = this.instance;\n    clone.symbolizer = this.symbolizer;\n    clone.filename = this.filename;\n    clone.variable = this.variable;\n    return clone;\n};\n\ntree.Rule.prototype.updateID = function() {\n    return this.id = this.zoom + '#' + this.instance + '#' + this.name;\n};\n\ntree.Rule.prototype.toString = function() {\n    return '[' + tree.Zoom.toString(this.zoom) + '] ' + this.name + ': ' + this.value;\n};\n\nfunction getMean(name) {\n    return Object.keys(tree.Reference.selector_cache).map(function(f) {\n        return [f, tree.Reference.editDistance(name, f)];\n    }).sort(function(a, b) { return a[1] - b[1]; });\n}\n\n// second argument, if true, outputs the value of this\n// rule without the usual attribute=\"content\" wrapping. Right\n// now this is just for the TextSymbolizer, but applies to other\n// properties in reference.json which specify serialization=content\ntree.Rule.prototype.toXML = function(env, content, sep, format) {\n    if (!tree.Reference.validSelector(this.name)) {\n        var mean = getMean(this.name);\n        var mean_message = '';\n        if (mean[0][1] < 3) {\n            mean_message = '. Did you mean ' + mean[0][0] + '?';\n        }\n        return env.error({\n            message: \"Unrecognized rule: \" + this.name + mean_message,\n            index: this.index,\n            type: 'syntax',\n            filename: this.filename\n        });\n    }\n\n    if ((this.value instanceof tree.Value) &&\n        !tree.Reference.validValue(env, this.name, this.value)) {\n        if (!tree.Reference.selector(this.name)) {\n            return env.error({\n                message: 'Unrecognized property: ' +\n                    this.name,\n                index: this.index,\n                type: 'syntax',\n                filename: this.filename\n            });\n        } else {\n            var typename;\n            if (tree.Reference.selector(this.name).validate) {\n                typename = tree.Reference.selector(this.name).validate;\n            } else if (typeof tree.Reference.selector(this.name).type === 'object') {\n                typename = 'keyword (options: ' + tree.Reference.selector(this.name).type.join(', ') + ')';\n            } else {\n                typename = tree.Reference.selector(this.name).type;\n            }\n            return env.error({\n                message: 'Invalid value for ' +\n                    this.name +\n                    ', the type ' + typename +\n                    ' is expected. ' + this.value +\n                    ' (of type ' + this.value.value[0].is + ') ' +\n                    ' was given.',\n                index: this.index,\n                type: 'syntax',\n                filename: this.filename\n            });\n        }\n    }\n\n    if (this.variable) {\n        return '';\n    } else if (tree.Reference.isFont(this.name) && this.value.value.length > 1) {\n        var f = tree._getFontSet(env, this.value.value);\n        return 'fontset-name=\"' + f.name + '\"';\n    } else if (content) {\n        return this.value.toString(env, this.name, sep);\n    } else {\n        return tree.Reference.selectorName(this.name) +\n            '=\"' +\n            this.value.toString(env, this.name) +\n            '\"';\n    }\n};\n\n// TODO: Rule ev chain should add fontsets to env.frames\ntree.Rule.prototype.ev = function(context) {\n    return new tree.Rule(this.name,\n        this.value.ev(context),\n        this.index,\n        this.filename);\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/ruleset.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Ruleset = function Ruleset(selectors, rules) {\n    this.selectors = selectors;\n    this.rules = rules;\n    // static cache of find() function\n    this._lookups = {};\n};\ntree.Ruleset.prototype = {\n    is: 'ruleset',\n    'ev': function(env) {\n        var i,\n            ruleset = new tree.Ruleset(this.selectors, this.rules.slice(0));\n        ruleset.root = this.root;\n\n        // push the current ruleset to the frames stack\n        env.frames.unshift(ruleset);\n\n        // Evaluate everything else\n        for (i = 0, rule; i < ruleset.rules.length; i++) {\n            rule = ruleset.rules[i];\n            ruleset.rules[i] = rule.ev ? rule.ev(env) : rule;\n        }\n\n        // Pop the stack\n        env.frames.shift();\n\n        return ruleset;\n    },\n    match: function(args) {\n        return !args || args.length === 0;\n    },\n    variables: function() {\n        if (this._variables) { return this._variables; }\n        else {\n            return this._variables = this.rules.reduce(function(hash, r) {\n                if (r instanceof tree.Rule && r.variable === true) {\n                    hash[r.name] = r;\n                }\n                return hash;\n            }, {});\n        }\n    },\n    variable: function(name) {\n        return this.variables()[name];\n    },\n    rulesets: function() {\n        if (this._rulesets) { return this._rulesets; }\n        else {\n            return this._rulesets = this.rules.filter(function(r) {\n                return (r instanceof tree.Ruleset);\n            });\n        }\n    },\n    find: function(selector, self) {\n        self = self || this;\n        var rules = [], rule, match,\n            key = selector.toString();\n\n        if (key in this._lookups) { return this._lookups[key]; }\n\n        this.rulesets().forEach(function(rule) {\n            if (rule !== self) {\n                for (var j = 0; j < rule.selectors.length; j++) {\n                    match = selector.match(rule.selectors[j]);\n                    if (match) {\n                        if (selector.elements.length > 1) {\n                            Array.prototype.push.apply(rules, rule.find(\n                                new tree.Selector(null, null, null, selector.elements.slice(1)), self));\n                        } else {\n                            rules.push(rule);\n                        }\n                        break;\n                    }\n                }\n            }\n        });\n        return this._lookups[key] = rules;\n    },\n    // Zooms can use variables. This replaces tree.Zoom objects on selectors\n    // with simple bit-arrays that we can compare easily.\n    evZooms: function(env) {\n        for (var i = 0; i < this.selectors.length; i++) {\n            var zval = tree.Zoom.all;\n            for (var z = 0; z < this.selectors[i].zoom.length; z++) {\n                zval = zval & this.selectors[i].zoom[z].ev(env).zoom;\n            }\n            this.selectors[i].zoom = zval;\n        }\n    },\n    flatten: function(result, parents, env) {\n        var selectors = [], i, j;\n        if (this.selectors.length === 0) {\n            env.frames = env.frames.concat(this.rules);\n        }\n        // evaluate zoom variables on this object.\n        this.evZooms(env);\n        for (i = 0; i < this.selectors.length; i++) {\n            var child = this.selectors[i];\n\n            if (!child.filters) {\n                // TODO: is this internal inconsistency?\n                // This is an invalid filterset.\n                continue;\n            }\n\n            if (parents.length) {\n                for (j = 0; j < parents.length; j++) {\n                    var parent = parents[j];\n\n                    var mergedFilters = parent.filters.cloneWith(child.filters);\n                    if (mergedFilters === null) {\n                        // Filters could be added, but they didn't change the\n                        // filters. This means that we only have to clone when\n                        // the zoom levels or the attachment is different too.\n                        if (parent.zoom === (parent.zoom & child.zoom) &&\n                            parent.frame_offset === child.frame_offset &&\n                            parent.attachment === child.attachment &&\n                            parent.elements.join() === child.elements.join()) {\n                            selectors.push(parent);\n                            continue;\n                        } else {\n                            mergedFilters = parent.filters;\n                        }\n                    } else if (!mergedFilters) {\n                        // The merged filters are invalid, that means we don't\n                        // have to clone.\n                        continue;\n                    }\n\n                    var clone = Object.create(tree.Selector.prototype);\n                    clone.filters = mergedFilters;\n                    clone.zoom = parent.zoom & child.zoom;\n                    clone.frame_offset = child.frame_offset;\n                    clone.elements = parent.elements.concat(child.elements);\n                    if (parent.attachment && child.attachment) {\n                        clone.attachment = parent.attachment + '/' + child.attachment;\n                    }\n                    else clone.attachment = child.attachment || parent.attachment;\n                    clone.conditions = parent.conditions + child.conditions;\n                    clone.index = child.index;\n                    selectors.push(clone);\n                }\n            } else {\n                selectors.push(child);\n            }\n        }\n\n        var rules = [];\n        for (i = 0; i < this.rules.length; i++) {\n            var rule = this.rules[i];\n\n            // Recursively flatten any nested rulesets\n            if (rule instanceof tree.Ruleset) {\n                rule.flatten(result, selectors, env);\n            } else if (rule instanceof tree.Rule) {\n                rules.push(rule);\n            } else if (rule instanceof tree.Invalid) {\n                env.error(rule);\n            }\n        }\n\n        var index = rules.length ? rules[0].index : false;\n        for (i = 0; i < selectors.length; i++) {\n            // For specificity sort, use the position of the first rule to allow\n            // defining attachments that are under current element as a descendant\n            // selector.\n            if (index !== false) {\n                selectors[i].index = index;\n            }\n            result.push(new tree.Definition(selectors[i], rules.slice()));\n        }\n\n        return result;\n    }\n};\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/selector.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Selector = function Selector(filters, zoom, frame_offset, elements, attachment, conditions, index) {\n    this.elements = elements || [];\n    this.attachment = attachment;\n    this.filters = filters || {};\n    this.frame_offset = frame_offset;\n    this.zoom = typeof zoom !== 'undefined' ? zoom : tree.Zoom.all;\n    this.conditions = conditions;\n    this.index = index;\n};\n\n// Determine the specificity of this selector\n// based on the specificity of its elements - calling\n// Element.specificity() in order to do so\n//\n// [ID, Class, Filters, Position in document]\ntree.Selector.prototype.specificity = function() {\n    return this.elements.reduce(function(memo, e) {\n        var spec = e.specificity();\n        memo[0] += spec[0];\n        memo[1] += spec[1];\n        return memo;\n    }, [0, 0, this.conditions, this.index]);\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/style.js\":[function(require,module,exports){\n(function (global){\n(function(tree) {\nvar _ = global._ || require('underscore');\n\n// Given a style's name, attachment, definitions, and an environment object,\n// return a stringified style for Mapnik\ntree.StyleXML = function(name, attachment, definitions, env) {\n    var existing = {};\n    var image_filters = [], image_filters_inflate = [], direct_image_filters = [], comp_op = [], opacity = [];\n\n    for (var i = 0; i < definitions.length; i++) {\n        for (var j = 0; j < definitions[i].rules.length; j++) {\n            if (definitions[i].rules[j].name === 'image-filters') {\n                image_filters.push(definitions[i].rules[j]);\n            }\n            if (definitions[i].rules[j].name === 'image-filters-inflate') {\n                image_filters_inflate.push(definitions[i].rules[j]);\n            }\n            if (definitions[i].rules[j].name === 'direct-image-filters') {\n                direct_image_filters.push(definitions[i].rules[j]);\n            }\n            if (definitions[i].rules[j].name === 'comp-op') {\n                comp_op.push(definitions[i].rules[j]);\n            }\n            if (definitions[i].rules[j].name === 'opacity') {\n                opacity.push(definitions[i].rules[j]);\n            }\n        }\n    }\n\n    var rules = definitions.map(function(definition) {\n        return definition.toXML(env, existing);\n    });\n\n    var attrs_xml = '';\n\n    if (image_filters.length) {\n        attrs_xml += ' image-filters=\"' + _.chain(image_filters)\n            // prevent identical filters from being duplicated in the style\n            .uniq(function(i) { return i.id; }).map(function(f) {\n            return f.ev(env).toXML(env, true, ',', 'image-filter');\n        }).value().join(',') + '\"';\n    }\n\n    if (image_filters_inflate.length) {\n        attrs_xml += ' image-filters-inflate=\"' + image_filters_inflate[0].value.ev(env).toString() + '\"';\n    }\n\n    if (direct_image_filters.length) {\n        attrs_xml += ' direct-image-filters=\"' + _.chain(direct_image_filters)\n            // prevent identical filters from being duplicated in the style\n            .uniq(function(i) { return i.id; }).map(function(f) {\n            return f.ev(env).toXML(env, true, ',', 'direct-image-filter');\n        }).value().join(',') + '\"';\n    }\n\n    if (comp_op.length && comp_op[0].value.ev(env).value != 'src-over') {\n        attrs_xml += ' comp-op=\"' + comp_op[0].value.ev(env).toString() + '\"';\n    }\n\n    if (opacity.length && opacity[0].value.ev(env).value != 1) {\n        attrs_xml += ' opacity=\"' + opacity[0].value.ev(env).toString() + '\"';\n    }\n    var rule_string = rules.join('');\n    if (!attrs_xml && !rule_string) return '';\n    return '<Style name=\"' + name + '\" filter-mode=\"first\"' + attrs_xml + '>\\n' + rule_string + '</Style>';\n};\n\n})(require('../tree'));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\",\"underscore\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/url.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.URL = function URL(val, paths) {\n    this.value = val;\n    this.paths = paths;\n};\n\ntree.URL.prototype = {\n    is: 'uri',\n    toString: function() {\n        return this.value.toString();\n    },\n    ev: function(ctx) {\n        return new tree.URL(this.value.ev(ctx), this.paths);\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/value.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Value = function Value(value) {\n    this.value = value;\n};\n\ntree.Value.prototype = {\n    is: 'value',\n    ev: function(env) {\n        if (this.value.length === 1) {\n            return this.value[0].ev(env);\n        } else {\n            return new tree.Value(this.value.map(function(v) {\n                return v.ev(env);\n            }));\n        }\n    },\n    toString: function(env, selector, sep, format) {\n        return this.value.map(function(e) {\n            return e.toString(env, format);\n        }).join(sep || ', ');\n    },\n    clone: function() {\n        var obj = Object.create(tree.Value.prototype);\n        if (Array.isArray(obj)) obj.value = this.value.slice();\n        else obj.value = this.value;\n        obj.is = this.is;\n        return obj;\n    },\n\n    toJS: function(env) {\n      //var v = this.value[0].value[0];\n      var val = this.ev(env);\n      var v = val.toString();\n      if(val.is === \"color\" || val.is === 'uri' || val.is === 'string' || val.is === 'keyword') {\n        v = \"'\" + v + \"'\";\n      } else if (val.is === 'field') {\n        // replace [variable] by ctx['variable']\n        v = v.replace(/\\[(.*)\\]/g, \"data['$1']\");\n      }else if (val.is === 'call') {\n        v = JSON.stringify({\n            name: val.name,\n            args: val.args\n        })\n      }\n      return \"_value = \" + v + \";\";\n    }\n\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/variable.js\":[function(require,module,exports){\n(function(tree) {\n\ntree.Variable = function Variable(name, index, filename) {\n    this.name = name;\n    this.index = index;\n    this.filename = filename;\n};\n\ntree.Variable.prototype = {\n    is: 'variable',\n    toString: function() {\n        return this.name;\n    },\n    ev: function(env) {\n        var variable,\n            v,\n            name = this.name;\n\n        if (this._css) return this._css;\n\n        var thisframe = env.frames.filter(function(f) {\n            return f.name == this.name;\n        }.bind(this));\n        if (thisframe.length) {\n            return thisframe[0].value.ev(env);\n        } else {\n            env.error({\n                message: 'variable ' + this.name + ' is undefined',\n                index: this.index,\n                type: 'runtime',\n                filename: this.filename\n            });\n            return {\n                is: 'undefined',\n                value: 'undefined'\n            };\n        }\n    }\n};\n\n})(require('../tree'));\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree/zoom.js\":[function(require,module,exports){\nvar tree = require('../tree');\n\n// Storage for zoom ranges. Only supports continuous ranges,\n// and stores them as bit-sequences so that they can be combined,\n// inverted, and compared quickly.\ntree.Zoom = function(op, value, index) {\n    this.op = op;\n    this.value = value;\n    this.index = index;\n};\n\ntree.Zoom.prototype.setZoom = function(zoom) {\n    this.zoom = zoom;\n    return this;\n};\n\ntree.Zoom.prototype.ev = function(env) {\n    var start = 0,\n        end = Infinity,\n        value = parseInt(this.value.ev(env).toString(), 10),\n        zoom = 0;\n\n    if (value > tree.Zoom.maxZoom || value < 0) {\n        env.error({\n            message: 'Only zoom levels between 0 and ' +\n                tree.Zoom.maxZoom + ' supported.',\n            index: this.index\n        });\n    }\n\n    switch (this.op) {\n        case '=':\n            this.zoom = 1 << value;\n            return this;\n        case '>':\n            start = value + 1;\n            break;\n        case '>=':\n            start = value;\n            break;\n        case '<':\n            end = value - 1;\n            break;\n        case '<=':\n            end = value;\n            break;\n    }\n    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {\n        if (i >= start && i <= end) {\n            zoom |= (1 << i);\n        }\n    }\n    this.zoom = zoom;\n    return this;\n};\n\ntree.Zoom.prototype.toString = function() {\n    return this.zoom;\n};\n\n// Covers all zoomlevels from 0 to 22\ntree.Zoom.all = 0x7FFFFF;\n\ntree.Zoom.maxZoom = 22;\n\ntree.Zoom.ranges = {\n     0: 1000000000,\n     1: 500000000,\n     2: 200000000,\n     3: 100000000,\n     4: 50000000,\n     5: 25000000,\n     6: 12500000,\n     7: 6500000,\n     8: 3000000,\n     9: 1500000,\n    10: 750000,\n    11: 400000,\n    12: 200000,\n    13: 100000,\n    14: 50000,\n    15: 25000,\n    16: 12500,\n    17: 5000,\n    18: 2500,\n    19: 1500,\n    20: 750,\n    21: 500,\n    22: 250,\n    23: 100\n};\n\n// Only works for single range zooms. `[XXX....XXXXX.........]` is invalid.\ntree.Zoom.prototype.toXML = function() {\n    var conditions = [];\n    if (this.zoom != tree.Zoom.all) {\n        var start = null, end = null;\n        for (var i = 0; i <= tree.Zoom.maxZoom; i++) {\n            if (this.zoom & (1 << i)) {\n                if (start === null) start = i;\n                end = i;\n            }\n        }\n        if (start > 0) conditions.push('    <MaxScaleDenominator>' +\n            tree.Zoom.ranges[start] + '</MaxScaleDenominator>\\n');\n        if (end < 22) conditions.push('    <MinScaleDenominator>' +\n            tree.Zoom.ranges[end + 1] + '</MinScaleDenominator>\\n');\n    }\n    return conditions;\n};\n\ntree.Zoom.prototype.toString = function() {\n    var str = '';\n    for (var i = 0; i <= tree.Zoom.maxZoom; i++) {\n        str += (this.zoom & (1 << i)) ? 'X' : '.';\n    }\n    return str;\n};\n\n},{\"../tree\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/lib/carto/tree.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/mapnik-reference/index.js\":[function(require,module,exports){\n(function (__dirname){\nvar fs = require('fs'),\n    path = require('path'),\n    existsSync = require('fs').existsSync || require('path').existsSync;\n\n// Load all stated versions into the module exports\nmodule.exports.version = {};\n\nvar refs = [\n '2.0.0',\n '2.0.1',\n '2.0.2',\n '2.1.0',\n '2.1.1',\n '2.2.0',\n '2.3.0',\n '3.0.0'\n];\n\nrefs.map(function(version) {\n    module.exports.version[version] = require(path.join(__dirname, version, 'reference.json'));\n    var ds_path = path.join(__dirname, version, 'datasources.json');\n    if (existsSync(ds_path)) {\n        module.exports.version[version].datasources = require(ds_path).datasources;\n    }\n});\n\n}).call(this,\"/node_modules/torque.js/node_modules/carto/node_modules/mapnik-reference\")\n},{\"fs\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/lib/_empty.js\",\"path\":\"/Users/tiatia/projects/reusable-components/map-components/node_modules/browserify/node_modules/path-browserify/index.js\"}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/node_modules/underscore/underscore.js\":[function(require,module,exports){\n//     Underscore.js 1.6.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.6.0';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return obj;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, length = obj.length; i < length; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results.push(iterator.call(context, value, index, list));\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);\n    each(obj, function(value, index, list) {\n      if (predicate.call(context, value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !predicate.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, predicate, context) {\n    predicate || (predicate = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = predicate.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    var result = -Infinity, lastComputed = -Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed > lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    var result = Infinity, lastComputed = Infinity;\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n\n  // Shuffle an array, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return value;\n    return _.property(value);\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iterator, context) {\n      var result = {};\n      iterator = lookupIterator(iterator);\n      each(obj, function(value, index) {\n        var key = iterator.call(context, value, index, obj);\n        behavior(result, key, value);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, key, value) {\n    _.has(result, key) ? result[key].push(value) : result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, key, value) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, key) {\n    _.has(result, key) ? result[key]++ : result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n == null) || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    each(input, function(value) {\n      if (_.isArray(value) || _.isArguments(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Split an array into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(array, predicate) {\n    var pass = [], fail = [];\n    each(array, function(elem) {\n      (predicate(elem) ? pass : fail).push(elem);\n    });\n    return [pass, fail];\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.contains(other, item);\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var length = _.max(_.pluck(arguments, 'length').concat(0));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, '' + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(length);\n\n    while(idx < length) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) throw new Error('bindAll must be passed function names');\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    options || (options = {});\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n      if (last < wait) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = new Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = new Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] === void 0) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                             _.isFunction(bCtor) && (bCtor instanceof bCtor))\n                        && ('constructor' in a && 'constructor' in b)) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function () {\n      return value;\n    };\n  };\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    return function(obj) {\n      if (obj === attrs) return true; //avoid comparing an object to itself.\n      for (var key in attrs) {\n        if (attrs[key] !== obj[key])\n          return false;\n      }\n      return true;\n    }\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(Math.max(0, n));\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() { return new Date().getTime(); };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}).call(this);\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/node_modules/torque.js/node_modules/carto/package.json\":[function(require,module,exports){\nmodule.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports=module.exports={\n  \"name\": \"carto\",\n  \"version\": \"0.15.1-cdb1\",\n  \"description\": \"CartoCSS Stylesheet Compiler\",\n  \"url\": \"https://github.com/cartodb/carto\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"http://github.com/cartodb/carto.git\"\n  },\n  \"author\": {\n    \"name\": \"CartoDB\",\n    \"url\": \"http://cartodb.com/\"\n  },\n  \"keywords\": [\n    \"maps\",\n    \"css\",\n    \"stylesheets\"\n  ],\n  \"contributors\": [\n    {\n      \"name\": \"Tom MacWright\",\n      \"email\": \"macwright@gmail.com\"\n    },\n    {\n      \"name\": \"Konstantin Kfer\"\n    },\n    {\n      \"name\": \"Alexis Sellier\",\n      \"email\": \"self@cloudhead.net\"\n    },\n    {\n      \"name\": \"Raul Ochoa\",\n      \"email\": \"rochoa@cartodb.com\"\n    },\n    {\n      \"name\": \"Javi Santana\",\n      \"email\": \"jsantana@cartodb.com\"\n    }\n  ],\n  \"licenses\": [\n    {\n      \"type\": \"Apache\"\n    }\n  ],\n  \"bin\": {\n    \"carto\": \"./bin/carto\"\n  },\n  \"man\": [\n    \"./man/carto.1\"\n  ],\n  \"main\": \"./lib/carto/index\",\n  \"engines\": {\n    \"node\": \">=0.4.x\"\n  },\n  \"dependencies\": {\n    \"underscore\": \"~1.6.0\",\n    \"mapnik-reference\": \"~6.0.2\",\n    \"optimist\": \"~0.6.0\"\n  },\n  \"devDependencies\": {\n    \"mocha\": \"1.12.x\",\n    \"jshint\": \"0.2.x\",\n    \"sax\": \"0.1.x\",\n    \"istanbul\": \"~0.2.14\",\n    \"coveralls\": \"~2.10.1\",\n    \"browserify\": \"~7.0.0\",\n    \"uglify-js\": \"1.3.3\"\n  },\n  \"scripts\": {\n    \"pretest\": \"npm install\",\n    \"test\": \"mocha -R spec\",\n    \"coverage\": \"istanbul cover ./node_modules/.bin/_mocha && coveralls < ./coverage/lcov.info\"\n  },\n  \"readme\": \"# CartoCSS\\n\\n[![Build Status](https://secure.travis-ci.org/mapbox/carto.png)](http://travis-ci.org/mapbox/carto)\\n\\nIs as stylesheet renderer for javascript, It's an evolution of the Mapnik renderer from Mapbox.\\nPlease, see original [Mapbox repo](http://github.com/mapbox/carto) for more information and credits\\n\\n## Quick Start\\n\\n```javascript\\n// shader is a CartoCSS object\\n\\nvar cartocss = [\\n    '#layer {',\\n    ' marker-width: [property]',\\n    ' marker-fill: red',\\n    '}'\\n].join('')\\nvar shader = new carto.RendererJS().render(cartocss);\\nvar layers = shader.getLayers()\\nfor (var i = 0; i < layers.length; ++i) {\\n    var layer = layers[i];\\n    console.log(\\\"layer name: \\\", layer.fullName())\\n    console.log(\\\"- frames: \\\", layer.frames())\\n    console.log(\\\"- attachment: \\\", layer.attachment())\\n\\n    var layerShader = layer.getStyle({ property: 1 }, { zoom: 10 })\\n    console.log(layerShader['marker-width']) // 1\\n    console.log(layerShader['marker-fill']) // #FF0000\\n}\\n\\n```\\n\\n# API\\n\\n## RendererJS\\n\\n### render(cartocss)\\n\\n## CartoCSS\\n\\ncompiled cartocss object\\n\\n### getLayers\\n\\nreturn the layers, an array of ``CartoCSS.Layer`` object\\n\\n### getDefault\\n\\nreturn the default layer (``CartoCSS.Layer``), usually the Map layer\\n\\n\\n### findLayer(where)\\n\\nfind a layer using where object.\\n\\n```\\nshader.findLayer({ name: 'test' })\\n```\\n\\n## CartoCSS.Layer\\n\\n### getStyle(props, context)\\n\\nreturn the evaluated style:\\n    - props: object containing properties needed to render the style. If the cartocss style uses\\n      some variables they should be passed in this object\\n    - context: rendering context variables like ``zoom`` or animation ``frame``\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n## Reference Documentation\\n\\n* [mapbox.com/carto](http://mapbox.com/carto/)\\n\\n\\n\",\n  \"readmeFilename\": \"README.md\",\n  \"bugs\": {\n    \"url\": \"https://github.com/cartodb/carto/issues\"\n  },\n  \"homepage\": \"https://github.com/cartodb/carto\",\n  \"_id\": \"carto@0.15.1-cdb1\",\n  \"_shasum\": \"62534c2975cbee073f10c6c14a0c7e889c9469e7\",\n  \"_resolved\": \"https://github.com/CartoDB/carto/archive/master.tar.gz\",\n  \"_from\": \"https://github.com/CartoDB/carto/archive/master.tar.gz\"\n}\n\n},{}],\"/Users/tiatia/projects/reusable-components/map-components/src/directives/map_directive.js\":[function(require,module,exports){\nmodule.exports = function() {\n  return {\n    restrict: 'E',\n    replace: true,\n    template: '<div class=\"map-component\"></div>',\n    scope: {},\n    link: function(scope, element, attrs) {\n      L.mapbox.accessToken = 'pk.eyJ1IjoiZWtudXRoIiwiYSI6InA5TFJabjAifQ.zOTDOdaBSMPwZY8ez12r_A';\n      var map = L.mapbox.map(element[0], 'examples.map-y7l23tes')\n          .setView([45.54, -122.63], 12);\n\n    }\n  };\n};\n\n},{}]},{},[\"./src/index.js\"]);\n"],"file":"bundle.js","sourceRoot":"/source/"}